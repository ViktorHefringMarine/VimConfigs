SCRIPT  C:\Users\Lenovo\scoop\apps\neovim\0.6.1\share\nvim\runtime\syntax\vim.vim
Sourced 1 time
Total time:   0.017307
 Self time:   0.012616

count  total (s)   self (s)
                            " Vim syntax file
                            
                            " #############################################################################
                            " #############################################################################
                            " Note: Be careful when merging the upstream version of this file.
                            "       Much of this is generated by scripts/genvimvim.lua
                            "       (installs to $VIMRUNTIME/syntax/vim/generated.vim)
                            " #############################################################################
                            " #############################################################################
                            
                            " Quit when a syntax file was already loaded {{{2
    1              0.000019 if exists("b:current_syntax")
                              finish
    1              0.000002 endif
    1              0.000016 let s:keepcpo = &cpo
    1              0.000016 set cpo&vim
                            
                            " vimTodo: contains common special-notices for comments {{{2
                            " Use the vimCommentGroup cluster to add your own.
    1              0.000012 syn keyword vimTodo contained	COMBAK	FIXME	TODO	XXX
    1              0.000020 syn cluster vimCommentGroup	contains=vimTodo,@Spell
                            
                            " Special and plugin vim commands {{{2
    1              0.000020 syn match   vimCommand contained	"\<z[-+^.=]\=\>"
    1              0.000013 syn keyword vimOnlyCommand contained	fix[del] op[en] sh[ell] P[rint]
    1              0.000008 syn keyword vimStdPlugin contained	DiffOrig Man N[ext] S TOhtml XMLent XMLns
                            
                            " Vim-specific options {{{2
    1              0.000051 syn keyword vimOnlyOption contained	biosk bioskey cp compatible consk conskey cm cryptmethod edcompatible guipty key macatsui mzq mzquantum osfiletype oft renderoptions rop st shelltype sn shortname tenc termencoding ta textauto tx textmode tf ttyfast ttym ttymouse tbi ttybuiltin wiv weirdinvert
                            
                            " Turn-off setting variants
    1              0.000016 syn keyword vimOnlyOption contained	nobiosk nobioskey noconsk noconskey nocp nocompatible noguipty nomacatsui nosn noshortname nota notextauto notx notextmode notf nottyfast notbi nottybuiltin nowiv noweirdinvert
                            
                            " Invertible setting variants
    1              0.000016 syn keyword vimOnlyOption contained	invbiosk invbioskey invconsk invconskey invcp invcompatible invguipty invmacatsui invsn invshortname invta invtextauto invtx invtextmode invtf invttyfast invtbi invttybuiltin invwiv invweirdinvert
                            " termcap codes (which can also be set) {{{2
    1              0.000257 syn keyword vimTermOption contained	t_8b t_AB t_al t_bc t_ce t_cl t_Co t_Cs t_CV t_db t_DL t_F1 t_F2 t_F3 t_F4 t_F5 t_F6 t_F7 t_F8 t_F9 t_fs t_IE t_IS t_k1 t_K1 t_k2 t_k3 t_K3 t_k4 t_K4 t_k5 t_K5 t_k6 t_K6 t_k7 t_K7 t_k8 t_K8 t_k9 t_K9 t_KA t_kb t_kB t_KB t_KC t_kd t_kD t_KD t_ke t_KE t_KF t_KG t_kh t_KH t_kI t_KI t_KJ t_KK t_kl t_KL t_kN t_kP t_kr t_ks t_ku t_le t_mb t_md t_me t_mr t_ms t_nd t_op t_RB t_RI t_RV t_Sb t_se t_Sf t_SI t_so t_sr t_SR t_te t_ti t_ts t_u7 t_ue t_us t_ut t_vb t_ve t_vi t_vs t_WP t_WS t_xn t_xs t_ZH t_ZR
    1              0.000010 syn keyword vimTermOption contained	t_8f t_AF t_AL t_cd t_Ce t_cm t_cs t_CS t_da t_dl t_EI
    1              0.000010 syn match   vimTermOption contained	"t_%1"
    1              0.000013 syn match   vimTermOption contained	"t_#2"
    1              0.000005 syn match   vimTermOption contained	"t_#4"
    1              0.000005 syn match   vimTermOption contained	"t_@7"
    1              0.000005 syn match   vimTermOption contained	"t_*7"
    1              0.000005 syn match   vimTermOption contained	"t_&8"
    1              0.000004 syn match   vimTermOption contained	"t_%i"
    1              0.000004 syn match   vimTermOption contained	"t_k;"
                            
                            " unsupported settings: these are supported by vi but don't do anything in vim {{{2
    1              0.000006 syn keyword vimErrSetting contained	hardtabs ht w1200 w300 w9600 
                            "}}}2
    1              0.000005 syn case ignore
                            " Highlight commonly used Groupnames {{{2
    1              0.000040 syn keyword vimGroup contained	Comment Constant String Character Number Boolean Float Identifier Function Statement Conditional Repeat Label Operator Keyword Exception PreProc Include Define Macro PreCondit Type StorageClass Structure Typedef Special SpecialChar Tag Delimiter SpecialComment Debug Underlined Ignore Error Todo 
                            
                            " Default highlighting groups {{{2
    1              0.000097 syn keyword vimHLGroup contained	ColorColumn Cursor CursorColumn CursorIM CursorLine CursorLineNr DiffAdd DiffChange DiffDelete DiffText Directory EndOfBuffer ErrorMsg FoldColumn Folded IncSearch LineNr MatchParen Menu ModeMsg MoreMsg NonText Normal Pmenu PmenuSbar PmenuSel PmenuThumb Question QuickFixLine Scrollbar Search SignColumn SpecialKey SpellBad SpellCap SpellLocal SpellRare StatusLine StatusLineNC TabLine TabLineFill TabLineSel Title Tooltip VertSplit Visual WarningMsg WildMenu 
    1              0.000017 syn match vimHLGroup contained	"Conceal"
    1              0.000009 syn keyword vimOnlyHLGroup contained	LineNrAbove LineNrBelow StatusLineTerm Terminal VisualNOS
    1              0.000006 syn keyword nvimHLGroup contained	Substitute TermCursor TermCursorNC
                            "}}}2
    1              0.000004 syn case match
                            " Special Vim Highlighting (not automatic) {{{1
                            
                            " Set up folding commands {{{2
    1              0.000013 if exists("g:vimsyn_folding") && g:vimsyn_folding =~# '[afhlmpPrt]'
                             if g:vimsyn_folding =~# 'a'
                              com! -nargs=* VimFolda <args> fold
                             else
                              com! -nargs=* VimFolda <args>
                             endif
                             if g:vimsyn_folding =~# 'f'
                              com! -nargs=* VimFoldf <args> fold
                             else
                              com! -nargs=* VimFoldf <args>
                             endif
                             if g:vimsyn_folding =~# 'h'
                              com! -nargs=* VimFoldh <args> fold
                             else
                              com! -nargs=* VimFoldh <args>
                             endif
                             if g:vimsyn_folding =~# 'l'
                              com! -nargs=* VimFoldl <args> fold
                             else
                              com! -nargs=* VimFoldl <args>
                             endif
                             if g:vimsyn_folding =~# 'm'
                              com! -nargs=* VimFoldm <args> fold
                             else
                              com! -nargs=* VimFoldm <args>
                             endif
                             if g:vimsyn_folding =~# 'p' 
                              com! -nargs=* VimFoldp <args> fold 
                             else 
                              com! -nargs=* VimFoldp <args> 
                             endif
                             if g:vimsyn_folding =~# 'P'
                              com! -nargs=* VimFoldP <args> fold
                             else
                              com! -nargs=* VimFoldP <args>
                             endif
                             if g:vimsyn_folding =~# 'r'
                              com! -nargs=* VimFoldr <args> fold
                             else
                              com! -nargs=* VimFoldr <args>
                             endif
                             if g:vimsyn_folding =~# 't'
                              com! -nargs=* VimFoldt <args> fold
                             else
                              com! -nargs=* VimFoldt <args>
                             endif
    1              0.000002 else
    1              0.000036  com! -nargs=*	VimFolda	<args>
    1              0.000020  com! -nargs=*	VimFoldf	<args>
    1              0.000019  com! -nargs=*	VimFoldh	<args>
    1              0.000017  com! -nargs=*	VimFoldl	<args>
    1              0.000016  com! -nargs=*	VimFoldm	<args>
    1              0.000015  com! -nargs=*	VimFoldp	<args>
    1              0.000013  com! -nargs=*	VimFoldP	<args>
    1              0.000015  com! -nargs=*	VimFoldr	<args>
    1              0.000014  com! -nargs=*	VimFoldt	<args>
    1              0.000002 endif
                            
                            " commands not picked up by the generator (due to non-standard format) {{{2
    1              0.000008 syn keyword vimCommand contained	py3
                            
                            " Deprecated variable options {{{2
    1              0.000012 if exists("g:vim_minlines")
                             let g:vimsyn_minlines= g:vim_minlines
    1              0.000002 endif
    1              0.000006 if exists("g:vim_maxlines")
                             let g:vimsyn_maxlines= g:vim_maxlines
    1              0.000002 endif
    1              0.000006 if exists("g:vimsyntax_noerror")
                             let g:vimsyn_noerror= g:vimsyntax_noerror
    1              0.000002 endif
                            
                            " Variable options {{{2
    1              0.000005 if exists("g:vim_maxlines")
                             let s:vimsyn_maxlines= g:vim_maxlines
    1              0.000002 else
    1              0.000008  let s:vimsyn_maxlines= 60
    1              0.000002 endif
                            
                            " Numbers {{{2
                            " =======
    1              0.000049 syn match vimNumber	'\<\d\+\%(\.\d\+\%([eE][+-]\=\d\+\)\=\)\=' skipwhite nextgroup=vimGlobal,vimSubst,vimCommand,vimComment,vim9Comment
    1              0.000023 syn match vimNumber	'-\d\+\%(\.\d\+\%([eE][+-]\=\d\+\)\=\)\='  skipwhite nextgroup=vimGlobal,vimSubst,vimCommand,vimComment,vim9Comment
    1              0.000019 syn match vimNumber	'\<0[xX]\x\+'		       skipwhite nextgroup=vimGlobal,vimSubst,vimCommand,vimComment,vim9Comment
    1              0.000026 syn match vimNumber	'\%(^\|\A\)\zs#\x\{6}'             	       skipwhite nextgroup=vimGlobal,vimSubst,vimCommand,vimComment,vim9Comment
    1              0.000035 syn match vimNumber	'\<0[zZ][a-zA-Z0-9.]\+'                    skipwhite nextgroup=vimGlobal,vimSubst,vimCommand,vimComment,vim9Comment
    1              0.000030 syn match vimNumber	'0[0-7]\+'		       skipwhite nextgroup=vimGlobal,vimSubst,vimCommand,vimComment,vim9Comment           
    1              0.000027 syn match vimNumber	'0[bB][01]\+'		       skipwhite nextgroup=vimGlobal,vimSubst,vimCommand,vimComment,vim9Comment           
                            
                            " All vimCommands are contained by vimIsCommand. {{{2
    1              0.000029 syn match vimCmdSep	"[:|]\+"	skipwhite nextgroup=vimAddress,vimAutoCmd,vimEcho,vimIsCommand,vimExtCmd,vimFilter,vimLet,vimMap,vimMark,vimSet,vimSyntax,vimUserCmd
    1              0.000015 syn match vimIsCommand	"\<\h\w*\>"	contains=vimCommand
    1              0.000015 syn match vimVar	      contained	"\<\h[a-zA-Z0-9#_]*\>"
    1              0.000012 syn match vimVar		"\<[bwglstav]:\h[a-zA-Z0-9#_]*\>"
    1              0.000010 syn match vimVar	      	"\s\zs&\a\+\>"
    1              0.000016 syn match vimFBVar      contained   "\<[bwglstav]:\h[a-zA-Z0-9#_]*\>"
    1              0.000004 syn keyword vimCommand  contained	in
                            
                            " Insertions And Appends: insert append {{{2
                            "   (buftype != nofile test avoids having append, change, insert show up in the command window)
                            " =======================
    1              0.000013 if &buftype != 'nofile'
    1              0.000062  syn region vimInsert	matchgroup=vimCommand start="^[: \t]*\(\d\+\(,\d\+\)\=\)\=a\%[ppend]$"		matchgroup=vimCommand end="^\.$""
    1              0.000018  syn region vimInsert	matchgroup=vimCommand start="^[: \t]*\(\d\+\(,\d\+\)\=\)\=c\%[hange]$"		matchgroup=vimCommand end="^\.$""
    1              0.000015  syn region vimInsert	matchgroup=vimCommand start="^[: \t]*\(\d\+\(,\d\+\)\=\)\=i\%[nsert]$"		matchgroup=vimCommand end="^\.$""
    1              0.000002 endif
                            
                            " Behave! {{{2
                            " =======
    1              0.000012 syn match   vimBehave	"\<be\%[have]\>" skipwhite nextgroup=vimBehaveModel,vimBehaveError
    1              0.000005 syn keyword vimBehaveModel contained	mswin	xterm
    1              0.000014 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_nobehaveerror")
    1              0.000009  syn match   vimBehaveError contained	"[^ ]\+"
    1              0.000002 endif
                            
                            " Filetypes {{{2
                            " =========
    1              0.000019 syn match   vimFiletype	"\<filet\%[ype]\(\s\+\I\i*\)*"	skipwhite contains=vimFTCmd,vimFTOption,vimFTError
    1              0.000010 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_vimFTError")
    1              0.000006  syn match   vimFTError  contained	"\I\i*"
    1              0.000002 endif
    1              0.000005 syn keyword vimFTCmd    contained	filet[ype]
    1              0.000006 syn keyword vimFTOption contained	detect indent off on plugin
                            
                            " Augroup : vimAugroupError removed because long augroups caused sync'ing problems. {{{2
                            " ======= : Trade-off: Increasing synclines with slower editing vs augroup END error checking.
    1              0.000093 syn cluster vimAugroupList	contains=vimAugroup,vimIsCommand,vimUserCmd,vimExecute,vimNotFunc,vimFuncName,vimFunction,vimFunctionError,vimLineComment,vimNotFunc,vimMap,vimSpecFile,vimOper,vimNumber,vimOperParen,vimComment,vim9Comment,vimString,vimSubst,vimMark,vimRegister,vimAddress,vimFilter,vimCmplxRepeat,vimComment,vim9Comment,vimLet,vimSet,vimAutoCmd,vimRegion,vimSynLine,vimNotation,vimCtrlChar,vimFuncVar,vimContinue,vimSetEqual,vimOption
    1              0.000009 if exists("g:vimsyn_folding") && g:vimsyn_folding =~# 'a'
                             syn region  vimAugroup	fold matchgroup=vimAugroupKey start="\<aug\%[roup]\>\ze\s\+\K\k*" end="\<aug\%[roup]\>\ze\s\+[eE][nN][dD]\>"	contains=vimAutoCmd,@vimAugroupList
    1              0.000006 else
    1              0.000028  syn region  vimAugroup	matchgroup=vimAugroupKey start="\<aug\%[roup]\>\ze\s\+\K\k*" end="\<aug\%[roup]\>\ze\s\+[eE][nN][dD]\>"		contains=vimAutoCmd,@vimAugroupList
    1              0.000002 endif
    1              0.000010 syn match   vimAugroup	"aug\%[roup]!"	contains=vimAugroupKey
    1              0.000012 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_noaugrouperror")
    1              0.000011  syn match   vimAugroupError	"\<aug\%[roup]\>\s\+[eE][nN][dD]\>"
    1              0.000002 endif
    1              0.000006 syn keyword vimAugroupKey contained	aug[roup]
                            
                            " Operators: {{{2
                            " =========
    1              0.000023 syn cluster	vimOperGroup	contains=vimEnvvar,vimFunc,vimFuncVar,vimOper,vimOperParen,vimNumber,vimString,vimType,vimRegister,vimContinue,vim9Comment
    1              0.000013 syn match	vimOper	"||\|&&\|[-+.!]"				skipwhite nextgroup=vimString,vimSpecFile
    1              0.000023 syn match	vimOper	"\%#=1\(==\|!=\|>=\|<=\|=\~\|!\~\|>\|<\|=\|!\~#\)[?#]\{0,2}"	skipwhite nextgroup=vimString,vimSpecFile
    1              0.000016 syn match	vimOper	"\(\<is\|\<isnot\)[?#]\{0,2}\>"			skipwhite nextgroup=vimString,vimSpecFile
    1              0.000023 syn region	vimOperParen 	matchgroup=vimParenSep	start="(" end=")" contains=vimoperStar,@vimOperGroup
    1              0.000019 syn region	vimOperParen	matchgroup=vimSep		start="#\={" end="}" contains=@vimOperGroup nextgroup=vimVar,vimFuncVar
    1              0.000011 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_noopererror")
    1              0.000005  syn match	vimOperError	")"
    1              0.000001 endif
                            
                            " Functions : Tag is provided for those who wish to highlight tagged functions {{{2
                            " =========
    1              0.000019 syn cluster	vimFuncList	contains=vimCommand,vimFunctionError,vimFuncKey,Tag,vimFuncSID
    1              0.000136 syn cluster	vimFuncBodyList	contains=vimAbb,vimAddress,vimAugroupKey,vimAutoCmd,vimCmplxRepeat,vimComment,vim9Comment,vimContinue,vimCtrlChar,vimEcho,vimEchoHL,vimEnvvar,vimExecute,vimIsCommand,vimFBVar,vimFunc,vimFunction,vimFuncVar,vimGlobal,vimHighlight,vimIsCommand,vimLet,vimLetHereDoc,vimLineComment,vimMap,vimMark,vimNorm,vimNotation,vimNotFunc,vimNumber,vimOper,vimOperParen,vimRegion,vimRegister,vimSearch,vimSet,vimSpecFile,vimString,vimSubst,vimSynLine,vimUnmap,vimUserCommand
    1              0.000037 syn match	vimFunction	"\<\(fu\%[nction]\)!\=\s\+\%(<[sS][iI][dD]>\|[sSgGbBwWtTlL]:\)\=\%(\i\|[#.]\|{.\{-1,}}\)*\ze\s*("	contains=@vimFuncList nextgroup=vimFuncBody
    1              0.000012  syn match	vimFunction	"\<def!\=\ze\s*(" contains=@vimFuncList nextgroup=vimFuncBody
                            
    1              0.000032 if exists("g:vimsyn_folding") && g:vimsyn_folding =~# 'f'
                             syn region	vimFuncBody  contained	fold start="\ze\s*("	matchgroup=vimCommand end="\<\(endf\>\|endfu\%[nction]\>\|enddef\>\)"		contains=@vimFuncBodyList
    1              0.000003 else
    1              0.000027  syn region	vimFuncBody  contained	start="\ze\s*("		matchgroup=vimCommand end="\<\(endf\>\|endfu\%[nction]\>\|enddef\>\)"		contains=@vimFuncBodyList
    1              0.000002 endif
    1              0.000010 syn match	vimFuncVar   contained	"a:\(\K\k*\|\d\+\)"
    1              0.000008 syn match	vimFuncSID   contained	"\c<sid>\|\<s:"
    1              0.000007 syn keyword	vimFuncKey   contained	fu[nction]
    1              0.000008 syn match	vimFuncBlank contained	"\s\+"
                            
    1              0.000005 syn keyword	vimPattern   contained	start	skip	end
                            
                            " vimTypes : new for vim9
    1              0.000020  syn match	vimType	":\s*\zs\<\(bool\|number\|float\|string\|blob\|list<\|dict<\|job\|channel\|func\)\>"
                            
                            " Special Filenames, Modifiers, Extension Removal: {{{2
                            " ===============================================
    1              0.000012 syn match	vimSpecFile	"<c\(word\|WORD\)>"	nextgroup=vimSpecFileMod,vimSubst
    1              0.000013 syn match	vimSpecFile	"<\([acs]file\|amatch\|abuf\)>"	nextgroup=vimSpecFileMod,vimSubst
    1              0.000010 syn match	vimSpecFile	"\s%[ \t:]"ms=s+1,me=e-1	nextgroup=vimSpecFileMod,vimSubst
    1              0.000008 syn match	vimSpecFile	"\s%$"ms=s+1	nextgroup=vimSpecFileMod,vimSubst
    1              0.000008 syn match	vimSpecFile	"\s%<"ms=s+1,me=e-1	nextgroup=vimSpecFileMod,vimSubst
    1              0.000010 syn match	vimSpecFile	"#\d\+\|[#%]<\>"	nextgroup=vimSpecFileMod,vimSubst
    1              0.000008 syn match	vimSpecFileMod	"\(:[phtre]\)\+"	contained
                            
                            " User-Specified Commands: {{{2
                            " =======================
    1              0.000064 syn cluster	vimUserCmdList	contains=vimAddress,vimSyntax,vimHighlight,vimAutoCmd,vimCmplxRepeat,vimComment,vim9Comment,vimCtrlChar,vimEscapeBrace,vimFunc,vimFuncName,vimFunction,vimFunctionError,vimIsCommand,vimMark,vimNotation,vimNumber,vimOper,vimRegion,vimRegister,vimLet,vimSet,vimSetEqual,vimSetString,vimSpecFile,vimString,vimSubst,vimSubstRep,vimSubstRange,vimSynLine
    1              0.000006 syn keyword	vimUserCommand	contained	com[mand]
    1              0.000018 syn match	vimUserCmd	"\<com\%[mand]!\=\>.*$"	contains=vimUserAttrb,vimUserAttrbError,vimUserCommand,@vimUserCmdList,vimComFilter
    1              0.000008 syn match	vimUserAttrbError	contained	"-\a\+\ze\s"
    1              0.000011 syn match	vimUserAttrb	contained	"-nargs=[01*?+]"	contains=vimUserAttrbKey,vimOper
    1              0.000015 syn match	vimUserAttrb	contained	"-complete="		contains=vimUserAttrbKey,vimOper nextgroup=vimUserAttrbCmplt,vimUserCmdError
    1              0.000013 syn match	vimUserAttrb	contained	"-range\(=%\|=\d\+\)\="	contains=vimNumber,vimOper,vimUserAttrbKey
    1              0.000015 syn match	vimUserAttrb	contained	"-count\(=\d\+\)\="	contains=vimNumber,vimOper,vimUserAttrbKey
    1              0.000015 syn match	vimUserAttrb	contained	"-bang\>"		contains=vimOper,vimUserAttrbKey
    1              0.000018 syn match	vimUserAttrb	contained	"-bar\>"		contains=vimOper,vimUserAttrbKey
    1              0.000010 syn match	vimUserAttrb	contained	"-buffer\>"		contains=vimOper,vimUserAttrbKey
    1              0.000009 syn match	vimUserAttrb	contained	"-register\>"		contains=vimOper,vimUserAttrbKey
    1              0.000012 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_nousercmderror")
    1              0.000012  syn match	vimUserCmdError	contained	"\S\+\>"
    1              0.000002 endif
    1              0.000005 syn case ignore
    1              0.000022 syn keyword	vimUserAttrbKey   contained	bar	ban[g]	cou[nt]	ra[nge] com[plete]	n[args]	re[gister]
    1              0.000032 syn keyword	vimUserAttrbCmplt contained	augroup buffer behave color command compiler cscope dir environment event expression file file_in_path filetype function help highlight history locale mapping menu option packadd shellcmd sign syntax syntime tag tag_listfiles user var
    1              0.000011 syn keyword	vimUserAttrbCmplt contained	custom customlist nextgroup=vimUserAttrbCmpltFunc,vimUserCmdError
    1              0.000020 syn match	vimUserAttrbCmpltFunc contained	",\%([sS]:\|<[sS][iI][dD]>\)\=\%(\h\w*\%(#\h\w*\)\+\|\h\w*\)"hs=s+1 nextgroup=vimUserCmdError
                            
    1              0.000004 syn case match
    1              0.000008 syn match	vimUserAttrbCmplt contained	"custom,\u\w*"
                            
                            " Lower Priority Comments: after some vim commands... {{{2
                            " =======================
    1              0.000014 syn match	vimComment	excludenl +\s"[^\-:.%#=*].*$+lc=1	contains=@vimCommentGroup,vimCommentString
    1              0.000012 syn match	vimComment	+\<endif\s\+".*$+lc=5	contains=@vimCommentGroup,vimCommentString
    1              0.000010 syn match	vimComment	+\<else\s\+".*$+lc=4	contains=@vimCommentGroup,vimCommentString
    1              0.000018 syn region	vimCommentString	contained oneline start='\S\s\+"'ms=e	end='"'
                            " Vim9 comments - TODO: might be highlighted while they don't work
    1              0.000029 syn match	vim9Comment	excludenl +\s#[^{].*$+lc=1	contains=@vimCommentGroup,vimCommentString
    1              0.000015 syn match	vim9Comment	+\<endif\s\+#[^{].*$+lc=5	contains=@vimCommentGroup,vimCommentString
    1              0.000011 syn match	vim9Comment	+\<else\s\+#[^{].*$+lc=4	contains=@vimCommentGroup,vimCommentString
                            " Vim9 comment inside expression
    1              0.000011 syn match	vim9Comment	+\s\zs#[^{].*$+ms=s+1	contains=@vimCommentGroup,vimCommentString
    1              0.000010 syn match	vim9Comment	+^\s*#[^{].*$+	contains=@vimCommentGroup,vimCommentString
    1              0.000015 syn match	vim9Comment	+^\s*#$+	contains=@vimCommentGroup,vimCommentString
                            
                            " Environment Variables: {{{2
                            " =====================
    1              0.000012 syn match	vimEnvvar	"\$\I\i*"
    1              0.000006 syn match	vimEnvvar	"\${\I\i*}"
                            
                            " In-String Specials: {{{2
                            " Try to catch strings, if nothing else matches (therefore it must precede the others!)
                            "  vimEscapeBrace handles ["]  []"] (ie. "s don't terminate string inside [])
    1              0.000022 syn region	vimEscapeBrace	oneline   contained transparent start="[^\\]\(\\\\\)*\[\zs\^\=\]\=" skip="\\\\\|\\\]" end="]"me=e-1
    1              0.000006 syn match	vimPatSepErr	contained	"\\)"
    1              0.000006 syn match	vimPatSep	contained	"\\|"
    1              0.000034 syn region	vimPatSepZone	oneline   contained   matchgroup=vimPatSepZ start="\\%\=\ze(" skip="\\\\" end="\\)\|[^\\]['"]"	contains=@vimStringGroup
    1              0.000018 syn region	vimPatRegion	contained transparent matchgroup=vimPatSepR start="\\[z%]\=(" end="\\)"	contains=@vimSubstList oneline
    1              0.000006 syn match	vimNotPatSep	contained	"\\\\"
    1              0.000017 syn cluster	vimStringGroup	contains=vimEscapeBrace,vimPatSep,vimNotPatSep,vimPatSepErr,vimPatSepZone,@Spell
    1              0.000023 syn region	vimString	oneline keepend	start=+[^a-zA-Z>!\\@]"+lc=1 skip=+\\\\\|\\"+ matchgroup=vimStringEnd end=+"+	contains=@vimStringGroup
    1              0.000013 syn region	vimString	oneline keepend	start=+[^a-zA-Z>!\\@]'+lc=1 end=+'+
    1              0.000025 syn region	vimString	oneline	start=+=!+lc=1	skip=+\\\\\|\\!+ end=+!+	contains=@vimStringGroup
    1              0.000014 syn region	vimString	oneline	start="=+"lc=1	skip="\\\\\|\\+" end="+"	contains=@vimStringGroup
                            "syn region	vimString	oneline	start="\s/\s*\A"lc=1 skip="\\\\\|\\+" end="/"	contains=@vimStringGroup  " see tst45.vim
    1              0.000009 syn match	vimString	contained	+"[^"]*\\$+	skipnl nextgroup=vimStringCont
    1              0.000010 syn match	vimStringCont	contained	+\(\\\\\|.\)\{-}[^\\]"+
                            
                            " Substitutions: {{{2
                            " =============
    1              0.000015 syn cluster	vimSubstList	contains=vimPatSep,vimPatRegion,vimPatSepErr,vimSubstTwoBS,vimSubstRange,vimNotation
    1              0.000011 syn cluster	vimSubstRepList	contains=vimSubstSubstr,vimSubstTwoBS,vimNotation
    1              0.000008 syn cluster	vimSubstList	add=vimCollection
    1              0.000026 syn match	vimSubst	"\(:\+\s*\|^\s*\||\s*\)\<\%(\<s\%[ubstitute]\>\|\<sm\%[agic]\>\|\<sno\%[magic]\>\)[:#[:alpha:]]\@!" nextgroup=vimSubstPat
                            "syn match	vimSubst	"\%(^\|[^\\]\)\<s\%[ubstitute]\>[:#[:alpha:]]\@!"	nextgroup=vimSubstPat contained
    1              0.000018 syn match	vimSubst	"\%(^\|[^\\\"']\)\<s\%[ubstitute]\>[:#[:alpha:]\"']\@!"	nextgroup=vimSubstPat contained
    1              0.000011 syn match	vimSubst	"/\zs\<s\%[ubstitute]\>\ze/"		nextgroup=vimSubstPat
    1              0.000013 syn match	vimSubst	"\(:\+\s*\|^\s*\)s\ze#.\{-}#.\{-}#"		nextgroup=vimSubstPat
    1              0.000010 syn match	vimSubst1       contained	"\<s\%[ubstitute]\>"	nextgroup=vimSubstPat
    1              0.000011 syn match	vimSubst2       contained	"s\%[ubstitute]\>"	nextgroup=vimSubstPat
    1              0.000029 syn region	vimSubstPat     contained	matchgroup=vimSubstDelim start="\z([^a-zA-Z( \t[\]&]\)"rs=s+1 skip="\\\\\|\\\z1" end="\z1"re=e-1,me=e-1	 contains=@vimSubstList	nextgroup=vimSubstRep4	oneline
    1              0.000037 syn region	vimSubstRep4    contained	matchgroup=vimSubstDelim start="\z(.\)" skip="\\\\\|\\\z1" end="\z1" matchgroup=vimNotation end="<[cC][rR]>" contains=@vimSubstRepList	nextgroup=vimSubstFlagErr	oneline
    1              0.000016 syn region	vimCollection   contained transparent	start="\\\@<!\[" skip="\\\[" end="\]"	contains=vimCollClass
    1              0.000009 syn match	vimCollClassErr contained	"\[:.\{-\}:\]"
    1              0.000030 syn match	vimCollClass    contained transparent	"\%#=1\[:\(alnum\|alpha\|blank\|cntrl\|digit\|graph\|lower\|print\|punct\|space\|upper\|xdigit\|return\|tab\|escape\|backspace\):\]"
    1              0.000037 syn match	vimSubstSubstr  contained	"\\z\=\d"
    1              0.000006 syn match	vimSubstTwoBS   contained	"\\\\"
    1              0.000011 syn match	vimSubstFlagErr contained	"[^< \t\r|]\+" contains=vimSubstFlags
    1              0.000015 syn match	vimSubstFlags   contained	"[&cegiIlnpr#]\+"
                            
                            " 'String': {{{2
    1              0.000008 syn match	vimString	"[^(,]'[^']\{-}\zs'"
                            
                            " Marks, Registers, Addresses, Filters: {{{2
    1              0.000032 syn match	vimMark	"'[a-zA-Z0-9]\ze[-+,!]"	nextgroup=vimFilter,vimMarkNumber,vimSubst
    1              0.000011 syn match	vimMark	"'[<>]\ze[-+,!]"		nextgroup=vimFilter,vimMarkNumber,vimSubst
    1              0.000010 syn match	vimMark	",\zs'[<>]\ze"		nextgroup=vimFilter,vimMarkNumber,vimSubst
    1              0.000011 syn match	vimMark	"[!,:]\zs'[a-zA-Z0-9]"	nextgroup=vimFilter,vimMarkNumber,vimSubst
    1              0.000013 syn match	vimMark	"\<norm\%[al]\s\zs'[a-zA-Z0-9]"	nextgroup=vimFilter,vimMarkNumber,vimSubst
    1              0.000010 syn match	vimMarkNumber	"[-+]\d\+"		contained contains=vimOper nextgroup=vimSubst2
    1              0.000008 syn match	vimPlainMark contained	"'[a-zA-Z0-9]"
    1              0.000012 syn match	vimRange	"[`'][a-zA-Z0-9],[`'][a-zA-Z0-9]"	contains=vimMark	skipwhite nextgroup=vimFilter
                            
    1              0.000013 syn match	vimRegister	'[^,;[{: \t]\zs"[a-zA-Z0-9.%#:_\-/]\ze[^a-zA-Z_":0-9]'
    1              0.000010 syn match	vimRegister	'\<norm\s\+\zs"[a-zA-Z0-9]'
    1              0.000009 syn match	vimRegister	'\<normal\s\+\zs"[a-zA-Z0-9]'
    1              0.000005 syn match	vimRegister	'@"'
    1              0.000012 syn match	vimPlainRegister contained	'"[a-zA-Z0-9\-:.%#*+=]'
                            
    1              0.000008 syn match	vimAddress	",\zs[.$]"	skipwhite nextgroup=vimSubst1
    1              0.000014 syn match	vimAddress	"%\ze\a"	skipwhite nextgroup=vimString,vimSubst1
                            
    1              0.000013 syn match	vimFilter 		"^!!\=[^"]\{-}\(|\|\ze\"\|$\)"	contains=vimOper,vimSpecFile
    1              0.000011 syn match	vimFilter    contained	"!!\=[^"]\{-}\(|\|\ze\"\|$\)"	contains=vimOper,vimSpecFile
    1              0.000017 syn match	vimComFilter contained	"|!!\=[^"]\{-}\(|\|\ze\"\|$\)"      contains=vimOper,vimSpecFile
                            
                            " Complex Repeats: (:h complex-repeat) {{{2
    1              0.000011 syn match	vimCmplxRepeat	'[^a-zA-Z_/\\()]q[0-9a-zA-Z"]\>'lc=1
    1              0.000011 syn match	vimCmplxRepeat	'@[0-9a-z".=@:]\ze\($\|[^a-zA-Z]\>\)'
                            
                            " Set command and associated set-options (vimOptions) with comment {{{2
    1              0.000049 syn region	vimSet		matchgroup=vimCommand start="\<\%(setl\%[ocal]\|setg\%[lobal]\|se\%[t]\)\>" skip="\%(\\\\\)*\\.\n\@!" end="$" end="|" matchgroup=vimNotation end="<[cC][rR]>" keepend contains=vimSetEqual,vimOption,vimErrSetting,vimComment,vim9Comment,vimSetString,vimSetMod
    1              0.000033  syn region	vimSetEqual	contained	start="[=:]\|[-+^]=" skip="\\\\\|\\\s" end="[| \t]"me=e-1 end="$"	contains=vimCtrlChar,vimSetSep,vimNotation,vimEnvvar
    1              0.000015 syn region	vimSetString	contained	start=+="+hs=s+1	skip=+\\\\\|\\"+  end=+"+		contains=vimCtrlChar
    1              0.000006 syn match	vimSetSep	contained	"[,:]"
    1              0.000008 syn match	vimSetMod	contained	"&vim\=\|[!&?<]\|all&"
                            
                            " Let: {{{2
                            " ===
    1              0.000012 syn keyword	vimLet	let	unl[et]	skipwhite nextgroup=vimVar,vimFuncVar,vimLetHereDoc
    1              0.000039 VimFoldh syn region vimLetHereDoc	matchgroup=vimLetHereDocStart start='=<<\s\+\%(trim\>\)\=\s*\z(\L\S*\)'	matchgroup=vimLetHereDocStop end='^\s*\z1\s*$'
                            
                            " Abbreviations: {{{2
                            " =============
    1              0.000025 syn keyword vimAbb	ab[breviate] ca[bbrev] inorea[bbrev] cnorea[bbrev] norea[bbrev] ia[bbrev] skipwhite nextgroup=vimMapMod,vimMapLhs
                            
                            " Autocmd: {{{2
                            " =======
    1              0.000016 syn match	vimAutoEventList	contained	"\(!\s\+\)\=\(\a\+,\)*\a\+"	contains=vimAutoEvent,nvimAutoEvent nextgroup=vimAutoCmdSpace
    1              0.000008 syn match	vimAutoCmdSpace	contained	"\s\+"	nextgroup=vimAutoCmdSfxList
    1              0.000008 syn match	vimAutoCmdSfxList	contained	"\S*"	skipwhite nextgroup=vimAutoCmdMod
    1              0.000013 syn keyword	vimAutoCmd	au[tocmd] do[autocmd] doautoa[ll]	skipwhite nextgroup=vimAutoEventList
    1              0.000021 syn match	vimAutoCmdMod	"\(++\)\=\(once\|nested\)"
                            
                            " Echo and Execute: -- prefer strings! {{{2
                            " ================
    1              0.000027 syn region	vimEcho	oneline excludenl matchgroup=vimCommand start="\<ec\%[ho]\>" skip="\(\\\\\)*\\|" end="$\||" contains=vimFunc,vimFuncVar,vimString,vimVar
    1              0.000031 syn region	vimExecute	oneline excludenl matchgroup=vimCommand start="\<exe\%[cute]\>" skip="\(\\\\\)*\\|" end="$\||\|<[cC][rR]>" contains=vimFuncVar,vimIsCommand,vimOper,vimNotation,vimOperParen,vimString,vimVar
    1              0.000016 syn match	vimEchoHL	"echohl\="	skipwhite nextgroup=vimGroup,vimHLGroup,vimEchoHLNone,vimOnlyHLGroup,nvimHLGroup
    1              0.000004 syn case ignore
    1              0.000004 syn keyword	vimEchoHLNone	none
    1              0.000003 syn case match
                            
                            " Maps: {{{2
                            " ====
    1              0.000013 syn match	vimMap		"\<map\>!\=\ze\s*[^(]" skipwhite nextgroup=vimMapMod,vimMapLhs
    1              0.000049 syn keyword	vimMap		cm[ap] cno[remap] im[ap] ino[remap] lm[ap] ln[oremap] nm[ap] nn[oremap] no[remap] om[ap] ono[remap] smap snor[emap] tno[remap] tm[ap] vm[ap] vmapc[lear] vn[oremap] xm[ap] xn[oremap] skipwhite nextgroup=vimMapBang,vimMapMod,vimMapLhs
    1              0.000030 syn keyword	nvimMap		tn[oremap] tm[ap] skipwhite nextgroup=vimMapBang,vimMapMod,vimMapLhs
    1              0.000008 syn keyword	vimMap		mapc[lear] smapc[lear]
    1              0.000024 syn keyword	vimUnmap		cu[nmap] iu[nmap] lu[nmap] nun[map] ou[nmap] sunm[ap] unm[ap] unm[ap] vu[nmap] xu[nmap] skipwhite nextgroup=vimMapBang,vimMapMod,vimMapLhs
    1              0.000009 syn keyword	nvimUnmap 		tunm[ap] skipwhite nextgroup=vimMapBang,vimMapMod,vimMapLhs
    1              0.000012 syn match	vimMapLhs	contained	"\S\+"			contains=vimNotation,vimCtrlChar skipwhite nextgroup=vimMapRhs
    1              0.000009 syn match	vimMapBang	contained	"!"			skipwhite nextgroup=vimMapMod,vimMapLhs
    1              0.000030 syn match	vimMapMod	contained	"\%#=1\c<\(buffer\|expr\|\(local\)\=leader\|nowait\|plug\|script\|sid\|unique\|silent\)\+>" contains=vimMapModKey,vimMapModErr skipwhite nextgroup=vimMapMod,vimMapLhs
    1              0.000011 syn match	vimMapRhs	contained	".*" contains=vimNotation,vimCtrlChar	skipnl nextgroup=vimMapRhsExtend
    1              0.000009 syn match	vimMapRhsExtend	contained	"^\s*\\.*$"			contains=vimContinue
    1              0.000005 syn case ignore
    1              0.000012 syn keyword	vimMapModKey	contained	buffer	expr	leader	localleader	nowait	plug	script	sid	silent	unique
    1              0.000003 syn case match
                            
                            " Menus: {{{2
                            " =====
    1              0.000016 syn cluster	vimMenuList contains=vimMenuBang,vimMenuPriority,vimMenuName,vimMenuMod
    1              0.000042 syn keyword	vimCommand	am[enu] an[oremenu] aun[menu] cme[nu] cnoreme[nu] cunme[nu] ime[nu] inoreme[nu] iunme[nu] me[nu] nme[nu] nnoreme[nu] noreme[nu] nunme[nu] ome[nu] onoreme[nu] ounme[nu] unme[nu] vme[nu] vnoreme[nu] vunme[nu] skipwhite nextgroup=@vimMenuList
    1              0.000012 syn match	vimMenuName	"[^ \t\\<]\+"	contained nextgroup=vimMenuNameMore,vimMenuMap
    1              0.000010 syn match	vimMenuPriority	"\d\+\(\.\d\+\)*"	contained skipwhite nextgroup=vimMenuName
    1              0.000013 syn match	vimMenuNameMore	"\c\\\s\|<tab>\|\\\."	contained nextgroup=vimMenuName,vimMenuNameMore contains=vimNotation
    1              0.000029 syn match	vimMenuMod    contained	"\c<\(script\|silent\)\+>"  skipwhite contains=vimMapModKey,vimMapModErr nextgroup=@vimMenuList
    1              0.000007 syn match	vimMenuMap	"\s"	contained skipwhite nextgroup=vimMenuRhs
    1              0.000011 syn match	vimMenuRhs	".*$"	contained contains=vimString,vimComment,vim9Comment,vimIsCommand
    1              0.000007 syn match	vimMenuBang	"!"	contained skipwhite nextgroup=@vimMenuList
                            
                            " Angle-Bracket Notation: (tnx to Michael Geddes) {{{2
                            " ======================
    1              0.000007 syn case ignore
    1              0.000071 syn match	vimNotation	"\%#=1\(\\\|<lt>\)\=<\([scamd]-\)\{0,4}x\=\(f\d\{1,2}\|[^ \t:]\|cmd\|cr\|lf\|linefeed\|return\|enter\|k\=del\%[ete]\|bs\|backspace\|tab\|esc\|right\|left\|help\|undo\|insert\|ins\|mouse\|k\=home\|k\=end\|kplus\|kminus\|kdivide\|kmultiply\|kenter\|kpoint\|space\|k\=\(page\)\=\(\|down\|up\|k\d\>\)\)>" contains=vimBracket
    1              0.000024 syn match	vimNotation	"\%#=1\(\\\|<lt>\)\=<\([scam2-4]-\)\{0,4}\(right\|left\|middle\)\(mouse\)\=\(drag\|release\)\=>"	contains=vimBracket
    1              0.000021 syn match	vimNotation	"\%#=1\(\\\|<lt>\)\=<\(bslash\|plug\|sid\|space\|bar\|nop\|nul\|lt\)>"			contains=vimBracket
    1              0.000015 syn match	vimNotation	'\(\\\|<lt>\)\=<C-R>[0-9a-z"%#:.\-=]'he=e-1				contains=vimBracket
    1              0.000023 syn match	vimNotation	'\%#=1\(\\\|<lt>\)\=<\%(q-\)\=\(line[12]\|count\|bang\|reg\|args\|mods\|f-args\|f-mods\|lt\)>'	contains=vimBracket
    1              0.000017 syn match	vimNotation	"\%#=1\(\\\|<lt>\)\=<\([cas]file\|abuf\|amatch\|cword\|cWORD\|client\)>"		contains=vimBracket
    1              0.000013 syn match	vimBracket contained	"[\\<>]"
    1              0.000003 syn case match
                            
                            " User Function Highlighting: {{{2
                            " (following Gautam Iyer's suggestion)
                            " ==========================
    1              0.000024 syn match vimFunc		"\%(\%([sSgGbBwWtTlL]:\|<[sS][iI][dD]>\)\=\%(\w\+\.\)*\I[a-zA-Z0-9_.]*\)\ze\s*("		contains=vimFuncName,vimUserFunc,vimExecute
    1              0.000021 syn match vimUserFunc contained	"\%(\%([sSgGbBwWtTlL]:\|<[sS][iI][dD]>\)\=\%(\w\+\.\)*\I[a-zA-Z0-9_.]*\)\|\<\u[a-zA-Z0-9.]*\>\|\<if\>"	contains=vimNotation
                            
                            " User Command Highlighting: {{{2
                            "syn match vimUsrCmd	'^\s*\zs\u\w*.*$'
    1              0.000015 syn match vimUsrCmd	'^\s*\zs\u\%(\w*\)\@>\%([(#[]\|\s\+\%([-+*/%]\=\|\.\.\)=\)\@!'
                            
                            " Errors And Warnings: {{{2
                            " ====================
    1              0.000016 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_novimfunctionerror")
    1              0.000015  syn match	vimFunctionError	"\s\zs[a-z0-9]\i\{-}\ze\s*("			contained contains=vimFuncKey,vimFuncBlank
    1              0.000018  syn match	vimFunctionError	"\s\zs\%(<[sS][iI][dD]>\|[sSgGbBwWtTlL]:\)\d\i\{-}\ze\s*("	contained contains=vimFuncKey,vimFuncBlank
    1              0.000023  syn match	vimElseIfErr	"\<else\s\+if\>"
    1              0.000011  syn match	vimBufnrWarn	/\<bufnr\s*(\s*["']\.['"]\s*)/
    1              0.000002 endif
                            
    1              0.000019 syn match vimNotFunc	"\<if\>\|\<el\%[seif]\>\|\<return\>\|\<while\>"	skipwhite nextgroup=vimOper,vimOperParen,vimVar,vimFunc,vimNotation
                            
                            " Norm: {{{2
                            " ====
    1              0.000009 syn match	vimNorm		"\<norm\%[al]!\=" skipwhite nextgroup=vimNormCmds
    1              0.000006 syn match	vimNormCmds contained	".*$"
                            
                            " Syntax: {{{2
                            "=======
    1              0.000012 syn match	vimGroupList	contained	"@\=[^ \t,]*"	contains=vimGroupSpecial,vimPatSep
    1              0.000019 syn match	vimGroupList	contained	"@\=[^ \t,]*,"	nextgroup=vimGroupList contains=vimGroupSpecial,vimPatSep
    1              0.000007 syn keyword	vimGroupSpecial	contained	ALL	ALLBUT	CONTAINED	TOP
    1              0.000012 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_novimsynerror")
    1              0.000006  syn match	vimSynError	contained	"\i\+"
    1              0.000007  syn match	vimSynError	contained	"\i\+="	nextgroup=vimGroupList
    1              0.000002 endif
    1              0.000011 syn match	vimSynContains	contained	"\<contain\(s\|edin\)="	nextgroup=vimGroupList
    1              0.000009 syn match	vimSynKeyContainedin	contained	"\<containedin="	nextgroup=vimGroupList
    1              0.000008 syn match	vimSynNextgroup	contained	"nextgroup="	nextgroup=vimGroupList
                            
    1              0.000027 syn match	vimSyntax	"\<sy\%[ntax]\>"	contains=vimCommand skipwhite nextgroup=vimSynType,vimComment,vim9Comment
    1              0.000015 syn match	vimAuSyntax	contained	"\s+sy\%[ntax]"	contains=vimCommand skipwhite nextgroup=vimSynType,vimComment,vim9Comment
    1              0.000016 syn cluster vimFuncBodyList add=vimSyntax
                            
                            " Syntax: case {{{2
    1              0.000008 syn keyword	vimSynType	contained	case	skipwhite nextgroup=vimSynCase,vimSynCaseError
    1              0.000012 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_novimsyncaseerror")
    1              0.000006  syn match	vimSynCaseError	contained	"\i\+"
    1              0.000002 endif
    1              0.000004 syn keyword	vimSynCase	contained	ignore	match
                            
                            " Syntax: clear {{{2
    1              0.000005 syn keyword	vimSynType	contained	clear	skipwhite nextgroup=vimGroupList
                            
                            " Syntax: cluster {{{2
    1              0.000007 syn keyword	vimSynType	contained	cluster	skipwhite nextgroup=vimClusterName
    1              0.000025 syn region	vimClusterName	contained	matchgroup=vimGroupName start="\h\w*" skip="\\\\\|\\|" matchgroup=vimSep end="$\||" contains=vimGroupAdd,vimGroupRem,vimSynContains,vimSynError
    1              0.000007 syn match	vimGroupAdd	contained	"add="	nextgroup=vimGroupList
    1              0.000014 syn match	vimGroupRem	contained	"remove="	nextgroup=vimGroupList
    1              0.000013 syn cluster vimFuncBodyList add=vimSynType,vimGroupAdd,vimGroupRem
                            
                            " Syntax: iskeyword {{{2
    1              0.000006 syn keyword	vimSynType	contained	iskeyword	skipwhite nextgroup=vimIskList
    1              0.000015 syn match	vimIskList	contained	'\S\+'	contains=vimIskSep
    1              0.000006 syn match	vimIskSep	contained	','
                            
                            " Syntax: include {{{2
    1              0.000005 syn keyword	vimSynType	contained	include	skipwhite nextgroup=vimGroupList
    1              0.000009 syn cluster vimFuncBodyList add=vimSynType
                            
                            " Syntax: keyword {{{2
    1              0.000012 syn cluster	vimSynKeyGroup	contains=vimSynNextgroup,vimSynKeyOpt,vimSynKeyContainedin
    1              0.000007 syn keyword	vimSynType	contained	keyword	skipwhite nextgroup=vimSynKeyRegion
    1              0.000023 syn region	vimSynKeyRegion	contained oneline keepend	matchgroup=vimGroupName start="\h\w*" skip="\\\\\|\\|" matchgroup=vimSep end="|\|$" contains=@vimSynKeyGroup
    1              0.000018 syn match	vimSynKeyOpt	contained	"\%#=1\<\(conceal\|contained\|transparent\|skipempty\|skipwhite\|skipnl\)\>"
    1              0.000008 syn cluster vimFuncBodyList add=vimSynType
                            
                            " Syntax: match {{{2
    1              0.000019 syn cluster	vimSynMtchGroup	contains=vimMtchComment,vimSynContains,vimSynError,vimSynMtchOpt,vimSynNextgroup,vimSynRegPat,vimNotation,vim9Comment
    1              0.000007 syn keyword	vimSynType	contained	match	skipwhite nextgroup=vimSynMatchRegion
    1              0.000016 syn region	vimSynMatchRegion	contained keepend	matchgroup=vimGroupName start="\h\w*" matchgroup=vimSep end="|\|$" contains=@vimSynMtchGroup
    1              0.000023 syn match	vimSynMtchOpt	contained	"\%#=1\<\(conceal\|transparent\|contained\|excludenl\|keepend\|skipempty\|skipwhite\|display\|extend\|skipnl\|fold\)\>"
    1              0.000013 if has("conceal")
    1              0.000008  syn match	vimSynMtchOpt	contained	"\<cchar="	nextgroup=vimSynMtchCchar
    1              0.000005  syn match	vimSynMtchCchar	contained	"\S"
    1              0.000002 endif
    1              0.000009 syn cluster vimFuncBodyList add=vimSynMtchGroup
                            
                            " Syntax: off and on {{{2
    1              0.000006 syn keyword	vimSynType	contained	enable	list	manual	off	on	reset
                            
                            " Syntax: region {{{2
    1              0.000059 syn cluster	vimSynRegPatGroup	contains=vimPatSep,vimNotPatSep,vimSynPatRange,vimSynNotPatRange,vimSubstSubstr,vimPatRegion,vimPatSepErr,vimNotation
    1              0.000015 syn cluster	vimSynRegGroup	contains=vimSynContains,vimSynNextgroup,vimSynRegOpt,vimSynReg,vimSynMtchGrp
    1              0.000007 syn keyword	vimSynType	contained	region	skipwhite nextgroup=vimSynRegion
    1              0.000020 syn region	vimSynRegion	contained keepend	matchgroup=vimGroupName start="\h\w*" skip="\\\\\|\\|" end="|\|$" contains=@vimSynRegGroup
    1              0.000028 syn match	vimSynRegOpt	contained	"\%#=1\<\(conceal\(ends\)\=\|transparent\|contained\|excludenl\|skipempty\|skipwhite\|display\|keepend\|oneline\|extend\|skipnl\|fold\)\>"
    1              0.000013 syn match	vimSynReg	contained	"\(start\|skip\|end\)="he=e-1	nextgroup=vimSynRegPat
    1              0.000014 syn match	vimSynMtchGrp	contained	"matchgroup="	nextgroup=vimGroup,vimHLGroup,vimOnlyHLGroup,nvimHLGroup
    1              0.000030 syn region	vimSynRegPat	contained extend	start="\z([-`~!@#$%^&*_=+;:'",./?]\)"  skip="\\\\\|\\\z1"  end="\z1"  contains=@vimSynRegPatGroup skipwhite nextgroup=vimSynPatMod,vimSynReg
    1              0.000016 syn match	vimSynPatMod	contained	"\%#=1\(hs\|ms\|me\|hs\|he\|rs\|re\)=[se]\([-+]\d\+\)\="
    1              0.000015 syn match	vimSynPatMod	contained	"\%#=1\(hs\|ms\|me\|hs\|he\|rs\|re\)=[se]\([-+]\d\+\)\=," nextgroup=vimSynPatMod
    1              0.000014 syn match	vimSynPatMod	contained	"lc=\d\+"
    1              0.000008 syn match	vimSynPatMod	contained	"lc=\d\+," nextgroup=vimSynPatMod
    1              0.000013 syn region	vimSynPatRange	contained	start="\["	skip="\\\\\|\\]"   end="]"
    1              0.000006 syn match	vimSynNotPatRange	contained	"\\\\\|\\\["
    1              0.000007 syn match	vimMtchComment	contained	'"[^"]\+$'
    1              0.000009 syn cluster vimFuncBodyList add=vimSynType
                            
                            " Syntax: sync {{{2
                            " ============
    1              0.000016 syn keyword vimSynType	contained	sync	skipwhite	nextgroup=vimSyncC,vimSyncLines,vimSyncMatch,vimSyncError,vimSyncLinebreak,vimSyncLinecont,vimSyncRegion
    1              0.000013 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_novimsyncerror")
    1              0.000006  syn match	vimSyncError	contained	"\i\+"
    1              0.000002 endif
    1              0.000006 syn keyword	vimSyncC	contained	ccomment	clear	fromstart
    1              0.000007 syn keyword	vimSyncMatch	contained	match	skipwhite	nextgroup=vimSyncGroupName
    1              0.000006 syn keyword	vimSyncRegion	contained	region	skipwhite	nextgroup=vimSynReg
    1              0.000009 syn match	vimSyncLinebreak	contained	"\<linebreaks="	skipwhite	nextgroup=vimNumber
    1              0.000006 syn keyword	vimSyncLinecont	contained	linecont	skipwhite	nextgroup=vimSynRegPat
    1              0.000010 syn match	vimSyncLines	contained	"\(min\|max\)\=lines="	nextgroup=vimNumber
    1              0.000008 syn match	vimSyncGroupName	contained	"\h\w*"	skipwhite	nextgroup=vimSyncKey
    1              0.000011 syn match	vimSyncKey	contained	"\<groupthere\|grouphere\>"	skipwhite nextgroup=vimSyncGroup
    1              0.000008 syn match	vimSyncGroup	contained	"\h\w*"	skipwhite	nextgroup=vimSynRegPat,vimSyncNone
    1              0.000003 syn keyword	vimSyncNone	contained	NONE
                            
                            " Additional IsCommand: here by reasons of precedence {{{2
                            " ====================
    1              0.000010 syn match	vimIsCommand	"<Bar>\s*\a\+"	transparent contains=vimCommand,vimNotation
                            
                            " Highlighting: {{{2
                            " ============
    1              0.000014 syn cluster	vimHighlightCluster		contains=vimHiLink,vimHiClear,vimHiKeyList,vimComment,vim9Comment
    1              0.000010 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_novimhictermerror")
    1              0.000008  syn match	vimHiCtermError	contained	"\D\i*"
    1              0.000002 endif
    1              0.000013 syn match	vimHighlight	"\<hi\%[ghlight]\>"	skipwhite nextgroup=vimHiBang,@vimHighlightCluster
    1              0.000007 syn match	vimHiBang	contained	"!"	skipwhite nextgroup=@vimHighlightCluster
                            
    1              0.000005 syn match	vimHiGroup	contained	"\i\+"
    1              0.000005 syn case ignore
    1              0.000013 syn keyword	vimHiAttrib	contained	none bold inverse italic nocombine reverse standout strikethrough underline undercurl
    1              0.000021 syn keyword	vimFgBgAttrib	contained	none bg background fg foreground
    1              0.000004 syn case match
    1              0.000007 syn match	vimHiAttribList	contained	"\i\+"	contains=vimHiAttrib
    1              0.000009 syn match	vimHiAttribList	contained	"\i\+,"he=e-1	contains=vimHiAttrib nextgroup=vimHiAttribList
    1              0.000007 syn case ignore
    1              0.000247 syn keyword	vimHiCtermColor	contained	black blue brown cyan darkblue darkcyan darkgray darkgreen darkgrey darkmagenta darkred darkyellow gray green grey grey40 grey50 grey90 lightblue lightcyan lightgray lightgreen lightgrey lightmagenta lightred lightyellow magenta red seagreen white yellow
    1              0.000021 syn match	vimHiCtermColor	contained	"\<color\d\{1,3}\>"
                            
    1              0.000006 syn case match
    1              0.000013 syn match	vimHiFontname	contained	"[a-zA-Z\-*]\+"
    1              0.000010 syn match	vimHiGuiFontname	contained	"'[a-zA-Z\-* ]\+'"
    1              0.000015 syn match	vimHiGuiRgb	contained	"#\x\{6}"
                            
                            " Highlighting: hi group key=arg ... {{{2
    1              0.000030 syn cluster	vimHiCluster contains=vimGroup,vimHiBlend,vimHiGroup,vimHiTerm,vimHiCTerm,vimHiStartStop,vimHiCtermFgBg,vimHiCtermul,vimHiGui,vimHiGuiFont,vimHiGuiFgBg,vimHiKeyError,vimNotation
    1              0.000023 syn region	vimHiKeyList	contained oneline start="\i\+" skip="\\\\\|\\|" end="$\||"	contains=@vimHiCluster
    1              0.000013 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_vimhikeyerror")
    1              0.000006  syn match	vimHiKeyError	contained	"\i\+="he=e-1
    1              0.000002 endif
    1              0.000016 syn match	vimHiTerm	contained	"\cterm="he=e-1		nextgroup=vimHiAttribList
    1              0.000011 syn match	vimHiStartStop	contained	"\c\(start\|stop\)="he=e-1	nextgroup=vimHiTermcap,vimOption
    1              0.000009 syn match	vimHiCTerm	contained	"\ccterm="he=e-1		nextgroup=vimHiAttribList
    1              0.000014 syn match	vimHiCtermFgBg	contained	"\ccterm[fb]g="he=e-1	nextgroup=vimHiNmbr,vimHiCtermColor,vimFgBgAttrib,vimHiCtermError
    1              0.000022 syn match	vimHiCtermul	contained	"\cctermul="he=e-1	nextgroup=vimHiNmbr,vimHiCtermColor,vimFgBgAttrib,vimHiCtermError
    1              0.000014 syn match	vimHiGui	contained	"\cgui="he=e-1		nextgroup=vimHiAttribList
    1              0.000014 syn match	vimHiGuiFont	contained	"\cfont="he=e-1		nextgroup=vimHiFontname
    1              0.000014 syn match	vimHiGuiFgBg	contained	"\cgui\%([fb]g\|sp\)="he=e-1	nextgroup=vimHiGroup,vimHiGuiFontname,vimHiGuiRgb,vimFgBgAttrib
    1              0.000007 syn match	vimHiTermcap	contained	"\S\+"		contains=vimNotation
    1              0.000008 syn match	vimHiBlend	contained	"\cblend="he=e-1		nextgroup=vimHiNmbr
    1              0.000010 syn match	vimHiNmbr	contained	'\d\+'
                            
                            " Highlight: clear {{{2
    1              0.000006 syn keyword	vimHiClear	contained	clear	nextgroup=vimHiGroup
                            
                            " Highlight: link {{{2
                            " see tst24 (hi def vs hi) (Jul 06, 2018)
                            "syn region	vimHiLink	contained oneline matchgroup=vimCommand start="\(\<hi\%[ghlight]\s\+\)\@<=\(\(def\%[ault]\s\+\)\=link\>\|\<def\>\)" end="$"	contains=vimHiGroup,vimGroup,vimHLGroup,vimNotation
    1              0.000030 syn region	vimHiLink	contained oneline matchgroup=vimCommand start="\(\<hi\%[ghlight]\s\+\)\@<=\(\(def\%[ault]\s\+\)\=link\>\|\<def\>\)" end="$"	contains=@vimHiCluster
    1              0.000011 syn cluster vimFuncBodyList add=vimHiLink
                            
                            " Control Characters: {{{2
                            " ==================
    1              0.000006 syn match	vimCtrlChar	"[--]"
                            
                            " Beginners - Patterns that involve ^ {{{2
                            " =========
    1              0.000015 syn match	vimLineComment	+^[ \t:]*".*$+	contains=@vimCommentGroup,vimCommentString,vimCommentTitle
    1              0.000014 syn match	vim9LineComment	+^[ \t:]\+#.*$+	contains=@vimCommentGroup,vimCommentString,vimCommentTitle
    1              0.000023 syn match	vimCommentTitle	'"\s*\%([sS]:\|\h\w*#\)\=\u\w*\(\s\+\u\w*\)*:'hs=s+1	contained contains=vimCommentTitleLeader,vimTodo,@vimCommentGroup
    1              0.000013 syn match	vimContinue	"^\s*\\"
    1              0.000022 syn region	vimString	start="^\s*\\\z(['"]\)" skip='\\\\\|\\\z1' end="\z1" oneline keepend contains=@vimStringGroup,vimContinue
    1              0.000007 syn match	vimCommentTitleLeader	'"\s\+'ms=s+1	contained
                            
                            " Searches And Globals: {{{2
                            " ====================
    1              0.000009 syn match	vimSearch	'^\s*[/?].*'		contains=vimSearchDelim
    1              0.000009 syn match	vimSearchDelim	'^\s*\zs[/?]\|[/?]$'	contained
    1              0.000019 syn region	vimGlobal	matchgroup=Statement start='\<g\%[lobal]!\=/'  skip='\\.' end='/'	skipwhite nextgroup=vimSubst
    1              0.000026 syn region	vimGlobal	matchgroup=Statement start='\<v\%[global]!\=/' skip='\\.' end='/'	skipwhite nextgroup=vimSubst
                            
                            " Embedded Scripts:  {{{2
                            " ================
                            "   perl,ruby     : Benoit Cerrina
                            "   python,tcl    : Johannes Zellner
                            "   mzscheme, lua : Charles Campbell
                            
                            " Allows users to specify the type of embedded script highlighting
                            " they want:  (perl/python/ruby/tcl support)
                            "   g:vimsyn_embed == 0   : don't embed any scripts
                            "   g:vimsyn_embed =~# 'l' : embed lua
                            "   g:vimsyn_embed =~# 'm' : embed mzscheme
                            "   g:vimsyn_embed =~# 'p' : embed perl
                            "   g:vimsyn_embed =~# 'P' : embed python
                            "   g:vimsyn_embed =~# 'r' : embed ruby
                            "   g:vimsyn_embed =~# 't' : embed tcl
    1              0.000008 if !exists("g:vimsyn_embed")
                             let g:vimsyn_embed = 'l'
    1              0.000002 endif
                            
                            " [-- lua --] {{{3
    1              0.000172 let s:luapath= fnameescape(expand("<sfile>:p:h")."/lua.vim")
    1              0.000177 if !filereadable(s:luapath)
                             for s:luapath in split(globpath(&rtp,"syntax/lua.vim"),"\n")
                              if filereadable(fnameescape(s:luapath))
                               let s:luapath= fnameescape(s:luapath)
                               break
                              endif
                             endfor
    1              0.000002 endif
    1              0.000148 if g:vimsyn_embed =~# 'l' && filereadable(s:luapath)
    1              0.000008  unlet! b:current_syntax
    1              0.000015  syn cluster vimFuncBodyList	add=vimLuaRegion
    1   0.005889   0.001199  exe "syn include @vimLuaScript ".s:luapath
    1              0.000068  VimFoldl syn region vimLuaRegion matchgroup=vimScriptDelim start=+lua\s*<<\s*\z(.*\)$+ end=+^\z1$+	contains=@vimLuaScript
    1              0.000035  VimFoldl syn region vimLuaRegion matchgroup=vimScriptDelim start=+lua\s*<<\s*$+ end=+\.$+	contains=@vimLuaScript
    1              0.000014  syn cluster vimFuncBodyList	add=vimLuaRegion
                            else
                             syn region vimEmbedError start=+lua\s*<<\s*\z(.*\)$+ end=+^\z1$+
                             syn region vimEmbedError start=+lua\s*<<\s*$+ end=+\.$+
    1              0.000003 endif
    1              0.000008 unlet s:luapath
                            
                            " [-- perl --] {{{3
    1              0.000222 let s:perlpath= fnameescape(expand("<sfile>:p:h")."/perl.vim")
    1              0.000183 if !filereadable(s:perlpath)
                             for s:perlpath in split(globpath(&rtp,"syntax/perl.vim"),"\n")
                              if filereadable(fnameescape(s:perlpath))
                               let s:perlpath= fnameescape(s:perlpath)
                               break
                              endif
                             endfor
    1              0.000002 endif
    1              0.000041 if g:vimsyn_embed =~# 'p' && filereadable(s:perlpath)
                             unlet! b:current_syntax
                             syn cluster vimFuncBodyList	add=vimPerlRegion
                             let s:foldmethod = &l:foldmethod
                             exe "syn include @vimPerlScript ".s:perlpath
                             let &l:foldmethod = s:foldmethod
                             VimFoldp syn region vimPerlRegion  matchgroup=vimScriptDelim start=+pe\%[rl]\s*<<\s*\z(\S*\)\ze\(\s*["#].*\)\=$+ end=+^\z1\ze\(\s*[#"].*\)\=$+	contains=@vimPerlScript
                             VimFoldp syn region vimPerlRegion	matchgroup=vimScriptDelim start=+pe\%[rl]\s*<<\s*$+ end=+\.$+			contains=@vimPerlScript
                             syn cluster vimFuncBodyList	add=vimPerlRegion
    1              0.000003 else
    1              0.000031  syn region vimEmbedError start=+pe\%[rl]\s*<<\s*\z(.*\)$+ end=+^\z1$+
    1              0.000022  syn region vimEmbedError start=+pe\%[rl]\s*<<\s*$+ end=+\.$+
    1              0.000002 endif
    1              0.000006 unlet s:perlpath
                            
                            " [-- ruby --] {{{3
    1              0.000157 let s:rubypath= fnameescape(expand("<sfile>:p:h")."/ruby.vim")
    1              0.000166 if !filereadable(s:rubypath)
                             for s:rubypath in split(globpath(&rtp,"syntax/ruby.vim"),"\n")
                              if filereadable(fnameescape(s:rubypath))
                               let s:rubypath= fnameescape(s:rubypath)
                               break
                              endif
                             endfor
    1              0.000002 endif
    1              0.000015 if g:vimsyn_embed =~# 'r' && filereadable(s:rubypath)
                             syn cluster vimFuncBodyList	add=vimRubyRegion
                             unlet! b:current_syntax
                             let s:foldmethod = &l:foldmethod
                             exe "syn include @vimRubyScript ".s:rubypath
                             let &l:foldmethod = s:foldmethod
                             VimFoldr syn region vimRubyRegion	matchgroup=vimScriptDelim start=+rub[y]\s*<<\s*\z(\S*\)\ze\(\s*#.*\)\=$+ end=+^\z1\ze\(\s*".*\)\=$+	contains=@vimRubyScript
                             syn region vimRubyRegion	matchgroup=vimScriptDelim start=+rub[y]\s*<<\s*$+ end=+\.$+			contains=@vimRubyScript
                             syn cluster vimFuncBodyList	add=vimRubyRegion
    1              0.000002 else
    1              0.000019  syn region vimEmbedError start=+rub[y]\s*<<\s*\z(.*\)$+ end=+^\z1$+
    1              0.000012  syn region vimEmbedError start=+rub[y]\s*<<\s*$+ end=+\.$+
    1              0.000002 endif
    1              0.000004 unlet s:rubypath
                            
                            " [-- python --] {{{3
    1              0.000118 let s:pythonpath= fnameescape(expand("<sfile>:p:h")."/python.vim")
    1              0.000147 if !filereadable(s:pythonpath)
                             for s:pythonpath in split(globpath(&rtp,"syntax/python.vim"),"\n")
                              if filereadable(fnameescape(s:pythonpath))
                               let s:pythonpath= fnameescape(s:pythonpath)
                               break
                              endif
                             endfor
    1              0.000002 endif
    1              0.000013 if g:vimsyn_embed =~# 'P' && filereadable(s:pythonpath)
                             unlet! b:current_syntax
                             syn cluster vimFuncBodyList	add=vimPythonRegion
                             exe "syn include @vimPythonScript ".s:pythonpath
                             VimFoldP syn region vimPythonRegion matchgroup=vimScriptDelim start=+py\%[thon][3x]\=\s*<<\s*\%(trim\s*\)\=\z(\S*\)\ze\(\s*#.*\)\=$+ end=+^\z1\ze\(\s*".*\)\=$+	contains=@vimPythonScript
                             VimFoldP syn region vimPythonRegion matchgroup=vimScriptDelim start=+py\%[thon][3x]\=\s*<<\s*\%(trim\s*\)\=$+ end=+\.$+				contains=@vimPythonScript
                             VimFoldP syn region vimPythonRegion matchgroup=vimScriptDelim start=+Py\%[thon]2or3\s*<<\s*\%(trim\s*\)\=\z(\S*\)\ze\(\s*#.*\)\=$+ end=+^\z1\ze\(\s*".*\)\=$+	contains=@vimPythonScript
                             VimFoldP syn region vimPythonRegion matchgroup=vimScriptDelim start=+Py\%[thon]2or3\=\s*<<\s*\%(trim\s*\)\=$+ end=+\.$+				contains=@vimPythonScript
                             syn cluster vimFuncBodyList	add=vimPythonRegion
    1              0.000002 else
    1              0.000023  syn region vimEmbedError start=+py\%[thon]3\=\s*<<\s*\z(.*\)$+ end=+^\z1$+
    1              0.000014  syn region vimEmbedError start=+py\%[thon]3\=\s*<<\s*$+ end=+\.$+
    1              0.000002 endif
    1              0.000004 unlet s:pythonpath
                            
                            " [-- tcl --] {{{3
    1              0.000014 if has("win32") || has("win95") || has("win64") || has("win16")
                             " apparently has("tcl") has been hanging vim on some windows systems with cygwin
    1              0.000046  let s:trytcl= (&shell !~ '\<\%(bash\>\|4[nN][tT]\|\<zsh\)\>\%(\.exe\)\=$')
                            else
                             let s:trytcl= 1
    1              0.000002 endif
    1              0.000004 if s:trytcl
    1              0.000112  let s:tclpath= fnameescape(expand("<sfile>:p:h")."/tcl.vim")
    1              0.000136  if !filereadable(s:tclpath)
                              for s:tclpath in split(globpath(&rtp,"syntax/tcl.vim"),"\n")
                               if filereadable(fnameescape(s:tclpath))
                                let s:tclpath= fnameescape(s:tclpath)
                                break
                               endif
                              endfor
    1              0.000002  endif
    1              0.000012  if g:vimsyn_embed =~# 't' && filereadable(s:tclpath)
                              unlet! b:current_syntax
                              syn cluster vimFuncBodyList	add=vimTclRegion
                              exe "syn include @vimTclScript ".s:tclpath
                              VimFoldt syn region vimTclRegion matchgroup=vimScriptDelim start=+tc[l]\=\s*<<\s*\z(.*\)$+ end=+^\z1$+	contains=@vimTclScript
                              VimFoldt syn region vimTclRegion matchgroup=vimScriptDelim start=+tc[l]\=\s*<<\s*$+ end=+\.$+	contains=@vimTclScript
                              syn cluster vimFuncBodyList	add=vimTclScript
    1              0.000002  else
    1              0.000017   syn region vimEmbedError start=+tc[l]\=\s*<<\s*\z(.*\)$+ end=+^\z1$+
    1              0.000011   syn region vimEmbedError start=+tc[l]\=\s*<<\s*$+ end=+\.$+
    1              0.000002  endif
    1              0.000004  unlet s:tclpath
                            else
                             syn region vimEmbedError start=+tc[l]\=\s*<<\s*\z(.*\)$+ end=+^\z1$+
                             syn region vimEmbedError start=+tc[l]\=\s*<<\s*$+ end=+\.$+
    1              0.000002 endif
    1              0.000003 unlet s:trytcl
                            
                            " [-- mzscheme --] {{{3
    1              0.000107 let s:mzschemepath= fnameescape(expand("<sfile>:p:h")."/scheme.vim")
    1              0.000153 if !filereadable(s:mzschemepath)
                             for s:mzschemepath in split(globpath(&rtp,"syntax/mzscheme.vim"),"\n")
                              if filereadable(fnameescape(s:mzschemepath))
                               let s:mzschemepath= fnameescape(s:mzschemepath)
                               break
                              endif
                             endfor
    1              0.000002 endif
    1              0.000012 if g:vimsyn_embed =~# 'm' && filereadable(s:mzschemepath)
                             unlet! b:current_syntax
                             let s:iskKeep= &isk
                             syn cluster vimFuncBodyList	add=vimMzSchemeRegion
                             exe "syn include @vimMzSchemeScript ".s:mzschemepath
                             let &isk= s:iskKeep
                             unlet s:iskKeep
                             VimFoldm syn region vimMzSchemeRegion matchgroup=vimScriptDelim start=+mz\%[scheme]\s*<<\s*\z(.*\)$+ end=+^\z1$+	contains=@vimMzSchemeScript
                             VimFoldm syn region vimMzSchemeRegion matchgroup=vimScriptDelim start=+mz\%[scheme]\s*<<\s*$+ end=+\.$+		contains=@vimMzSchemeScript
                             syn cluster vimFuncBodyList	add=vimMzSchemeRegion
    1              0.000002 else
    1              0.000020  syn region vimEmbedError start=+mz\%[scheme]\s*<<\s*\z(.*\)$+ end=+^\z1$+
    1              0.000014  syn region vimEmbedError start=+mz\%[scheme]\s*<<\s*$+ end=+\.$+
    1              0.000002 endif
    1              0.000004 unlet s:mzschemepath
                            
                            " Synchronize (speed) {{{2
                            "============
    1              0.000007 if exists("g:vimsyn_minlines")
                             exe "syn sync minlines=".g:vimsyn_minlines
    1              0.000002 endif
    1              0.000015 exe "syn sync maxlines=".s:vimsyn_maxlines
    1              0.000016 syn sync linecont	"^\s\+\\"
    1              0.000023 syn sync match vimAugroupSyncA	groupthere NONE	"\<aug\%[roup]\>\s\+[eE][nN][dD]"
                            
                            " ====================
                            " Highlighting Settings {{{2
                            " ====================
                            
    1              0.000007 if !exists("skip_vim_syntax_inits")
    1              0.000005  if !exists("g:vimsyn_noerror")
    1              0.000005   hi def link vimBehaveError	vimError
    1              0.000004   hi def link vimCollClassErr	vimError
    1              0.000003   hi def link vimErrSetting	vimError
    1              0.000003   hi def link vimEmbedError	Normal
    1              0.000003   hi def link vimFTError	vimError
    1              0.000003   hi def link vimFunctionError	vimError
    1              0.000003   hi def link vimFunc         	vimError
    1              0.000003   hi def link vimHiAttribList	vimError
    1              0.000003   hi def link vimHiCtermError	vimError
    1              0.000003   hi def link vimHiKeyError	vimError
    1              0.000003   hi def link vimKeyCodeError	vimError
    1              0.000003   hi def link vimMapModErr	vimError
    1              0.000003   hi def link vimSubstFlagErr	vimError
    1              0.000003   hi def link vimSynCaseError	vimError
    1              0.000003   hi def link vimBufnrWarn	vimWarn
    1              0.000001  endif
                            
    1              0.000003  hi def link vimAbb	vimCommand
    1              0.000003  hi def link vimAddress	vimMark
    1              0.000003  hi def link vimAugroupError	vimError
    1              0.000003  hi def link vimAugroupKey	vimCommand
    1              0.000004  hi def link vimAuHighlight	vimHighlight
    1              0.000003  hi def link vimAutoCmdOpt	vimOption
    1              0.000003  hi def link vimAutoCmd	vimCommand
    1              0.000003  hi def link vimAutoEvent	Type
    1              0.000003  hi def link vimAutoCmdMod	Special
    1              0.000003  hi def link vimAutoSet	vimCommand
    1              0.000003  hi def link vimBehaveModel	vimBehave
    1              0.000003  hi def link vimBehave	vimCommand
    1              0.000003  hi def link vimBracket	Delimiter
    1              0.000003  hi def link vimCmplxRepeat	SpecialChar
    1              0.000003  hi def link vimCommand	Statement
    1              0.000003  hi def link vimComment	Comment
    1              0.000003  hi def link vim9Comment	Comment
    1              0.000003  hi def link vimCommentString	vimString
    1              0.000003  hi def link vimCommentTitle	PreProc
    1              0.000002  hi def link vimCondHL	vimCommand
    1              0.000022  hi def link vimContinue	Special
    1              0.000003  hi def link vimCtrlChar	SpecialChar
    1              0.000003  hi def link vimEchoHLNone	vimGroup
    1              0.000003  hi def link vimEchoHL	vimCommand
    1              0.000003  hi def link vimElseIfErr	Error
    1              0.000003  hi def link vimElseif	vimCondHL
    1              0.000002  hi def link vimEnvvar	PreProc
    1              0.000003  hi def link vimError	Error
    1              0.000003  hi def link vimFBVar	vimVar
    1              0.000003  hi def link vimFgBgAttrib	vimHiAttrib
    1              0.000003  hi def link vimHiCtermul	vimHiTerm
    1              0.000003  hi def link vimFold	Folded
    1              0.000003  hi def link vimFTCmd	vimCommand
    1              0.000003  hi def link vimFTOption	vimSynType
    1              0.000003  hi def link vimFuncKey	vimCommand
    1              0.000003  hi def link vimFuncName	Function
    1              0.000003  hi def link vimFuncSID	Special
    1              0.000003  hi def link vimFuncVar	Identifier
    1              0.000003  hi def link vimGroupAdd	vimSynOption
    1              0.000003  hi def link vimGroupName	vimGroup
    1              0.000003  hi def link vimGroupRem	vimSynOption
    1              0.000003  hi def link vimGroupSpecial	Special
    1              0.000003  hi def link vimGroup	Type
    1              0.000003  hi def link vimHiAttrib	PreProc
    1              0.000003  hi def link vimHiBlend	vimHiTerm
    1              0.000003  hi def link vimHiClear	vimHighlight
    1              0.000003  hi def link vimHiCtermFgBg	vimHiTerm
    1              0.000003  hi def link vimHiCTerm	vimHiTerm
    1              0.000003  hi def link vimHighlight	vimCommand
    1              0.000003  hi def link vimHiGroup	vimGroupName
    1              0.000003  hi def link vimHiGuiFgBg	vimHiTerm
    1              0.000003  hi def link vimHiGuiFont	vimHiTerm
    1              0.000003  hi def link vimHiGuiRgb	vimNumber
    1              0.000003  hi def link vimHiGui	vimHiTerm
    1              0.000003  hi def link vimHiNmbr	Number
    1              0.000003  hi def link vimHiStartStop	vimHiTerm
    1              0.000003  hi def link vimHiTerm	Type
    1              0.000003  hi def link vimHLGroup	vimGroup
    1              0.000003  hi def link vimHLMod	PreProc
    1              0.000002  hi def link vimInsert	vimString
    1              0.000002  hi def link vimIskSep	Delimiter
    1              0.000003  hi def link vimKeyCode	vimSpecFile
    1              0.000003  hi def link vimKeyword	Statement
    1              0.000003  hi def link vimLet	vimCommand
    1              0.000003  hi def link vimLetHereDoc	vimString
    1              0.000003  hi def link vimLetHereDocStart	Special
    1              0.000003  hi def link vimLetHereDocStop	Special
    1              0.000003  hi def link vimLineComment	vimComment
    1              0.000003  hi def link vim9LineComment	vimComment
    1              0.000003  hi def link vimMapBang	vimCommand
    1              0.000003  hi def link vimMapModKey	vimFuncSID
    1              0.000003  hi def link vimMapMod	vimBracket
    1              0.000002  hi def link vimMap	vimCommand
    1              0.000003  hi def link vimMark	Number
    1              0.000003  hi def link vimMarkNumber	vimNumber
    1              0.000003  hi def link vimMenuMod	vimMapMod
    1              0.000003  hi def link vimMenuNameMore	vimMenuName
    1              0.000003  hi def link vimMenuName	PreProc
    1              0.000003  hi def link vimMtchComment	vimComment
    1              0.000003  hi def link vimNorm	vimCommand
    1              0.000003  hi def link vimNotation	Special
    1              0.000003  hi def link vimNotFunc	vimCommand
    1              0.000003  hi def link vimNotPatSep	vimString
    1              0.000002  hi def link vimNumber	Number
    1              0.000003  hi def link vimOperError	Error
    1              0.000003  hi def link vimOper	Operator
    1              0.000003  hi def link vimOperStar	vimOper
    1              0.000003  hi def link vimOption	PreProc
    1              0.000003  hi def link vimParenSep	Delimiter
    1              0.000003  hi def link vimPatSepErr	vimError
    1              0.000003  hi def link vimPatSepR	vimPatSep
    1              0.000003  hi def link vimPatSep	SpecialChar
    1              0.000003  hi def link vimPatSepZone	vimString
    1              0.000002  hi def link vimPatSepZ	vimPatSep
    1              0.000003  hi def link vimPattern	Type
    1              0.000003  hi def link vimPlainMark	vimMark
    1              0.000003  hi def link vimPlainRegister	vimRegister
    1              0.000003  hi def link vimRegister	SpecialChar
    1              0.000003  hi def link vimScriptDelim	Comment
    1              0.000003  hi def link vimSearchDelim	Statement
    1              0.000003  hi def link vimSearch	vimString
    1              0.000003  hi def link vimSep	Delimiter
    1              0.000003  hi def link vimSetMod	vimOption
    1              0.000002  hi def link vimSetSep	Statement
    1              0.000003  hi def link vimSetString	vimString
    1              0.000003  hi def link vimSpecFile	Identifier
    1              0.000003  hi def link vimSpecFileMod	vimSpecFile
    1              0.000003  hi def link vimSpecial	Type
    1              0.000003  hi def link vimStatement	Statement
    1              0.000003  hi def link vimStringCont	vimString
    1              0.000003  hi def link vimString	String
    1              0.000003  hi def link vimStringEnd	vimString
    1              0.000003  hi def link vimSubst1	vimSubst
    1              0.000003  hi def link vimSubstDelim	Delimiter
    1              0.000003  hi def link vimSubstFlags	Special
    1              0.000003  hi def link vimSubstSubstr	SpecialChar
    1              0.000003  hi def link vimSubstTwoBS	vimString
    1              0.000003  hi def link vimSubst	vimCommand
    1              0.000003  hi def link vimSynCaseError	Error
    1              0.000002  hi def link vimSynCase	Type
    1              0.000003  hi def link vimSyncC	Type
    1              0.000003  hi def link vimSyncError	Error
    1              0.000003  hi def link vimSyncGroupName	vimGroupName
    1              0.000003  hi def link vimSyncGroup	vimGroupName
    1              0.000002  hi def link vimSyncKey	Type
    1              0.000003  hi def link vimSyncNone	Type
    1              0.000003  hi def link vimSynContains	vimSynOption
    1              0.000003  hi def link vimSynError	Error
    1              0.000003  hi def link vimSynKeyContainedin	vimSynContains
    1              0.000003  hi def link vimSynKeyOpt	vimSynOption
    1              0.000003  hi def link vimSynMtchGrp	vimSynOption
    1              0.000003  hi def link vimSynMtchOpt	vimSynOption
    1              0.000003  hi def link vimSynNextgroup	vimSynOption
    1              0.000003  hi def link vimSynNotPatRange	vimSynRegPat
    1              0.000003  hi def link vimSynOption	Special
    1              0.000013  hi def link vimSynPatRange	vimString
    1              0.000003  hi def link vimSynRegOpt	vimSynOption
    1              0.000003  hi def link vimSynRegPat	vimString
    1              0.000003  hi def link vimSynReg	Type
    1              0.000002  hi def link vimSyntax	vimCommand
    1              0.000003  hi def link vimSynType	vimSpecial
    1              0.000003  hi def link vimTodo	Todo
    1              0.000002  hi def link vimType	Type
    1              0.000003  hi def link vimUnmap	vimMap
    1              0.000003  hi def link vimUserAttrbCmpltFunc	Special
    1              0.000003  hi def link vimUserAttrbCmplt	vimSpecial
    1              0.000003  hi def link vimUserAttrbKey	vimOption
    1              0.000003  hi def link vimUserAttrb	vimSpecial
    1              0.000003  hi def link vimUserAttrbError	Error
    1              0.000003  hi def link vimUserCmdError	Error
    1              0.000003  hi def link vimUserCommand	vimCommand
    1              0.000003  hi def link vimUserFunc	Normal
    1              0.000002  hi def link vimVar	Identifier
    1              0.000002  hi def link vimWarn	WarningMsg
                            
    1              0.000003  hi def link nvimAutoEvent	vimAutoEvent
    1              0.000003  hi def link nvimHLGroup	vimHLGroup
    1              0.000003  hi def link nvimMap	vimMap
    1              0.000003  hi def link nvimUnmap	vimUnmap
    1              0.000001 endif
                            
                            " Current Syntax Variable: {{{2
    1              0.000006 let b:current_syntax = "vim"
                            
                            " ---------------------------------------------------------------------
                            " Cleanup: {{{1
    1              0.000005 delc VimFolda
    1              0.000003 delc VimFoldf
    1              0.000003 delc VimFoldl
    1              0.000003 delc VimFoldm
    1              0.000002 delc VimFoldp
    1              0.000002 delc VimFoldP
    1              0.000002 delc VimFoldr
    1              0.000003 delc VimFoldt
    1              0.000019 let &cpo = s:keepcpo
    1              0.000004 unlet s:keepcpo
                            " vim:ts=18  fdm=marker

SCRIPT  C:\Users\Lenovo\scoop\apps\neovim\0.6.1\share\nvim\runtime\syntax\lua.vim
Sourced 1 time
Total time:   0.004492
 Self time:   0.004492

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:	Lua 4.0, Lua 5.0, Lua 5.1 and Lua 5.2
                            " Maintainer:	Marcus Aurelius Farias <masserahguard-lua 'at' yahoo com>
                            " First Author:	Carlos Augusto Teixeira Mendes <cmendes 'at' inf puc-rio br>
                            " Last Change:	2012 Aug 12
                            " Options:	lua_version = 4 or 5
                            "		lua_subversion = 0 (4.0, 5.0) or 1 (5.1) or 2 (5.2)
                            "		default 5.2
                            
                            " quit when a syntax file was already loaded
    1              0.000012 if exists("b:current_syntax")
                              finish
    1              0.000002 endif
                            
    1              0.000014 let s:cpo_save = &cpo
    1              0.000015 set cpo&vim
                            
    1              0.000007 if !exists("lua_version")
                              " Default is lua 5.2
                              let lua_version = 5
                              let lua_subversion = 2
    1              0.000007 elseif !exists("lua_subversion")
                              " lua_version exists, but lua_subversion doesn't. So, set it to 0
                              let lua_subversion = 0
    1              0.000001 endif
                            
    1              0.000004 syn case match
                            
                            " syncing method
    1              0.000004 syn sync minlines=100
                            
                            " Comments
    1              0.000008 syn keyword luaTodo            contained TODO FIXME XXX
    1              0.000019 syn match   luaComment         "--.*$" contains=luaTodo,@Spell
    1              0.000008 if lua_version == 5 && lua_subversion == 0
                              syn region luaComment        matchgroup=luaComment start="--\[\[" end="\]\]" contains=luaTodo,luaInnerComment,@Spell
                              syn region luaInnerComment   contained transparent start="\[\[" end="\]\]"
    1              0.000011 elseif lua_version > 5 || (lua_version == 5 && lua_subversion >= 1)
                              " Comments in Lua 5.1: --[[ ... ]], [=[ ... ]=], [===[ ... ]===], etc.
    1              0.000027   syn region luaComment        matchgroup=luaComment start="--\[\z(=*\)\[" end="\]\z1\]" contains=luaTodo,@Spell
    1              0.000002 endif
                            
                            " First line may start with #!
    1              0.000013 syn match luaComment "\%^#!.*"
                            
                            " catch errors caused by wrong parenthesis and wrong curly brackets or
                            " keywords placed outside their respective blocks
    1              0.000038 syn region luaParen      transparent                     start='(' end=')' contains=ALLBUT,luaParenError,luaTodo,luaSpecial,luaIfThen,luaElseifThen,luaElse,luaThenEnd,luaBlock,luaLoopBlock,luaIn,luaStatement
    1              0.000026 syn region luaTableBlock transparent matchgroup=luaTable start="{" end="}" contains=ALLBUT,luaBraceError,luaTodo,luaSpecial,luaIfThen,luaElseifThen,luaElse,luaThenEnd,luaBlock,luaLoopBlock,luaIn,luaStatement
                            
    1              0.000005 syn match  luaParenError ")"
    1              0.000005 syn match  luaBraceError "}"
    1              0.000016 syn match  luaError "\<\%(end\|else\|elseif\|then\|until\|in\)\>"
                            
                            " function ... end
    1              0.000033 syn region luaFunctionBlock transparent matchgroup=luaFunction start="\<function\>" end="\<end\>" contains=ALLBUT,luaTodo,luaSpecial,luaElseifThen,luaElse,luaThenEnd,luaIn
                            
                            " if ... then
    1              0.000032 syn region luaIfThen transparent matchgroup=luaCond start="\<if\>" end="\<then\>"me=e-4           contains=ALLBUT,luaTodo,luaSpecial,luaElseifThen,luaElse,luaIn nextgroup=luaThenEnd skipwhite skipempty
                            
                            " then ... end
    1              0.000029 syn region luaThenEnd contained transparent matchgroup=luaCond start="\<then\>" end="\<end\>" contains=ALLBUT,luaTodo,luaSpecial,luaThenEnd,luaIn
                            
                            " elseif ... then
    1              0.000020 syn region luaElseifThen contained transparent matchgroup=luaCond start="\<elseif\>" end="\<then\>" contains=ALLBUT,luaTodo,luaSpecial,luaElseifThen,luaElse,luaThenEnd,luaIn
                            
                            " else
    1              0.000004 syn keyword luaElse contained else
                            
                            " do ... end
    1              0.000031 syn region luaBlock transparent matchgroup=luaStatement start="\<do\>" end="\<end\>"          contains=ALLBUT,luaTodo,luaSpecial,luaElseifThen,luaElse,luaThenEnd,luaIn
                            
                            " repeat ... until
    1              0.000020 syn region luaLoopBlock transparent matchgroup=luaRepeat start="\<repeat\>" end="\<until\>"   contains=ALLBUT,luaTodo,luaSpecial,luaElseifThen,luaElse,luaThenEnd,luaIn
                            
                            " while ... do
    1              0.000035 syn region luaLoopBlock transparent matchgroup=luaRepeat start="\<while\>" end="\<do\>"me=e-2 contains=ALLBUT,luaTodo,luaSpecial,luaIfThen,luaElseifThen,luaElse,luaThenEnd,luaIn nextgroup=luaBlock skipwhite skipempty
                            
                            " for ... do and for ... in ... do
    1              0.000035 syn region luaLoopBlock transparent matchgroup=luaRepeat start="\<for\>" end="\<do\>"me=e-2   contains=ALLBUT,luaTodo,luaSpecial,luaIfThen,luaElseifThen,luaElse,luaThenEnd nextgroup=luaBlock skipwhite skipempty
                            
    1              0.000003 syn keyword luaIn contained in
                            
                            " other keywords
    1              0.000006 syn keyword luaStatement return local break
    1              0.000008 if lua_version > 5 || (lua_version == 5 && lua_subversion >= 2)
    1              0.000005   syn keyword luaStatement goto
    1              0.000008   syn match luaLabel "::\I\i*::"
    1              0.000020 endif
    1              0.000007 syn keyword luaOperator and or not
    1              0.000005 syn keyword luaConstant nil
    1              0.000004 if lua_version > 4
    1              0.000005   syn keyword luaConstant true false
    1              0.000001 endif
                            
                            " Strings
    1              0.000004 if lua_version < 5
                              syn match  luaSpecial contained "\\[\\abfnrtv\'\"]\|\\[[:digit:]]\{,3}"
    1              0.000004 elseif lua_version == 5
    1              0.000004   if lua_subversion == 0
                                syn match  luaSpecial contained #\\[\\abfnrtv'"[\]]\|\\[[:digit:]]\{,3}#
                                syn region luaString2 matchgroup=luaString start=+\[\[+ end=+\]\]+ contains=luaString2,@Spell
    1              0.000003   else
    1              0.000004     if lua_subversion == 1
                                  syn match  luaSpecial contained #\\[\\abfnrtv'"]\|\\[[:digit:]]\{,3}#
    1              0.000004     else " Lua 5.2
    1              0.000022       syn match  luaSpecial contained #\\[\\abfnrtvz'"]\|\\x[[:xdigit:]]\{2}\|\\[[:digit:]]\{,3}#
    1              0.000003     endif
    1              0.000025     syn region luaString2 matchgroup=luaString start="\[\z(=*\)\[" end="\]\z1\]" contains=@Spell
    1              0.000002   endif
    1              0.000002 endif
    1              0.000037 syn region luaString  start=+'+ end=+'+ skip=+\\\\\|\\'+ contains=luaSpecial,@Spell
    1              0.000018 syn region luaString  start=+"+ end=+"+ skip=+\\\\\|\\"+ contains=luaSpecial,@Spell
                            
                            " integer number
    1              0.000008 syn match luaNumber "\<\d\+\>"
                            " floating point number, with dot, optional exponent
    1              0.000014 syn match luaNumber  "\<\d\+\.\d*\%([eE][-+]\=\d\+\)\=\>"
                            " floating point number, starting with a dot, optional exponent
    1              0.000011 syn match luaNumber  "\.\d\+\%([eE][-+]\=\d\+\)\=\>"
                            " floating point number, without dot, with exponent
    1              0.000015 syn match luaNumber  "\<\d\+[eE][-+]\=\d\+\>"
                            
                            " hex numbers
    1              0.000005 if lua_version >= 5
    1              0.000003   if lua_subversion == 1
                                syn match luaNumber "\<0[xX]\x\+\>"
    1              0.000005   elseif lua_subversion >= 2
    1              0.000014     syn match luaNumber "\<0[xX][[:xdigit:].]\+\%([pP][-+]\=\d\+\)\=\>"
    1              0.000002   endif
    1              0.000001 endif
                            
    1              0.000009 syn keyword luaFunc assert collectgarbage dofile error next
    1              0.000009 syn keyword luaFunc print rawget rawset tonumber tostring type _VERSION
                            
    1              0.000003 if lua_version == 4
                              syn keyword luaFunc _ALERT _ERRORMESSAGE gcinfo
                              syn keyword luaFunc call copytagmethods dostring
                              syn keyword luaFunc foreach foreachi getglobal getn
                              syn keyword luaFunc gettagmethod globals newtag
                              syn keyword luaFunc setglobal settag settagmethod sort
                              syn keyword luaFunc tag tinsert tremove
                              syn keyword luaFunc _INPUT _OUTPUT _STDIN _STDOUT _STDERR
                              syn keyword luaFunc openfile closefile flush seek
                              syn keyword luaFunc setlocale execute remove rename tmpname
                              syn keyword luaFunc getenv date clock exit
                              syn keyword luaFunc readfrom writeto appendto read write
                              syn keyword luaFunc PI abs sin cos tan asin
                              syn keyword luaFunc acos atan atan2 ceil floor
                              syn keyword luaFunc mod frexp ldexp sqrt min max log
                              syn keyword luaFunc log10 exp deg rad random
                              syn keyword luaFunc randomseed strlen strsub strlower strupper
                              syn keyword luaFunc strchar strrep ascii strbyte
                              syn keyword luaFunc format strfind gsub
                              syn keyword luaFunc getinfo getlocal setlocal setcallhook setlinehook
    1              0.000003 elseif lua_version == 5
    1              0.000006   syn keyword luaFunc getmetatable setmetatable
    1              0.000005   syn keyword luaFunc ipairs pairs
    1              0.000005   syn keyword luaFunc pcall xpcall
    1              0.000006   syn keyword luaFunc _G loadfile rawequal require
    1              0.000003   if lua_subversion == 0
                                syn keyword luaFunc getfenv setfenv
                                syn keyword luaFunc loadstring unpack
                                syn keyword luaFunc gcinfo loadlib LUA_PATH _LOADED _REQUIREDNAME
    1              0.000002   else
    1              0.000005     syn keyword luaFunc load select
    1              0.000011     syn match   luaFunc /\<package\.cpath\>/
    1              0.000015     syn match   luaFunc /\<package\.loaded\>/
    1              0.000011     syn match   luaFunc /\<package\.loadlib\>/
    1              0.000008     syn match   luaFunc /\<package\.path\>/
    1              0.000003     if lua_subversion == 1
                                  syn keyword luaFunc getfenv setfenv
                                  syn keyword luaFunc loadstring module unpack
                                  syn match   luaFunc /\<package\.loaders\>/
                                  syn match   luaFunc /\<package\.preload\>/
                                  syn match   luaFunc /\<package\.seeall\>/
    1              0.000004     elseif lua_subversion == 2
    1              0.000005       syn keyword luaFunc _ENV rawlen
    1              0.000008       syn match   luaFunc /\<package\.config\>/
    1              0.000008       syn match   luaFunc /\<package\.preload\>/
    1              0.000009       syn match   luaFunc /\<package\.searchers\>/
    1              0.000008       syn match   luaFunc /\<package\.searchpath\>/
    1              0.000008       syn match   luaFunc /\<bit32\.arshift\>/
    1              0.000007       syn match   luaFunc /\<bit32\.band\>/
    1              0.000026       syn match   luaFunc /\<bit32\.bnot\>/
    1              0.000008       syn match   luaFunc /\<bit32\.bor\>/
    1              0.000008       syn match   luaFunc /\<bit32\.btest\>/
    1              0.000007       syn match   luaFunc /\<bit32\.bxor\>/
    1              0.000008       syn match   luaFunc /\<bit32\.extract\>/
    1              0.000007       syn match   luaFunc /\<bit32\.lrotate\>/
    1              0.000008       syn match   luaFunc /\<bit32\.lshift\>/
    1              0.000007       syn match   luaFunc /\<bit32\.replace\>/
    1              0.000007       syn match   luaFunc /\<bit32\.rrotate\>/
    1              0.000007       syn match   luaFunc /\<bit32\.rshift\>/
    1              0.000002     endif
    1              0.000008     syn match luaFunc /\<coroutine\.running\>/
    1              0.000002   endif
    1              0.000009   syn match   luaFunc /\<coroutine\.create\>/
    1              0.000008   syn match   luaFunc /\<coroutine\.resume\>/
    1              0.000008   syn match   luaFunc /\<coroutine\.status\>/
    1              0.000008   syn match   luaFunc /\<coroutine\.wrap\>/
    1              0.000013   syn match   luaFunc /\<coroutine\.yield\>/
    1              0.000007   syn match   luaFunc /\<string\.byte\>/
    1              0.000007   syn match   luaFunc /\<string\.char\>/
    1              0.000006   syn match   luaFunc /\<string\.dump\>/
    1              0.000007   syn match   luaFunc /\<string\.find\>/
    1              0.000007   syn match   luaFunc /\<string\.format\>/
    1              0.000007   syn match   luaFunc /\<string\.gsub\>/
    1              0.000007   syn match   luaFunc /\<string\.len\>/
    1              0.000008   syn match   luaFunc /\<string\.lower\>/
    1              0.000007   syn match   luaFunc /\<string\.rep\>/
    1              0.000007   syn match   luaFunc /\<string\.sub\>/
    1              0.000007   syn match   luaFunc /\<string\.upper\>/
    1              0.000004   if lua_subversion == 0
                                syn match luaFunc /\<string\.gfind\>/
    1              0.000004   else
    1              0.000009     syn match luaFunc /\<string\.gmatch\>/
    1              0.000008     syn match luaFunc /\<string\.match\>/
    1              0.000015     syn match luaFunc /\<string\.reverse\>/
    1              0.000002   endif
    1              0.000004   if lua_subversion == 0
                                syn match luaFunc /\<table\.getn\>/
                                syn match luaFunc /\<table\.setn\>/
                                syn match luaFunc /\<table\.foreach\>/
                                syn match luaFunc /\<table\.foreachi\>/
    1              0.000006   elseif lua_subversion == 1
                                syn match luaFunc /\<table\.maxn\>/
    1              0.000007   elseif lua_subversion == 2
    1              0.000015     syn match luaFunc /\<table\.pack\>/
    1              0.000014     syn match luaFunc /\<table\.unpack\>/
    1              0.000003   endif
    1              0.000012   syn match   luaFunc /\<table\.concat\>/
    1              0.000040   syn match   luaFunc /\<table\.sort\>/
    1              0.000015   syn match   luaFunc /\<table\.insert\>/
    1              0.000016   syn match   luaFunc /\<table\.remove\>/
    1              0.000009   syn match   luaFunc /\<math\.abs\>/
    1              0.000008   syn match   luaFunc /\<math\.acos\>/
    1              0.000007   syn match   luaFunc /\<math\.asin\>/
    1              0.000007   syn match   luaFunc /\<math\.atan\>/
    1              0.000007   syn match   luaFunc /\<math\.atan2\>/
    1              0.000006   syn match   luaFunc /\<math\.ceil\>/
    1              0.000007   syn match   luaFunc /\<math\.sin\>/
    1              0.000007   syn match   luaFunc /\<math\.cos\>/
    1              0.000007   syn match   luaFunc /\<math\.tan\>/
    1              0.000006   syn match   luaFunc /\<math\.deg\>/
    1              0.000006   syn match   luaFunc /\<math\.exp\>/
    1              0.000007   syn match   luaFunc /\<math\.floor\>/
    1              0.000006   syn match   luaFunc /\<math\.log\>/
    1              0.000006   syn match   luaFunc /\<math\.max\>/
    1              0.000006   syn match   luaFunc /\<math\.min\>/
    1              0.000005   if lua_subversion == 0
                                syn match luaFunc /\<math\.mod\>/
                                syn match luaFunc /\<math\.log10\>/
    1              0.000002   else
    1              0.000003     if lua_subversion == 1
                                  syn match luaFunc /\<math\.log10\>/
    1              0.000002     endif
    1              0.000017     syn match luaFunc /\<math\.huge\>/
    1              0.000011     syn match luaFunc /\<math\.fmod\>/
    1              0.000007     syn match luaFunc /\<math\.modf\>/
    1              0.000006     syn match luaFunc /\<math\.cosh\>/
    1              0.000006     syn match luaFunc /\<math\.sinh\>/
    1              0.000006     syn match luaFunc /\<math\.tanh\>/
    1              0.000002   endif
    1              0.000007   syn match   luaFunc /\<math\.pow\>/
    1              0.000006   syn match   luaFunc /\<math\.rad\>/
    1              0.000010   syn match   luaFunc /\<math\.sqrt\>/
    1              0.000007   syn match   luaFunc /\<math\.frexp\>/
    1              0.000007   syn match   luaFunc /\<math\.ldexp\>/
    1              0.000009   syn match   luaFunc /\<math\.random\>/
    1              0.000009   syn match   luaFunc /\<math\.randomseed\>/
    1              0.000009   syn match   luaFunc /\<math\.pi\>/
    1              0.000007   syn match   luaFunc /\<io\.close\>/
    1              0.000007   syn match   luaFunc /\<io\.flush\>/
    1              0.000006   syn match   luaFunc /\<io\.input\>/
    1              0.000006   syn match   luaFunc /\<io\.lines\>/
    1              0.000007   syn match   luaFunc /\<io\.open\>/
    1              0.000007   syn match   luaFunc /\<io\.output\>/
    1              0.000006   syn match   luaFunc /\<io\.popen\>/
    1              0.000007   syn match   luaFunc /\<io\.read\>/
    1              0.000007   syn match   luaFunc /\<io\.stderr\>/
    1              0.000007   syn match   luaFunc /\<io\.stdin\>/
    1              0.000007   syn match   luaFunc /\<io\.stdout\>/
    1              0.000007   syn match   luaFunc /\<io\.tmpfile\>/
    1              0.000006   syn match   luaFunc /\<io\.type\>/
    1              0.000007   syn match   luaFunc /\<io\.write\>/
    1              0.000006   syn match   luaFunc /\<os\.clock\>/
    1              0.000007   syn match   luaFunc /\<os\.date\>/
    1              0.000011   syn match   luaFunc /\<os\.difftime\>/
    1              0.000012   syn match   luaFunc /\<os\.execute\>/
    1              0.000011   syn match   luaFunc /\<os\.exit\>/
    1              0.000044   syn match   luaFunc /\<os\.getenv\>/
    1              0.000011   syn match   luaFunc /\<os\.remove\>/
    1              0.000011   syn match   luaFunc /\<os\.rename\>/
    1              0.000014   syn match   luaFunc /\<os\.setlocale\>/
    1              0.000008   syn match   luaFunc /\<os\.time\>/
    1              0.000010   syn match   luaFunc /\<os\.tmpname\>/
    1              0.000008   syn match   luaFunc /\<debug\.debug\>/
    1              0.000009   syn match   luaFunc /\<debug\.gethook\>/
    1              0.000008   syn match   luaFunc /\<debug\.getinfo\>/
    1              0.000009   syn match   luaFunc /\<debug\.getlocal\>/
    1              0.000009   syn match   luaFunc /\<debug\.getupvalue\>/
    1              0.000008   syn match   luaFunc /\<debug\.setlocal\>/
    1              0.000008   syn match   luaFunc /\<debug\.setupvalue\>/
    1              0.000007   syn match   luaFunc /\<debug\.sethook\>/
    1              0.000008   syn match   luaFunc /\<debug\.traceback\>/
    1              0.000006   if lua_subversion == 1
                                syn match luaFunc /\<debug\.getfenv\>/
                                syn match luaFunc /\<debug\.setfenv\>/
                                syn match luaFunc /\<debug\.getmetatable\>/
                                syn match luaFunc /\<debug\.setmetatable\>/
                                syn match luaFunc /\<debug\.getregistry\>/
    1              0.000007   elseif lua_subversion == 2
    1              0.000011     syn match luaFunc /\<debug\.getmetatable\>/
    1              0.000009     syn match luaFunc /\<debug\.setmetatable\>/
    1              0.000009     syn match luaFunc /\<debug\.getregistry\>/
    1              0.000008     syn match luaFunc /\<debug\.getuservalue\>/
    1              0.000008     syn match luaFunc /\<debug\.setuservalue\>/
    1              0.000010     syn match luaFunc /\<debug\.upvalueid\>/
    1              0.000009     syn match luaFunc /\<debug\.upvaluejoin\>/
    1              0.000002   endif
    1              0.000001 endif
                            
                            " Define the default highlighting.
                            " Only when an item doesn't have highlighting yet
                            
    1              0.000008 hi def link luaStatement		Statement
    1              0.000004 hi def link luaRepeat		Repeat
    1              0.000003 hi def link luaFor			Repeat
    1              0.000004 hi def link luaString		String
    1              0.000003 hi def link luaString2		String
    1              0.000003 hi def link luaNumber		Number
    1              0.000003 hi def link luaOperator		Operator
    1              0.000003 hi def link luaIn			Operator
    1              0.000005 hi def link luaConstant		Constant
    1              0.000005 hi def link luaCond		Conditional
    1              0.000003 hi def link luaElse		Conditional
    1              0.000003 hi def link luaFunction		Function
    1              0.000004 hi def link luaComment		Comment
    1              0.000004 hi def link luaTodo		Todo
    1              0.000004 hi def link luaTable		Structure
    1              0.000003 hi def link luaError		Error
    1              0.000003 hi def link luaParenError		Error
    1              0.000003 hi def link luaBraceError		Error
    1              0.000003 hi def link luaSpecial		SpecialChar
    1              0.000003 hi def link luaFunc		Identifier
    1              0.000003 hi def link luaLabel		Label
                            
                            
    1              0.000011 let b:current_syntax = "lua"
                            
    1              0.000058 let &cpo = s:cpo_save
    1              0.000010 unlet s:cpo_save
                            " vim: et ts=8 sw=2

SCRIPT  C:\Users\Lenovo\AppData\Local\nvim-data\plugged\vim-polyglot\syntax\python.vim
Sourced 33 times
Total time:   0.597410
 Self time:   0.545748

count  total (s)   self (s)
   33   0.014144   0.009590 if polyglot#init#is_disabled(expand('<sfile>:p'), 'python', 'syntax/python.vim')
                              finish
   33              0.000127 endif
                            
                            " For version 5.x: Clear all syntax items
                            " For versions greater than 6.x: Quit when a syntax file was already loaded
   33              0.000290 if v:version < 600
                                syntax clear
   33              0.000470 elseif exists('b:current_syntax')
                                finish
   33              0.000105 endif
                            
                            "
                            " Commands
                            "
   33              0.002709 command! -buffer Python2Syntax let b:python_version_2 = 1 | let &syntax=&syntax
   33              0.002397 command! -buffer Python3Syntax let b:python_version_2 = 0 | let &syntax=&syntax
                            
                            " Enable option if it's not defined
   33              0.000640 function! s:EnableByDefault(name)
                                if !exists(a:name)
                                    let {a:name} = 1
                                endif
                            endfunction
                            
                            " Check if option is enabled
   33              0.000311 function! s:Enabled(name)
                                return exists(a:name) && {a:name}
                            endfunction
                            
                            " Is it Python 2 syntax?
   33              0.000304 function! s:Python2Syntax()
                                if exists('b:python_version_2')
                                    return b:python_version_2
                                endif
                                return s:Enabled('g:python_version_2')
                            endfunction
                            
                            "
                            " Default options
                            "
                            
   33   0.002413   0.001438 call s:EnableByDefault('g:python_slow_sync')
   33   0.001757   0.001027 call s:EnableByDefault('g:python_highlight_builtin_funcs_kwarg')
                            
   33   0.001998   0.001256 if s:Enabled('g:python_highlight_all')
                                call s:EnableByDefault('g:python_highlight_builtins')
                                call s:EnableByDefault('g:python_highlight_exceptions')
                                call s:EnableByDefault('g:python_highlight_string_formatting')
                                call s:EnableByDefault('g:python_highlight_string_format')
                                call s:EnableByDefault('g:python_highlight_string_templates')
                                call s:EnableByDefault('g:python_highlight_indent_errors')
                                call s:EnableByDefault('g:python_highlight_space_errors')
                                call s:EnableByDefault('g:python_highlight_doctests')
                                call s:EnableByDefault('g:python_print_as_function')
                                call s:EnableByDefault('g:python_highlight_func_calls')
                                call s:EnableByDefault('g:python_highlight_class_vars')
                                call s:EnableByDefault('g:python_highlight_operators')
   33              0.000109 endif
                            
   33   0.001749   0.000852 if s:Enabled('g:python_highlight_builtins')
                                call s:EnableByDefault('g:python_highlight_builtin_objs')
                                call s:EnableByDefault('g:python_highlight_builtin_types')
                                call s:EnableByDefault('g:python_highlight_builtin_funcs')
   33              0.000094 endif
                            
                            "
                            " Function calls
                            "
                            
   33   0.001522   0.000821 if s:Enabled('g:python_highlight_func_calls')
   33              0.002488     syn match pythonFunctionCall '\%([^[:cntrl:][:space:][:punct:][:digit:]]\|_\)\%([^[:cntrl:][:punct:][:space:]]\|_\)*\ze\%(\s*(\)'
   33              0.000156 endif
                            
                            "
                            " Keywords
                            "
                            
   33              0.000829 syn keyword pythonStatement     break continue del return pass yield global assert lambda with
   33              0.000626 syn keyword pythonStatement     raise nextgroup=pythonExClass skipwhite
   33              0.000504 syn keyword pythonStatement     def nextgroup=pythonFunction skipwhite
   33              0.000415 syn keyword pythonStatement     class nextgroup=pythonClass skipwhite
   33   0.001848   0.001038 if s:Enabled('g:python_highlight_class_vars')
                                syn keyword pythonClassVar    self cls mcs
   33              0.000130 endif
   33              0.000396 syn keyword pythonRepeat        for while
   33              0.000327 syn keyword pythonConditional   if elif else
   33              0.000379 syn keyword pythonException     try except finally
                            " The standard pyrex.vim unconditionally removes the pythonInclude group, so
                            " we provide a dummy group here to avoid crashing pyrex.vim.
   33              0.000272 syn keyword pythonInclude       import
   33              0.000263 syn keyword pythonImport        import
   33              0.000687 syn match pythonRaiseFromStatement      '\<from\>'
   33              0.000825 syn match pythonImport          '^\s*\zsfrom\>'
                            
                            
   33   0.003580   0.001141 if s:Python2Syntax()
                                if !s:Enabled('g:python_print_as_function')
                                    syn keyword pythonStatement  print
                                endif
                                syn keyword pythonStatement   exec
                                syn keyword pythonImport      as
                                syn match   pythonFunction    '[a-zA-Z_][a-zA-Z0-9_]*' display contained
   33              0.000242 else
   33              0.000398     syn keyword pythonStatement   as nonlocal
   33              0.000788     syn match   pythonStatement   '\v\.@<!<await>'
   33              0.001566     syn match   pythonFunction    '\%([^[:cntrl:][:space:][:punct:][:digit:]]\|_\)\%([^[:cntrl:][:punct:][:space:]]\|_\)*' display contained
   33              0.001052     syn match   pythonClass       '\%([^[:cntrl:][:space:][:punct:][:digit:]]\|_\)\%([^[:cntrl:][:punct:][:space:]]\|_\)*' display contained
   33              0.000905     syn match   pythonStatement   '\<async\s\+def\>' nextgroup=pythonFunction skipwhite
   33              0.002603     syn match   pythonStatement   '\<async\s\+with\>'
   33              0.000887     syn match   pythonStatement   '\<async\s\+for\>'
   33              0.003983     syn cluster pythonExpression contains=pythonStatement,pythonRepeat,pythonConditional,pythonOperator,pythonNumber,pythonHexNumber,pythonOctNumber,pythonBinNumber,pythonFloat,pythonString,pythonFString,pythonRawString,pythonRawFString,pythonBytes,pythonBoolean,pythonNone,pythonSingleton,pythonBuiltinObj,pythonBuiltinFunc,pythonBuiltinType,pythonClassVar
   33              0.000155 endif
                            
                            
                            "
                            " Operators
                            "
   33              0.000436 syn keyword pythonOperator      and in is not or
   33   0.002594   0.001364 if s:Enabled('g:python_highlight_operators')
                                syn match pythonOperator        '\V=\|-\|+\|*\|@\|/\|%\|&\||\|^\|~\|<\|>\|!=\|:='
   33              0.000308 endif
   33              0.002798 syn match pythonError           '[$?]\|\([-+@%&|^~]\)\1\{1,}\|\([=*/<>]\)\2\{2,}\|\([+@/%&|^~<>]\)\3\@![-+*@/%&|^~<>]\|\*\*[*@/%&|^<>]\|=[*@/%&|^<>]\|-[+*@/%&|^~<]\|[<!>]\+=\{2,}\|!\{2,}=\+' display
                            
                            "
                            " Decorators (new in Python 2.4)
                            "
                            
   33              0.000971 syn match   pythonDecorator    '^\s*\zs@' display nextgroup=pythonDottedName skipwhite
   33   0.003771   0.001171 if s:Python2Syntax()
                                syn match   pythonDottedName '[a-zA-Z_][a-zA-Z0-9_]*\%(\.[a-zA-Z_][a-zA-Z0-9_]*\)*' display contained
   33              0.000348 else
   33              0.002668     syn match   pythonDottedName '\%([^[:cntrl:][:space:][:punct:][:digit:]]\|_\)\%([^[:cntrl:][:punct:][:space:]]\|_\)*\%(\.\%([^[:cntrl:][:space:][:punct:][:digit:]]\|_\)\%([^[:cntrl:][:punct:][:space:]]\|_\)*\)*' display contained
   33              0.000208 endif
   33              0.000666 syn match   pythonDot        '\.' display containedin=pythonDottedName
                            
                            "
                            " Comments
                            "
                            
   33              0.001386 syn match   pythonComment       '#.*$' display contains=pythonTodo,@Spell
   33   0.002592   0.001447 if !s:Enabled('g:python_highlight_file_headers_as_comments')
                                syn match   pythonRun         '\%^#!.*$'
                                syn match   pythonCoding      '\%^.*\%(\n.*\)\?#.*coding[:=]\s*[0-9A-Za-z-_.]\+.*$'
   33              0.000228 endif
   33              0.000541 syn keyword pythonTodo          TODO FIXME XXX contained
                            
                            "
                            " Errors
                            "
                            
   33              0.001078 syn match pythonError           '\<\d\+[^0-9[:space:]]\+\>' display
                            
                            " Mixing spaces and tabs also may be used for pretty formatting multiline
                            " statements
   33   0.002201   0.001256 if s:Enabled('g:python_highlight_indent_errors')
   33              0.000875     syn match pythonIndentError   '^\s*\%( \t\|\t \)\s*\S'me=e-1 display
   33              0.000128 endif
                            
                            " Trailing space errors
   33   0.001769   0.000971 if s:Enabled('g:python_highlight_space_errors')
   33              0.000769     syn match pythonSpaceError    '\s\+$' display
   33              0.000115 endif
                            
                            "
                            " Strings
                            "
                            
   33   0.002991   0.000860 if s:Python2Syntax()
                                " Python 2 strings
                                syn region pythonString   start=+[bB]\='+ skip=+\\\\\|\\'\|\\$+ excludenl end=+'+ end=+$+ keepend contains=pythonBytesEscape,pythonBytesEscapeError,pythonUniEscape,pythonUniEscapeError,@Spell
                                syn region pythonString   start=+[bB]\="+ skip=+\\\\\|\\"\|\\$+ excludenl end=+"+ end=+$+ keepend contains=pythonBytesEscape,pythonBytesEscapeError,pythonUniEscape,pythonUniEscapeError,@Spell
                                syn region pythonString   start=+[bB]\="""+ skip=+\\"+ end=+"""+ keepend contains=pythonBytesEscape,pythonBytesEscapeError,pythonUniEscape,pythonUniEscapeError,pythonDocTest2,pythonSpaceError,@Spell
                                syn region pythonString   start=+[bB]\='''+ skip=+\\'+ end=+'''+ keepend contains=pythonBytesEscape,pythonBytesEscapeError,pythonUniEscape,pythonUniEscapeError,pythonDocTest,pythonSpaceError,@Spell
   33              0.000249 else
                                " Python 3 byte strings
   33              0.002413     syn region pythonBytes    start=+[bB]'+ skip=+\\\\\|\\'\|\\$+ excludenl end=+'+ end=+$+ keepend contains=pythonBytesError,pythonBytesContent,@Spell
   33              0.001585     syn region pythonBytes    start=+[bB]"+ skip=+\\\\\|\\"\|\\$+ excludenl end=+"+ end=+$+ keepend contains=pythonBytesError,pythonBytesContent,@Spell
   33              0.001976     syn region pythonBytes    start=+[bB]'''+ skip=+\\'+ end=+'''+ keepend contains=pythonBytesError,pythonBytesContent,pythonDocTest,pythonSpaceError,@Spell
   33              0.001506     syn region pythonBytes    start=+[bB]"""+ skip=+\\"+ end=+"""+ keepend contains=pythonBytesError,pythonBytesContent,pythonDocTest2,pythonSpaceError,@Spell
                            
   33              0.000546     syn match pythonBytesError    '.\+' display contained
   33              0.001146     syn match pythonBytesContent  '[\u0000-\u00ff]\+' display contained contains=pythonBytesEscape,pythonBytesEscapeError
   33              0.000148 endif
                            
   33              0.000624 syn match pythonBytesEscape       +\\[abfnrtv'"\\]+ display contained
   33              0.002371 syn match pythonBytesEscape       '\\\o\o\=\o\=' display contained
   33              0.000783 syn match pythonBytesEscapeError  '\\\o\{,2}[89]' display contained
   33              0.000593 syn match pythonBytesEscape       '\\x\x\{2}' display contained
   33              0.000757 syn match pythonBytesEscapeError  '\\x\x\=\X' display contained
   33              0.000466 syn match pythonBytesEscape       '\\$'
                            
   33              0.000548 syn match pythonUniEscape         '\\u\x\{4}' display contained
   33              0.000692 syn match pythonUniEscapeError    '\\u\x\{,3}\X' display contained
   33              0.000554 syn match pythonUniEscape         '\\U\x\{8}' display contained
   33              0.000638 syn match pythonUniEscapeError    '\\U\x\{,7}\X' display contained
   33              0.000713 syn match pythonUniEscape         '\\N{[A-Z ]\+}' display contained
   33              0.000561 syn match pythonUniEscapeError    '\\N{[^A-Z ]\+}' display contained
                            
   33   0.004219   0.001427 if s:Python2Syntax()
                                " Python 2 Unicode strings
                                syn region pythonUniString  start=+[uU]'+ skip=+\\\\\|\\'\|\\$+ excludenl end=+'+ end=+$+ keepend contains=pythonBytesEscape,pythonBytesEscapeError,pythonUniEscape,pythonUniEscapeError,@Spell
                                syn region pythonUniString  start=+[uU]"+ skip=+\\\\\|\\"\|\\$+ excludenl end=+"+ end=+$+ keepend contains=pythonBytesEscape,pythonBytesEscapeError,pythonUniEscape,pythonUniEscapeError,@Spell
                                syn region pythonUniString  start=+[uU]'''+ skip=+\\'+ end=+'''+ keepend contains=pythonBytesEscape,pythonBytesEscapeError,pythonUniEscape,pythonUniEscapeError,pythonDocTest,pythonSpaceError,@Spell
                                syn region pythonUniString  start=+[uU]"""+ skip=+\\"+ end=+"""+ keepend contains=pythonBytesEscape,pythonBytesEscapeError,pythonUniEscape,pythonUniEscapeError,pythonDocTest2,pythonSpaceError,@Spell
   33              0.000219 else
                                " Python 3 strings
   33              0.002060     syn region pythonString   start=+'+ skip=+\\\\\|\\'\|\\$+ excludenl end=+'+ end=+$+ keepend contains=pythonBytesEscape,pythonBytesEscapeError,pythonUniEscape,pythonUniEscapeError,@Spell
   33              0.002042     syn region pythonString   start=+"+ skip=+\\\\\|\\"\|\\$+ excludenl end=+"+ end=+$+ keepend contains=pythonBytesEscape,pythonBytesEscapeError,pythonUniEscape,pythonUniEscapeError,@Spell
   33              0.002213     syn region pythonString   start=+'''+ skip=+\\'+ end=+'''+ keepend contains=pythonBytesEscape,pythonBytesEscapeError,pythonUniEscape,pythonUniEscapeError,pythonDocTest,pythonSpaceError,@Spell
   33              0.001658     syn region pythonString   start=+"""+ skip=+\\"+ end=+"""+ keepend contains=pythonBytesEscape,pythonBytesEscapeError,pythonUniEscape,pythonUniEscapeError,pythonDocTest2,pythonSpaceError,@Spell
                            
   33              0.001916     syn region pythonFString   start=+[fF]'+ skip=+\\\\\|\\'\|\\$+ excludenl end=+'+ end=+$+ keepend contains=pythonBytesEscape,pythonBytesEscapeError,pythonUniEscape,pythonUniEscapeError,@Spell
   33              0.001825     syn region pythonFString   start=+[fF]"+ skip=+\\\\\|\\"\|\\$+ excludenl end=+"+ end=+$+ keepend contains=pythonBytesEscape,pythonBytesEscapeError,pythonUniEscape,pythonUniEscapeError,@Spell
   33              0.001962     syn region pythonFString   start=+[fF]'''+ skip=+\\'+ end=+'''+ keepend contains=pythonBytesEscape,pythonBytesEscapeError,pythonUniEscape,pythonUniEscapeError,pythonDocTest,pythonSpaceError,@Spell
   33              0.001804     syn region pythonFString   start=+[fF]"""+ skip=+\\"+ end=+"""+ keepend contains=pythonBytesEscape,pythonBytesEscapeError,pythonUniEscape,pythonUniEscapeError,pythonDocTest2,pythonSpaceError,@Spell
   33              0.000144 endif
                            
   33   0.004162   0.001322 if s:Python2Syntax()
                                " Python 2 Unicode raw strings
                                syn region pythonUniRawString start=+[uU][rR]'+ skip=+\\\\\|\\'\|\\$+ excludenl end=+'+ end=+$+ keepend contains=pythonRawEscape,pythonUniRawEscape,pythonUniRawEscapeError,@Spell
                                syn region pythonUniRawString start=+[uU][rR]"+ skip=+\\\\\|\\"\|\\$+ excludenl end=+"+ end=+$+ keepend contains=pythonRawEscape,pythonUniRawEscape,pythonUniRawEscapeError,@Spell
                                syn region pythonUniRawString start=+[uU][rR]'''+ skip=+\\'+ end=+'''+ keepend contains=pythonUniRawEscape,pythonUniRawEscapeError,pythonDocTest,pythonSpaceError,@Spell
                                syn region pythonUniRawString start=+[uU][rR]"""+ skip=+\\"+ end=+"""+ keepend contains=pythonUniRawEscape,pythonUniRawEscapeError,pythonDocTest2,pythonSpaceError,@Spell
                            
                                syn match  pythonUniRawEscape       '\%([^\\]\%(\\\\\)*\)\@<=\\u\x\{4}' display contained
                                syn match  pythonUniRawEscapeError  '\%([^\\]\%(\\\\\)*\)\@<=\\u\x\{,3}\X' display contained
   33              0.000193 endif
                            
                            " Python 2/3 raw strings
   33   0.003736   0.001368 if s:Python2Syntax()
                                syn region pythonRawString  start=+[bB]\=[rR]'+ skip=+\\\\\|\\'\|\\$+ excludenl end=+'+ end=+$+ keepend contains=pythonRawEscape,@Spell
                                syn region pythonRawString  start=+[bB]\=[rR]"+ skip=+\\\\\|\\"\|\\$+ excludenl end=+"+ end=+$+ keepend contains=pythonRawEscape,@Spell
                                syn region pythonRawString  start=+[bB]\=[rR]'''+ skip=+\\'+ end=+'''+ keepend contains=pythonDocTest,pythonSpaceError,@Spell
                                syn region pythonRawString  start=+[bB]\=[rR]"""+ skip=+\\"+ end=+"""+ keepend contains=pythonDocTest2,pythonSpaceError,@Spell
   33              0.000254 else
   33              0.001652     syn region pythonRawString  start=+[rR]'+ skip=+\\\\\|\\'\|\\$+ excludenl end=+'+ end=+$+ keepend contains=pythonRawEscape,@Spell
   33              0.001930     syn region pythonRawString  start=+[rR]"+ skip=+\\\\\|\\"\|\\$+ excludenl end=+"+ end=+$+ keepend contains=pythonRawEscape,@Spell
   33              0.001360     syn region pythonRawString  start=+[rR]'''+ skip=+\\'+ end=+'''+ keepend contains=pythonDocTest,pythonSpaceError,@Spell
   33              0.001034     syn region pythonRawString  start=+[rR]"""+ skip=+\\"+ end=+"""+ keepend contains=pythonDocTest2,pythonSpaceError,@Spell
                            
   33              0.001815     syn region pythonRawFString   start=+\%([fF][rR]\|[rR][fF]\)'+ skip=+\\\\\|\\'\|\\$+ excludenl end=+'+ end=+$+ keepend contains=pythonRawEscape,@Spell
   33              0.001986     syn region pythonRawFString   start=+\%([fF][rR]\|[rR][fF]\)"+ skip=+\\\\\|\\"\|\\$+ excludenl end=+"+ end=+$+ keepend contains=pythonRawEscape,@Spell
   33              0.001632     syn region pythonRawFString   start=+\%([fF][rR]\|[rR][fF]\)'''+ skip=+\\'+ end=+'''+ keepend contains=pythonDocTest,pythonSpaceError,@Spell
   33              0.001366     syn region pythonRawFString   start=+\%([fF][rR]\|[rR][fF]\)"""+ skip=+\\"+ end=+"""+ keepend contains=pythonDocTest,pythonSpaceError,@Spell
                            
   33              0.001701     syn region pythonRawBytes  start=+\%([bB][rR]\|[rR][bB]\)'+ skip=+\\\\\|\\'\|\\$+ excludenl end=+'+ end=+$+ keepend contains=pythonRawEscape,@Spell
   33              0.001416     syn region pythonRawBytes  start=+\%([bB][rR]\|[rR][bB]\)"+ skip=+\\\\\|\\"\|\\$+ excludenl end=+"+ end=+$+ keepend contains=pythonRawEscape,@Spell
   33              0.001486     syn region pythonRawBytes  start=+\%([bB][rR]\|[rR][bB]\)'''+ skip=+\\'+ end=+'''+ keepend contains=pythonDocTest,pythonSpaceError,@Spell
   33              0.001875     syn region pythonRawBytes  start=+\%([bB][rR]\|[rR][bB]\)"""+ skip=+\\"+ end=+"""+ keepend contains=pythonDocTest2,pythonSpaceError,@Spell
   33              0.000144 endif
                            
   33              0.000846 syn match pythonRawEscape +\\['"]+ display contained
                            
   33   0.002713   0.001391 if s:Enabled('g:python_highlight_string_formatting')
                                " % operator string formatting
   33   0.002880   0.000921     if s:Python2Syntax()
                                    syn match pythonStrFormatting '%\%(([^)]\+)\)\=[-#0 +]*\d*\%(\.\d\+\)\=[hlL]\=[diouxXeEfFgGcrs%]' contained containedin=pythonString,pythonUniString,pythonUniRawString,pythonRawString,pythonBytesContent
                                    syn match pythonStrFormatting '%[-#0 +]*\%(\*\|\d\+\)\=\%(\.\%(\*\|\d\+\)\)\=[hlL]\=[diouxXeEfFgGcrs%]' contained containedin=pythonString,pythonUniString,pythonUniRawString,pythonRawString,pythonBytesContent
   33              0.000306     else
   33              0.001853         syn match pythonStrFormatting '%\%(([^)]\+)\)\=[-#0 +]*\d*\%(\.\d\+\)\=[hlL]\=[diouxXeEfFgGcrs%]' contained containedin=pythonString,pythonRawString,pythonBytesContent
   33              0.001247         syn match pythonStrFormatting '%[-#0 +]*\%(\*\|\d\+\)\=\%(\.\%(\*\|\d\+\)\)\=[hlL]\=[diouxXeEfFgGcrs%]' contained containedin=pythonString,pythonRawString,pythonBytesContent
   33              0.000118     endif
   33              0.000088 endif
                            
   33   0.002022   0.001108 if s:Enabled('g:python_highlight_string_format')
                                " str.format syntax
   33   0.003153   0.001050     if s:Python2Syntax()
                                    syn match pythonStrFormat '{{\|}}' contained containedin=pythonString,pythonUniString,pythonUniRawString,pythonRawString
                                    syn match pythonStrFormat '{\%(\%([^[:cntrl:][:space:][:punct:][:digit:]]\|_\)\%([^[:cntrl:][:punct:][:space:]]\|_\)*\|\d\+\)\=\%(\.\%([^[:cntrl:][:space:][:punct:][:digit:]]\|_\)\%([^[:cntrl:][:punct:][:space:]]\|_\)*\|\[\%(\d\+\|[^!:\}]\+\)\]\)*\%(![rsa]\)\=\%(:\%({\%(\%([^[:cntrl:][:space:][:punct:][:digit:]]\|_\)\%([^[:cntrl:][:punct:][:space:]]\|_\)*\|\d\+\)}\|\%([^}]\=[<>=^]\)\=[ +-]\=#\=0\=\d*,\=\%(\.\d\+\)\=[bcdeEfFgGnosxX%]\=\)\=\)\=}' contained containedin=pythonString,pythonUniString,pythonUniRawString,pythonRawString
   33              0.001982     else
   33              0.003562         syn match pythonStrFormat "{\%(\%([^[:cntrl:][:space:][:punct:][:digit:]]\|_\)\%([^[:cntrl:][:punct:][:space:]]\|_\)*\|\d\+\)\=\%(\.\%([^[:cntrl:][:space:][:punct:][:digit:]]\|_\)\%([^[:cntrl:][:punct:][:space:]]\|_\)*\|\[\%(\d\+\|[^!:\}]\+\)\]\)*\%(![rsa]\)\=\%(:\%({\%(\%([^[:cntrl:][:space:][:punct:][:digit:]]\|_\)\%([^[:cntrl:][:punct:][:space:]]\|_\)*\|\d\+\)}\|\%([^}]\=[<>=^]\)\=[ +-]\=#\=0\=\d*,\=\%(\.\d\+\)\=[bcdeEfFgGnosxX%]\=\)\=\)\=}" contained containedin=pythonString,pythonRawString
   33              0.003556         syn region pythonStrInterpRegion matchgroup=pythonStrFormat start="{" end="\%(![rsa]\)\=\%(:\%({\%(\%([^[:cntrl:][:space:][:punct:][:digit:]]\|_\)\%([^[:cntrl:][:punct:][:space:]]\|_\)*\|\d\+\)}\|\%([^}]\=[<>=^]\)\=[ +-]\=#\=0\=\d*,\=\%(\.\d\+\)\=[bcdeEfFgGnosxX%]\=\)\=\)\=}" extend contained containedin=pythonFString,pythonRawFString contains=pythonStrInterpRegion,@pythonExpression
   33              0.000790         syn match pythonStrFormat "{{\|}}" contained containedin=pythonFString,pythonRawFString
   33              0.000120     endif
   33              0.000128 endif
                            
   33   0.002360   0.001215 if s:Enabled('g:python_highlight_string_templates')
                                " string.Template format
   33   0.002909   0.000916     if s:Python2Syntax()
                                    syn match pythonStrTemplate '\$\$' contained containedin=pythonString,pythonUniString,pythonUniRawString,pythonRawString
                                    syn match pythonStrTemplate '\${[a-zA-Z_][a-zA-Z0-9_]*}' contained containedin=pythonString,pythonUniString,pythonUniRawString,pythonRawString
                                    syn match pythonStrTemplate '\$[a-zA-Z_][a-zA-Z0-9_]*' contained containedin=pythonString,pythonUniString,pythonUniRawString,pythonRawString
   33              0.000340     else
   33              0.000822         syn match pythonStrTemplate '\$\$' contained containedin=pythonString,pythonRawString
   33              0.000767         syn match pythonStrTemplate '\${[a-zA-Z_][a-zA-Z0-9_]*}' contained containedin=pythonString,pythonRawString
   33              0.000582         syn match pythonStrTemplate '\$[a-zA-Z_][a-zA-Z0-9_]*' contained containedin=pythonString,pythonRawString
   33              0.000106     endif
   33              0.000087 endif
                            
   33   0.001920   0.001031 if s:Enabled('g:python_highlight_doctests')
                                " DocTests
   33              0.001729     syn region pythonDocTest   start='^\s*>>>' skip=+\\'+ end=+'''+he=s-1 end='^\s*$' contained
   33              0.001176     syn region pythonDocTest2  start='^\s*>>>' skip=+\\"+ end=+"""+he=s-1 end='^\s*$' contained
   33              0.000112 endif
                            
                            "
                            " Numbers (ints, longs, floats, complex)
                            "
                            
   33   0.002966   0.000890 if s:Python2Syntax()
                                syn match   pythonHexError    '\<0[xX]\x*[g-zG-Z]\+\x*[lL]\=\>' display
                                syn match   pythonOctError    '\<0[oO]\=\o*\D\+\d*[lL]\=\>' display
                                syn match   pythonBinError    '\<0[bB][01]*\D\+\d*[lL]\=\>' display
                            
                                syn match   pythonHexNumber   '\<0[xX]\x\+[lL]\=\>' display
                                syn match   pythonOctNumber   '\<0[oO]\o\+[lL]\=\>' display
                                syn match   pythonBinNumber   '\<0[bB][01]\+[lL]\=\>' display
                            
                                syn match   pythonNumberError '\<\d\+\D[lL]\=\>' display
                                syn match   pythonNumber      '\<\d[lL]\=\>' display
                                syn match   pythonNumber      '\<[0-9]\d\+[lL]\=\>' display
                                syn match   pythonNumber      '\<\d\+[lLjJ]\>' display
                            
                                syn match   pythonOctError    '\<0[oO]\=\o*[8-9]\d*[lL]\=\>' display
                                syn match   pythonBinError    '\<0[bB][01]*[2-9]\d*[lL]\=\>' display
                            
                                syn match   pythonFloat       '\.\d\+\%([eE][+-]\=\d\+\)\=[jJ]\=\>' display
                                syn match   pythonFloat       '\<\d\+[eE][+-]\=\d\+[jJ]\=\>' display
                                syn match   pythonFloat       '\<\d\+\.\d*\%([eE][+-]\=\d\+\)\=[jJ]\=' display
   33              0.000230 else
   33              0.000839     syn match   pythonOctError    '\<0[oO]\=\o*\D\+\d*\>' display
                                " pythonHexError comes after pythonOctError so that 0xffffl is pythonHexError
   33              0.000751     syn match   pythonHexError    '\<0[xX]\x*[g-zG-Z]\x*\>' display
   33              0.000522     syn match   pythonBinError    '\<0[bB][01]*\D\+\d*\>' display
                            
   33              0.000727     syn match   pythonHexNumber   '\<0[xX][_0-9a-fA-F]*\x\>' display
   33              0.000621     syn match   pythonOctNumber   '\<0[oO][_0-7]*\o\>' display
   33              0.000531     syn match   pythonBinNumber   '\<0[bB][_01]*[01]\>' display
                            
   33              0.000560     syn match   pythonNumberError '\<\d[_0-9]*\D\>' display
   33              0.000523     syn match   pythonNumberError '\<0[_0-9]\+\>' display
   33              0.000585     syn match   pythonNumberError '\<0_x\S*\>' display
   33              0.000688     syn match   pythonNumberError '\<0[bBxXoO][_0-9a-fA-F]*_\>' display
   33              0.002002     syn match   pythonNumberError '\<\d[_0-9]*_\>' display
   33              0.000460     syn match   pythonNumber      '\<\d\>' display
   33              0.000559     syn match   pythonNumber      '\<[1-9][_0-9]*\d\>' display
   33              0.000506     syn match   pythonNumber      '\<\d[jJ]\>' display
   33              0.000607     syn match   pythonNumber      '\<[1-9][_0-9]*\d[jJ]\>' display
                            
   33              0.000633     syn match   pythonOctError    '\<0[oO]\=\o*[8-9]\d*\>' display
   33              0.000514     syn match   pythonBinError    '\<0[bB][01]*[2-9]\d*\>' display
                            
   33              0.001156     syn match   pythonFloat       '\.\d\%([_0-9]*\d\)\=\%([eE][+-]\=\d\%([_0-9]*\d\)\=\)\=[jJ]\=\>' display
   33              0.000961     syn match   pythonFloat       '\<\d\%([_0-9]*\d\)\=[eE][+-]\=\d\%([_0-9]*\d\)\=[jJ]\=\>' display
   33              0.001136     syn match   pythonFloat       '\<\d\%([_0-9]*\d\)\=\.\d\=\%([_0-9]*\d\)\=\%([eE][+-]\=\d\%([_0-9]*\d\)\=\)\=[jJ]\=' display
   33              0.000128 endif
                            
                            "
                            " Builtin objects
                            "
                            
   33   0.002678   0.001525 if s:Enabled('g:python_highlight_builtin_objs')
   33              0.000477     syn keyword pythonNone        None
   33              0.000348     syn keyword pythonBoolean     True False
   33              0.000365     syn keyword pythonSingleton   Ellipsis NotImplemented
   33              0.000412     syn keyword pythonBuiltinObj  __debug__ __doc__ __file__ __name__ __package__
   33              0.000830     syn keyword pythonBuiltinObj  __loader__ __spec__ __path__ __cached__
   33              0.000102 endif
                            
                            "
                            " Builtin functions
                            "
                            
   33   0.001936   0.001150 if s:Enabled('g:python_highlight_builtin_funcs')
   33              0.001074     let s:funcs_re = '__import__|abs|all|any|bin|callable|chr|classmethod|compile|complex|delattr|dir|divmod|enumerate|eval|filter|format|getattr|globals|hasattr|hash|help|hex|id|input|isinstance|issubclass|iter|len|locals|map|max|memoryview|min|next|oct|open|ord|pow|property|range|repr|reversed|round|setattr|slice|sorted|staticmethod|sum|super|type|vars|zip'
                            
   33   0.003234   0.000862     if s:Python2Syntax()
                                    let s:funcs_re .= '|apply|basestring|buffer|cmp|coerce|execfile|file|intern|long|raw_input|reduce|reload|unichr|unicode|xrange'
                                    if s:Enabled('g:python_print_as_function')
                                        let s:funcs_re .= '|print'
                                    endif
   33              0.000143     else
   33              0.000612         let s:funcs_re .= '|ascii|breakpoint|exec|print'
   33              0.000098     endif
                            
   33              0.000685     let s:funcs_re = 'syn match pythonBuiltinFunc ''\v\.@<!\zs<%(' . s:funcs_re . ')>'
                            
   33   0.001677   0.000860     if !s:Enabled('g:python_highlight_builtin_funcs_kwarg')
                                    let s:funcs_re .= '\=@!'
   33              0.000098     endif
                            
   33              0.005686     execute s:funcs_re . ''''
   33              0.000361     unlet s:funcs_re
   33              0.000112 endif
                            
                            "
                            " Builtin types
                            "
                            
   33   0.001767   0.000944 if s:Enabled('g:python_highlight_builtin_types')
   33              0.001477     syn match pythonBuiltinType    '\v\.@<!<%(object|bool|int|float|tuple|str|list|dict|set|frozenset|bytearray|bytes)>'
   33              0.000110 endif
                            
                            
                            "
                            " Builtin exceptions and warnings
                            "
                            
   33   0.001995   0.001297 if s:Enabled('g:python_highlight_exceptions')
                                let s:exs_re = 'BaseException|Exception|ArithmeticError|LookupError|EnvironmentError|AssertionError|AttributeError|BufferError|EOFError|FloatingPointError|GeneratorExit|IOError|ImportError|IndexError|KeyError|KeyboardInterrupt|MemoryError|NameError|NotImplementedError|OSError|OverflowError|ReferenceError|RuntimeError|StopIteration|SyntaxError|IndentationError|TabError|SystemError|SystemExit|TypeError|UnboundLocalError|UnicodeError|UnicodeEncodeError|UnicodeDecodeError|UnicodeTranslateError|ValueError|VMSError|WindowsError|ZeroDivisionError|Warning|UserWarning|BytesWarning|DeprecationWarning|PendingDeprecationWarning|SyntaxWarning|RuntimeWarning|FutureWarning|ImportWarning|UnicodeWarning'
                            
                                if s:Python2Syntax()
                                    let s:exs_re .= '|StandardError'
                                else
                                    let s:exs_re .= '|BlockingIOError|ChildProcessError|ConnectionError|BrokenPipeError|ConnectionAbortedError|ConnectionRefusedError|ConnectionResetError|FileExistsError|FileNotFoundError|InterruptedError|IsADirectoryError|NotADirectoryError|PermissionError|ProcessLookupError|TimeoutError|StopAsyncIteration|ResourceWarning'
                                endif
                            
                                execute 'syn match pythonExClass ''\v\.@<!\zs<%(' . s:exs_re . ')>'''
                                unlet s:exs_re
   33              0.000108 endif
                            
                            "
                            " Misc
                            "
                            
   33   0.001587   0.000935 if s:Enabled('g:python_slow_sync')
   33              0.000351     syn sync minlines=2000
                            else
                                " This is fast but code inside triple quoted strings screws it up. It
                                " is impossible to fix because the only way to know if you are inside a
                                " triple quoted string is to start from the beginning of the file.
                                syn sync match pythonSync grouphere NONE '):$'
                                syn sync maxlines=200
   33              0.000099 endif
                            
   33              0.000644 if v:version >= 508 || !exists('did_python_syn_inits')
   33              0.000235     if v:version <= 508
                                    let did_python_syn_inits = 1
                                    command -nargs=+ HiLink hi link <args>
   33              0.000129     else
   33              0.001652         command -nargs=+ HiLink hi def link <args>
   33              0.000109     endif
                            
   33              0.001031     HiLink pythonStatement        Statement
   33              0.000725     HiLink pythonRaiseFromStatement   Statement
   33              0.000616     HiLink pythonImport           Include
   33              0.000594     HiLink pythonFunction         Function
   33              0.000530     HiLink pythonFunctionCall     Function
   33              0.000560     HiLink pythonConditional      Conditional
   33              0.000554     HiLink pythonRepeat           Repeat
   33              0.000540     HiLink pythonException        Exception
   33              0.000498     HiLink pythonOperator         Operator
                            
   33              0.000526     HiLink pythonDecorator        Define
   33              0.000515     HiLink pythonDottedName       Function
                            
   33              0.000552     HiLink pythonComment          Comment
   33   0.002221   0.001205     if !s:Enabled('g:python_highlight_file_headers_as_comments')
                                    HiLink pythonCoding           Special
                                    HiLink pythonRun              Special
   33              0.000133     endif
   33              0.000592     HiLink pythonTodo             Todo
                            
   33              0.000532     HiLink pythonError            Error
   33              0.000512     HiLink pythonIndentError      Error
   33              0.000480     HiLink pythonSpaceError       Error
                            
   33              0.000536     HiLink pythonString           String
   33              0.000503     HiLink pythonRawString        String
   33              0.000517     HiLink pythonRawEscape        Special
                            
   33              0.000531     HiLink pythonUniEscape        Special
   33              0.000489     HiLink pythonUniEscapeError   Error
                            
   33   0.003158   0.000911     if s:Python2Syntax()
                                    HiLink pythonUniString          String
                                    HiLink pythonUniRawString       String
                                    HiLink pythonUniRawEscape       Special
                                    HiLink pythonUniRawEscapeError  Error
   33              0.000132     else
   33              0.000587         HiLink pythonBytes              String
   33              0.000516         HiLink pythonRawBytes           String
   33              0.000510         HiLink pythonBytesContent       String
   33              0.000499         HiLink pythonBytesError         Error
   33              0.000510         HiLink pythonBytesEscape        Special
   33              0.000517         HiLink pythonBytesEscapeError   Error
   33              0.000504         HiLink pythonFString            String
   33              0.000486         HiLink pythonRawFString         String
   33              0.000094     endif
                            
   33              0.000496     HiLink pythonStrFormatting    Special
   33              0.000514     HiLink pythonStrFormat        Special
   33              0.000484     HiLink pythonStrTemplate      Special
                            
   33              0.000482     HiLink pythonDocTest          Special
   33              0.000479     HiLink pythonDocTest2         Special
                            
   33              0.000516     HiLink pythonNumber           Number
   33              0.000516     HiLink pythonHexNumber        Number
   33              0.000470     HiLink pythonOctNumber        Number
   33              0.000555     HiLink pythonBinNumber        Number
   33              0.000507     HiLink pythonFloat            Float
   33              0.000503     HiLink pythonNumberError      Error
   33              0.000479     HiLink pythonOctError         Error
   33              0.000509     HiLink pythonHexError         Error
   33              0.000451     HiLink pythonBinError         Error
                            
   33              0.000523     HiLink pythonBoolean          Boolean
   33              0.000540     HiLink pythonNone             Constant
   33              0.000494     HiLink pythonSingleton        Constant
                            
   33              0.000578     HiLink pythonBuiltinObj       Identifier
   33              0.000522     HiLink pythonBuiltinFunc      Function
   33              0.000492     HiLink pythonBuiltinType      Structure
                            
   33              0.000523     HiLink pythonExClass          Structure
   33              0.000490     HiLink pythonClass            Structure
   33              0.000499     HiLink pythonClassVar         Identifier
                            
   33              0.000244     delcommand HiLink
   33              0.000094 endif
                            
   33              0.002025 let b:current_syntax = 'python'

SCRIPT  C:\Users\Lenovo\scoop\apps\neovim\0.6.1\share\nvim\runtime\syntax\python.vim
Sourced 33 times
Total time:   0.006422
 Self time:   0.006422

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:	Python
                            " Maintainer:	Zvezdan Petkovic <zpetkovic@acm.org>
                            " Last Change:	2021 Feb 15
                            " Credits:	Neil Schemenauer <nas@python.ca>
                            "		Dmitry Vasiliev
                            "
                            "		This version is a major rewrite by Zvezdan Petkovic.
                            "
                            "		- introduced highlighting of doctests
                            "		- updated keywords, built-ins, and exceptions
                            "		- corrected regular expressions for
                            "
                            "		  * functions
                            "		  * decorators
                            "		  * strings
                            "		  * escapes
                            "		  * numbers
                            "		  * space error
                            "
                            "		- corrected synchronization
                            "		- more highlighting is ON by default, except
                            "		- space error highlighting is OFF by default
                            "
                            " Optional highlighting can be controlled using these variables.
                            "
                            "   let python_no_builtin_highlight = 1
                            "   let python_no_doctest_code_highlight = 1
                            "   let python_no_doctest_highlight = 1
                            "   let python_no_exception_highlight = 1
                            "   let python_no_number_highlight = 1
                            "   let python_space_error_highlight = 1
                            "
                            " All the options above can be switched on together.
                            "
                            "   let python_highlight_all = 1
                            "
                            
                            " quit when a syntax file was already loaded.
   33              0.001075 if exists("b:current_syntax")
   33              0.000237   finish
                            endif
                            
                            " We need nocompatible mode in order to continue lines with backslashes.
                            " Original setting will be restored.
                            let s:cpo_save = &cpo
                            set cpo&vim
                            
                            if exists("python_no_doctest_highlight")
                              let python_no_doctest_code_highlight = 1
                            endif
                            
                            if exists("python_highlight_all")
                              if exists("python_no_builtin_highlight")
                                unlet python_no_builtin_highlight
                              endif
                              if exists("python_no_doctest_code_highlight")
                                unlet python_no_doctest_code_highlight
                              endif
                              if exists("python_no_doctest_highlight")
                                unlet python_no_doctest_highlight
                              endif
                              if exists("python_no_exception_highlight")
                                unlet python_no_exception_highlight
                              endif
                              if exists("python_no_number_highlight")
                                unlet python_no_number_highlight
                              endif
                              let python_space_error_highlight = 1
                            endif
                            
                            " Keep Python keywords in alphabetical order inside groups for easy
                            " comparison with the table in the 'Python Language Reference'
                            " https://docs.python.org/reference/lexical_analysis.html#keywords.
                            " Groups are in the order presented in NAMING CONVENTIONS in syntax.txt.
                            " Exceptions come last at the end of each group (class and def below).
                            "
                            " The list can be checked using:
                            "
                            " python3 -c 'import keyword, pprint; pprint.pprint(keyword.kwlist, compact=True)'
                            "
                            syn keyword pythonStatement	False None True
                            syn keyword pythonStatement	as assert break continue del global
                            syn keyword pythonStatement	lambda nonlocal pass return with yield
                            syn keyword pythonStatement	class def nextgroup=pythonFunction skipwhite
                            syn keyword pythonConditional	elif else if
                            syn keyword pythonRepeat	for while
                            syn keyword pythonOperator	and in is not or
                            syn keyword pythonException	except finally raise try
                            syn keyword pythonInclude	from import
                            syn keyword pythonAsync		async await
                            
                            " Decorators
                            " A dot must be allowed because of @MyClass.myfunc decorators.
                            syn match   pythonDecorator	"@" display contained
                            syn match   pythonDecoratorName	"@\s*\h\%(\w\|\.\)*" display contains=pythonDecorator
                            
                            " Python 3.5 introduced the use of the same symbol for matrix multiplication:
                            " https://www.python.org/dev/peps/pep-0465/.  We now have to exclude the
                            " symbol from highlighting when used in that context.
                            " Single line multiplication.
                            syn match   pythonMatrixMultiply
                                  \ "\%(\w\|[])]\)\s*@"
                                  \ contains=ALLBUT,pythonDecoratorName,pythonDecorator,pythonFunction,pythonDoctestValue
                                  \ transparent
                            " Multiplication continued on the next line after backslash.
                            syn match   pythonMatrixMultiply
                                  \ "[^\\]\\\s*\n\%(\s*\.\.\.\s\)\=\s\+@"
                                  \ contains=ALLBUT,pythonDecoratorName,pythonDecorator,pythonFunction,pythonDoctestValue
                                  \ transparent
                            " Multiplication in a parenthesized expression over multiple lines with @ at
                            " the start of each continued line; very similar to decorators and complex.
                            syn match   pythonMatrixMultiply
                                  \ "^\s*\%(\%(>>>\|\.\.\.\)\s\+\)\=\zs\%(\h\|\%(\h\|[[(]\).\{-}\%(\w\|[])]\)\)\s*\n\%(\s*\.\.\.\s\)\=\s\+@\%(.\{-}\n\%(\s*\.\.\.\s\)\=\s\+@\)*"
                                  \ contains=ALLBUT,pythonDecoratorName,pythonDecorator,pythonFunction,pythonDoctestValue
                                  \ transparent
                            
                            syn match   pythonFunction	"\h\w*" display contained
                            
                            syn match   pythonComment	"#.*$" contains=pythonTodo,@Spell
                            syn keyword pythonTodo		FIXME NOTE NOTES TODO XXX contained
                            
                            " Triple-quoted strings can contain doctests.
                            syn region  pythonString matchgroup=pythonQuotes
                                  \ start=+[uU]\=\z(['"]\)+ end="\z1" skip="\\\\\|\\\z1"
                                  \ contains=pythonEscape,@Spell
                            syn region  pythonString matchgroup=pythonTripleQuotes
                                  \ start=+[uU]\=\z('''\|"""\)+ skip=+\\["']+ end="\z1" keepend
                                  \ contains=pythonEscape,pythonSpaceError,pythonDoctest,@Spell
                            syn region  pythonRawString matchgroup=pythonQuotes
                                  \ start=+[uU]\=[rR]\z(['"]\)+ end="\z1" skip="\\\\\|\\\z1"
                                  \ contains=@Spell
                            syn region  pythonRawString matchgroup=pythonTripleQuotes
                                  \ start=+[uU]\=[rR]\z('''\|"""\)+ end="\z1" keepend
                                  \ contains=pythonSpaceError,pythonDoctest,@Spell
                            
                            syn match   pythonEscape	+\\[abfnrtv'"\\]+ contained
                            syn match   pythonEscape	"\\\o\{1,3}" contained
                            syn match   pythonEscape	"\\x\x\{2}" contained
                            syn match   pythonEscape	"\%(\\u\x\{4}\|\\U\x\{8}\)" contained
                            " Python allows case-insensitive Unicode IDs: http://www.unicode.org/charts/
                            syn match   pythonEscape	"\\N{\a\+\%(\s\a\+\)*}" contained
                            syn match   pythonEscape	"\\$"
                            
                            " It is very important to understand all details before changing the
                            " regular expressions below or their order.
                            " The word boundaries are *not* the floating-point number boundaries
                            " because of a possible leading or trailing decimal point.
                            " The expressions below ensure that all valid number literals are
                            " highlighted, and invalid number literals are not.  For example,
                            "
                            " - a decimal point in '4.' at the end of a line is highlighted,
                            " - a second dot in 1.0.0 is not highlighted,
                            " - 08 is not highlighted,
                            " - 08e0 or 08j are highlighted,
                            "
                            " and so on, as specified in the 'Python Language Reference'.
                            " https://docs.python.org/reference/lexical_analysis.html#numeric-literals
                            if !exists("python_no_number_highlight")
                              " numbers (including longs and complex)
                              syn match   pythonNumber	"\<0[oO]\=\o\+[Ll]\=\>"
                              syn match   pythonNumber	"\<0[xX]\x\+[Ll]\=\>"
                              syn match   pythonNumber	"\<0[bB][01]\+[Ll]\=\>"
                              syn match   pythonNumber	"\<\%([1-9]\d*\|0\)[Ll]\=\>"
                              syn match   pythonNumber	"\<\d\+[jJ]\>"
                              syn match   pythonNumber	"\<\d\+[eE][+-]\=\d\+[jJ]\=\>"
                              syn match   pythonNumber
                            	\ "\<\d\+\.\%([eE][+-]\=\d\+\)\=[jJ]\=\%(\W\|$\)\@="
                              syn match   pythonNumber
                            	\ "\%(^\|\W\)\zs\d*\.\d\+\%([eE][+-]\=\d\+\)\=[jJ]\=\>"
                            endif
                            
                            " Group the built-ins in the order in the 'Python Library Reference' for
                            " easier comparison.
                            " https://docs.python.org/library/constants.html
                            " http://docs.python.org/library/functions.html
                            " Python built-in functions are in alphabetical order.
                            "
                            " The list can be checked using:
                            "
                            " python3 -c 'import builtins, pprint; pprint.pprint(dir(builtins), compact=True)'
                            "
                            " The constants added by the `site` module are not listed below because they
                            " should not be used in programs, only in interactive interpreter.
                            " Similarly for some other attributes and functions `__`-enclosed from the
                            " output of the above command.
                            "
                            if !exists("python_no_builtin_highlight")
                              " built-in constants
                              " 'False', 'True', and 'None' are also reserved words in Python 3
                              syn keyword pythonBuiltin	False True None
                              syn keyword pythonBuiltin	NotImplemented Ellipsis __debug__
                              " constants added by the `site` module
                              syn keyword pythonBuiltin	quit exit copyright credits license
                              " built-in functions
                              syn keyword pythonBuiltin	abs all any ascii bin bool breakpoint bytearray
                              syn keyword pythonBuiltin	bytes callable chr classmethod compile complex
                              syn keyword pythonBuiltin	delattr dict dir divmod enumerate eval exec
                              syn keyword pythonBuiltin	filter float format frozenset getattr globals
                              syn keyword pythonBuiltin	hasattr hash help hex id input int isinstance
                              syn keyword pythonBuiltin	issubclass iter len list locals map max
                              syn keyword pythonBuiltin	memoryview min next object oct open ord pow
                              syn keyword pythonBuiltin	print property range repr reversed round set
                              syn keyword pythonBuiltin	setattr slice sorted staticmethod str sum super
                              syn keyword pythonBuiltin	tuple type vars zip __import__
                              " avoid highlighting attributes as builtins
                              syn match   pythonAttribute	/\.\h\w*/hs=s+1
                            	\ contains=ALLBUT,pythonBuiltin,pythonFunction,pythonAsync
                            	\ transparent
                            endif
                            
                            " From the 'Python Library Reference' class hierarchy at the bottom.
                            " http://docs.python.org/library/exceptions.html
                            if !exists("python_no_exception_highlight")
                              " builtin base exceptions (used mostly as base classes for other exceptions)
                              syn keyword pythonExceptions	BaseException Exception
                              syn keyword pythonExceptions	ArithmeticError BufferError LookupError
                              " builtin exceptions (actually raised)
                              syn keyword pythonExceptions	AssertionError AttributeError EOFError
                              syn keyword pythonExceptions	FloatingPointError GeneratorExit ImportError
                              syn keyword pythonExceptions	IndentationError IndexError KeyError
                              syn keyword pythonExceptions	KeyboardInterrupt MemoryError
                              syn keyword pythonExceptions	ModuleNotFoundError NameError
                              syn keyword pythonExceptions	NotImplementedError OSError OverflowError
                              syn keyword pythonExceptions	RecursionError ReferenceError RuntimeError
                              syn keyword pythonExceptions	StopAsyncIteration StopIteration SyntaxError
                              syn keyword pythonExceptions	SystemError SystemExit TabError TypeError
                              syn keyword pythonExceptions	UnboundLocalError UnicodeDecodeError
                              syn keyword pythonExceptions	UnicodeEncodeError UnicodeError
                              syn keyword pythonExceptions	UnicodeTranslateError ValueError
                              syn keyword pythonExceptions	ZeroDivisionError
                              " builtin exception aliases for OSError
                              syn keyword pythonExceptions	EnvironmentError IOError WindowsError
                              " builtin OS exceptions in Python 3
                              syn keyword pythonExceptions	BlockingIOError BrokenPipeError
                              syn keyword pythonExceptions	ChildProcessError ConnectionAbortedError
                              syn keyword pythonExceptions	ConnectionError ConnectionRefusedError
                              syn keyword pythonExceptions	ConnectionResetError FileExistsError
                              syn keyword pythonExceptions	FileNotFoundError InterruptedError
                              syn keyword pythonExceptions	IsADirectoryError NotADirectoryError
                              syn keyword pythonExceptions	PermissionError ProcessLookupError TimeoutError
                              " builtin warnings
                              syn keyword pythonExceptions	BytesWarning DeprecationWarning FutureWarning
                              syn keyword pythonExceptions	ImportWarning PendingDeprecationWarning
                              syn keyword pythonExceptions	ResourceWarning RuntimeWarning
                              syn keyword pythonExceptions	SyntaxWarning UnicodeWarning
                              syn keyword pythonExceptions	UserWarning Warning
                            endif
                            
                            if exists("python_space_error_highlight")
                              " trailing whitespace
                              syn match   pythonSpaceError	display excludenl "\s\+$"
                              " mixed tabs and spaces
                              syn match   pythonSpaceError	display " \+\t"
                              syn match   pythonSpaceError	display "\t\+ "
                            endif
                            
                            " Do not spell doctests inside strings.
                            " Notice that the end of a string, either ''', or """, will end the contained
                            " doctest too.  Thus, we do *not* need to have it as an end pattern.
                            if !exists("python_no_doctest_highlight")
                              if !exists("python_no_doctest_code_highlight")
                                syn region pythonDoctest
                            	  \ start="^\s*>>>\s" end="^\s*$"
                            	  \ contained contains=ALLBUT,pythonDoctest,pythonFunction,@Spell
                                syn region pythonDoctestValue
                            	  \ start=+^\s*\%(>>>\s\|\.\.\.\s\|"""\|'''\)\@!\S\++ end="$"
                            	  \ contained
                              else
                                syn region pythonDoctest
                            	  \ start="^\s*>>>" end="^\s*$"
                            	  \ contained contains=@NoSpell
                              endif
                            endif
                            
                            " Sync at the beginning of class, function, or method definition.
                            syn sync match pythonSync grouphere NONE "^\%(def\|class\)\s\+\h\w*\s*[(:]"
                            
                            " The default highlight links.  Can be overridden later.
                            hi def link pythonStatement		Statement
                            hi def link pythonConditional		Conditional
                            hi def link pythonRepeat		Repeat
                            hi def link pythonOperator		Operator
                            hi def link pythonException		Exception
                            hi def link pythonInclude		Include
                            hi def link pythonAsync			Statement
                            hi def link pythonDecorator		Define
                            hi def link pythonDecoratorName		Function
                            hi def link pythonFunction		Function
                            hi def link pythonComment		Comment
                            hi def link pythonTodo			Todo
                            hi def link pythonString		String
                            hi def link pythonRawString		String
                            hi def link pythonQuotes		String
                            hi def link pythonTripleQuotes		pythonQuotes
                            hi def link pythonEscape		Special
                            if !exists("python_no_number_highlight")
                              hi def link pythonNumber		Number
                            endif
                            if !exists("python_no_builtin_highlight")
                              hi def link pythonBuiltin		Function
                            endif
                            if !exists("python_no_exception_highlight")
                              hi def link pythonExceptions		Structure
                            endif
                            if exists("python_space_error_highlight")
                              hi def link pythonSpaceError		Error
                            endif
                            if !exists("python_no_doctest_highlight")
                              hi def link pythonDoctest		Special
                              hi def link pythonDoctestValue	Define
                            endif
                            
                            let b:current_syntax = "python"
                            
                            let &cpo = s:cpo_save
                            unlet s:cpo_save
                            
                            " vim:set sw=2 sts=2 ts=8 noet:

SCRIPT  C:\Users\Lenovo\scoop\apps\neovim\0.6.1\share\nvim\runtime\ftplugin\python.vim
Sourced 2 times
Total time:   0.077816
 Self time:   0.077816

count  total (s)   self (s)
                            " Vim filetype plugin file
                            " Language:	python
                            " Maintainer:	Tom Picton <tom@tompicton.co.uk>
                            " Previous Maintainer: James Sully <sullyj3@gmail.com>
                            " Previous Maintainer: Johannes Zellner <johannes@zellner.org>
                            " Last Change:	Mon, 5 October 2020
                            " https://github.com/tpict/vim-ftplugin-python
                            
    2              0.000096 if exists("b:did_ftplugin") | finish | endif
    2              0.000032 let b:did_ftplugin = 1
    2              0.000054 let s:keepcpo= &cpo
    2              0.000063 set cpo&vim
                            
    2              0.000036 setlocal cinkeys-=0#
    2              0.000038 setlocal indentkeys-=0#
    2              0.000026 setlocal include=^\\s*\\(from\\\|import\\)
    2              0.000019 setlocal define=^\\s*\\(def\\\|class\\)
                            
                            " For imports with leading .., append / and replace additional .s with ../
    2              0.000027 let b:grandparent_match = '^\(.\.\)\(\.*\)'
    2              0.000022 let b:grandparent_sub = '\=submatch(1)."/".repeat("../",strlen(submatch(2)))'
                            
                            " For imports with a single leading ., replace it with ./
    2              0.000015 let b:parent_match = '^\.\(\.\)\@!'
    2              0.000013 let b:parent_sub = './'
                            
                            " Replace any . sandwiched between word characters with /
    2              0.000015 let b:child_match = '\(\w\)\.\(\w\)'
    2              0.000013 let b:child_sub = '\1/\2'
                            
    2              0.000058 setlocal includeexpr=substitute(substitute(substitute(
                                  \v:fname,
                                  \b:grandparent_match,b:grandparent_sub,''),
                                  \b:parent_match,b:parent_sub,''),
                                  \b:child_match,b:child_sub,'g')
                            
    2              0.000022 setlocal suffixesadd=.py
    2              0.000027 setlocal comments=b:#,fb:-
    2              0.000020 setlocal commentstring=#\ %s
                            
    2              0.000160 if has('python3')
    2              0.000030   setlocal omnifunc=python3complete#Complete
                            elseif has('python')
                              setlocal omnifunc=pythoncomplete#Complete
    2              0.000006 endif
                            
    2              0.000044 set wildignore+=*.pyc
                            
    2              0.000028 let b:next_toplevel='\v%$\|^(class\|def\|async def)>'
    2              0.000019 let b:prev_toplevel='\v^(class\|def\|async def)>'
    2              0.000020 let b:next_endtoplevel='\v%$\|\S.*\n+(def\|class)'
    2              0.000019 let b:prev_endtoplevel='\v\S.*\n+(def\|class)'
    2              0.000019 let b:next='\v%$\|^\s*(class\|def\|async def)>'
    2              0.000020 let b:prev='\v^\s*(class\|def\|async def)>'
    2              0.000028 let b:next_end='\v\S\n*(%$\|^(\s*\n*)*(class\|def\|async def)\|^\S)'
    2              0.000017 let b:prev_end='\v\S\n*(^(\s*\n*)*(class\|def\|async def)\|^\S)'
                            
    2              0.000047 if !exists('g:no_plugin_maps') && !exists('g:no_python_maps')
    2              0.000376     execute "nnoremap <silent> <buffer> ]] :call <SID>Python_jump('n', '". b:next_toplevel."', 'W', v:count1)<cr>"
    2              0.000294     execute "nnoremap <silent> <buffer> [[ :call <SID>Python_jump('n', '". b:prev_toplevel."', 'Wb', v:count1)<cr>"
    2              0.000289     execute "nnoremap <silent> <buffer> ][ :call <SID>Python_jump('n', '". b:next_endtoplevel."', 'W', v:count1, 0)<cr>"
    2              0.000275     execute "nnoremap <silent> <buffer> [] :call <SID>Python_jump('n', '". b:prev_endtoplevel."', 'Wb', v:count1, 0)<cr>"
    2              0.000344     execute "nnoremap <silent> <buffer> ]m :call <SID>Python_jump('n', '". b:next."', 'W', v:count1)<cr>"
    2              0.000412     execute "nnoremap <silent> <buffer> [m :call <SID>Python_jump('n', '". b:prev."', 'Wb', v:count1)<cr>"
    2              0.000445     execute "nnoremap <silent> <buffer> ]M :call <SID>Python_jump('n', '". b:next_end."', 'W', v:count1, 0)<cr>"
    2              0.000317     execute "nnoremap <silent> <buffer> [M :call <SID>Python_jump('n', '". b:prev_end."', 'Wb', v:count1, 0)<cr>"
                            
    2              0.000262     execute "onoremap <silent> <buffer> ]] :call <SID>Python_jump('o', '". b:next_toplevel."', 'W', v:count1)<cr>"
    2              0.000283     execute "onoremap <silent> <buffer> [[ :call <SID>Python_jump('o', '". b:prev_toplevel."', 'Wb', v:count1)<cr>"
    2              0.000251     execute "onoremap <silent> <buffer> ][ :call <SID>Python_jump('o', '". b:next_endtoplevel."', 'W', v:count1, 0)<cr>"
    2              0.000250     execute "onoremap <silent> <buffer> [] :call <SID>Python_jump('o', '". b:prev_endtoplevel."', 'Wb', v:count1, 0)<cr>"
    2              0.000263     execute "onoremap <silent> <buffer> ]m :call <SID>Python_jump('o', '". b:next."', 'W', v:count1)<cr>"
    2              0.000257     execute "onoremap <silent> <buffer> [m :call <SID>Python_jump('o', '". b:prev."', 'Wb', v:count1)<cr>"
    2              0.000311     execute "onoremap <silent> <buffer> ]M :call <SID>Python_jump('o', '". b:next_end."', 'W', v:count1, 0)<cr>"
    2              0.000310     execute "onoremap <silent> <buffer> [M :call <SID>Python_jump('o', '". b:prev_end."', 'Wb', v:count1, 0)<cr>"
                            
    2              0.000261     execute "xnoremap <silent> <buffer> ]] :call <SID>Python_jump('x', '". b:next_toplevel."', 'W', v:count1)<cr>"
    2              0.000413     execute "xnoremap <silent> <buffer> [[ :call <SID>Python_jump('x', '". b:prev_toplevel."', 'Wb', v:count1)<cr>"
    2              0.000253     execute "xnoremap <silent> <buffer> ][ :call <SID>Python_jump('x', '". b:next_endtoplevel."', 'W', v:count1, 0)<cr>"
    2              0.000241     execute "xnoremap <silent> <buffer> [] :call <SID>Python_jump('x', '". b:prev_endtoplevel."', 'Wb', v:count1, 0)<cr>"
    2              0.000260     execute "xnoremap <silent> <buffer> ]m :call <SID>Python_jump('x', '". b:next."', 'W', v:count1)<cr>"
    2              0.000266     execute "xnoremap <silent> <buffer> [m :call <SID>Python_jump('x', '". b:prev."', 'Wb', v:count1)<cr>"
    2              0.000317     execute "xnoremap <silent> <buffer> ]M :call <SID>Python_jump('x', '". b:next_end."', 'W', v:count1, 0)<cr>"
    2              0.000305     execute "xnoremap <silent> <buffer> [M :call <SID>Python_jump('x', '". b:prev_end."', 'Wb', v:count1, 0)<cr>"
    2              0.000008 endif
                            
    2              0.000048 if !exists('*<SID>Python_jump')
                              fun! <SID>Python_jump(mode, motion, flags, count, ...) range
                                  let l:startofline = (a:0 >= 1) ? a:1 : 1
                            
                                  if a:mode == 'x'
                                      normal! gv
                                  endif
                            
                                  if l:startofline == 1
                                      normal! 0
                                  endif
                            
                                  let cnt = a:count
                                  mark '
                                  while cnt > 0
                                      call search(a:motion, a:flags)
                                      let cnt = cnt - 1
                                  endwhile
                            
                                  if l:startofline == 1
                                      normal! ^
                                  endif
                              endfun
    2              0.000007 endif
                            
    2              0.000052 if has("browsefilter") && !exists("b:browsefilter")
    2              0.000042     let b:browsefilter = "Python Files (*.py)\t*.py\n" .
                                            \ "All Files (*.*)\t*.*\n"
    2              0.000006 endif
                            
    2              0.000034 if !exists("g:python_recommended_style") || g:python_recommended_style != 0
                                " As suggested by PEP8.
    2              0.000114     setlocal expandtab tabstop=4 softtabstop=4 shiftwidth=4
    2              0.000006 endif
                            
                            " Use pydoc for keywordprg.
                            " Unix users preferentially get pydoc3, then pydoc2.
                            " Windows doesn't have a standalone pydoc executable in $PATH by default, nor
                            " does it have separate python2/3 executables, so Windows users just get
                            " whichever version corresponds to their installed Python version.
    2              0.066903 if executable('python3')
    2              0.000095   setlocal keywordprg=python3\ -m\ pydoc
                            elseif executable('python')
                              setlocal keywordprg=python\ -m\ pydoc
    2              0.000008 endif
                            
                            " Script for filetype switching to undo the local stuff we may have changed
    2              0.001192 let b:undo_ftplugin = 'setlocal cinkeys<'
                                  \ . '|setlocal comments<'
                                  \ . '|setlocal commentstring<'
                                  \ . '|setlocal expandtab<'
                                  \ . '|setlocal include<'
                                  \ . '|setlocal includeexpr<'
                                  \ . '|setlocal indentkeys<'
                                  \ . '|setlocal keywordprg<'
                                  \ . '|setlocal omnifunc<'
                                  \ . '|setlocal shiftwidth<'
                                  \ . '|setlocal softtabstop<'
                                  \ . '|setlocal suffixesadd<'
                                  \ . '|setlocal tabstop<'
                                  \ . '|silent! nunmap <buffer> [M'
                                  \ . '|silent! nunmap <buffer> [['
                                  \ . '|silent! nunmap <buffer> []'
                                  \ . '|silent! nunmap <buffer> [m'
                                  \ . '|silent! nunmap <buffer> ]M'
                                  \ . '|silent! nunmap <buffer> ]['
                                  \ . '|silent! nunmap <buffer> ]]'
                                  \ . '|silent! nunmap <buffer> ]m'
                                  \ . '|silent! ounmap <buffer> [M'
                                  \ . '|silent! ounmap <buffer> [['
                                  \ . '|silent! ounmap <buffer> []'
                                  \ . '|silent! ounmap <buffer> [m'
                                  \ . '|silent! ounmap <buffer> ]M'
                                  \ . '|silent! ounmap <buffer> ]['
                                  \ . '|silent! ounmap <buffer> ]]'
                                  \ . '|silent! ounmap <buffer> ]m'
                                  \ . '|silent! xunmap <buffer> [M'
                                  \ . '|silent! xunmap <buffer> [['
                                  \ . '|silent! xunmap <buffer> []'
                                  \ . '|silent! xunmap <buffer> [m'
                                  \ . '|silent! xunmap <buffer> ]M'
                                  \ . '|silent! xunmap <buffer> ]['
                                  \ . '|silent! xunmap <buffer> ]]'
                                  \ . '|silent! xunmap <buffer> ]m'
                                  \ . '|unlet! b:browsefilter'
                                  \ . '|unlet! b:child_match'
                                  \ . '|unlet! b:child_sub'
                                  \ . '|unlet! b:grandparent_match'
                                  \ . '|unlet! b:grandparent_sub'
                                  \ . '|unlet! b:next'
                                  \ . '|unlet! b:next_end'
                                  \ . '|unlet! b:next_endtoplevel'
                                  \ . '|unlet! b:next_toplevel'
                                  \ . '|unlet! b:parent_match'
                                  \ . '|unlet! b:parent_sub'
                                  \ . '|unlet! b:prev'
                                  \ . '|unlet! b:prev_end'
                                  \ . '|unlet! b:prev_endtoplevel'
                                  \ . '|unlet! b:prev_toplevel'
                                  \ . '|unlet! b:undo_ftplugin'
                            
    2              0.000076 let &cpo = s:keepcpo
    2              0.000115 unlet s:keepcpo

SCRIPT  C:\Users\Lenovo\AppData\Local\nvim\after\ftplugin\python.vim
Sourced 2 times
Total time:   0.000300
 Self time:   0.000300

count  total (s)   self (s)
    2              0.000086 if exists("g:python_PlugPluggidiliditity")
    2              0.000015   finish
                            endif
                            let g:python_PlugPluggidiliditity = 1
                            let g:python_RunFile = 'undefined'
                            
                            function CondaInfo()
                                " Print Info
                                echo $CONDA_DEFAULT_ENV
                                echo $g:python3_host_prog
                            endfunction
                            
                            function CondaUpdate()
                                let g:python3_host_prog = 'C:/Users/Lenovo/miniconda3/envs/' . g:CondaEnv . '/python'
                            endfunction
                            
                            function CondaInit(env='')
                                " Set Environment
                                echo a:env
                                if a:env != ''
                                    let g:CondaEnv = a:env
                                    call CondaUpdate()
                                endif
                            endfunction
                            
                            if $CONDA_DEFAULT_ENV == ''
                                call CondaInit($CONDA_DEFAULT_ENV)
                            endif
                            
                            
                            " Call Python
                            "map <buffer> <F9> :w<CR>:execute '!condaVim'  g:CondaEnv shellescape(@%, 1)<CR>
                            "imap <buffer> <F9> <esc>:w<CR>:execute '!condaVim' g:CondaEnv shellescape(@%, 1)<CR>
                            
                             " Bind F5 to save file if modified and execute python script in a buffer. -
                            "map <F10> :call SaveAndExecutePython('python')<CR>
                            "imap <F10> :<C-u>call SaveAndExecutePython('python')<CR>
                            
                            
                            let g:CondaEnv = $CONDA_DEFAULT_ENV
                            
                            let g:python3_host_prog = 'C:/Users/Lenovo/miniconda3/envs/' . g:CondaEnv . '/python'
                            
                            
                            """""""""""""""""""""""
                            "let g:neoterm_command_prefix = 'python'
                            
                            function NeotermTerminalPython(current_file, main_window_nr, Update_RunFile)
                                if g:python_RunFile=='undefined'|| a:Update_RunFile==1
                                    let g:python_RunFile = a:current_file
                                endif
                                let g:main_window_nr = a:main_window_nr
                            
                                execute "1winc w"
                                if t:NerdTreeInUse == 1
                                    NERDTreeToggle
                                    execute "71winc |"
                                endif
                            
                                if g:python_PlugPluggidiliditity == 1
                                    "execute 'T PROMPT ________________________$_$_\033[32m' . substitute(getcwd(), '^.*\', '', '') . '$g$s'
                                    execute 'T PROMPT ________________________$_$_' . substitute(getcwd(), '^.*\', '', '') . '$g$s'
                                    exec "setlocal statusline="
                                    let b:CloseThisWindowIfItsLonely = 1    " re-label this variable to be named after your plugin
                                    "setlocal nobuflisted
                                    setlocal noswapfile
                                    "setlocal bufhidden="wipe"
                                    setlocal foldcolumn=1
                                    setlocal winfixwidth
                                endif
                                let g:python_PlugPluggidiliditity = 0
                                execute "T python " . g:python_RunFile
                                execute a:main_window_nr . "winc w"
                            endfunction
                            map  <F9> :w<CR>:call NeotermTerminalPython(@%, winnr(), 1)<CR>
                            map  <F10> :w<CR>:call NeotermTerminalPython(@%, winnr(), 0)<CR>
                            
                            map  <C-p> :w<CR>:call NeotermTerminalPython(@%, winnr(), 0)<CR>
                            
                            
                            
                            

SCRIPT  C:\Users\Lenovo\AppData\Local\nvim-data\plugged\vim-polyglot\indent\python.vim
Sourced 2 times
Total time:   0.003743
 Self time:   0.003589

count  total (s)   self (s)
    2   0.000515   0.000360 if polyglot#init#is_disabled(expand('<sfile>:p'), 'python-indent', 'indent/python.vim')
                              finish
    2              0.000005 endif
                            
                            " PEP8 compatible Python indent file
                            " Language:         Python
                            " Maintainer:       Daniel Hahler <https://daniel.hahler.de/>
                            " Prev Maintainer:  Hynek Schlawack <hs@ox.cx>
                            " Prev Maintainer:  Eric Mc Sween <em@tomcom.de> (address invalid)
                            " Original Author:  David Bustos <bustos@caltech.edu> (address invalid)
                            " License:          CC0
                            "
                            " vim-python-pep8-indent - A nicer Python indentation style for vim.
                            " Written in 2004 by David Bustos <bustos@caltech.edu>
                            " Maintained from 2004-2005 by Eric Mc Sween <em@tomcom.de>
                            " Maintained from 2013 by Hynek Schlawack <hs@ox.cx>
                            " Maintained from 2017 by Daniel Hahler <https://daniel.hahler.de/>
                            "
                            " To the extent possible under law, the author(s) have dedicated all copyright
                            " and related and neighboring rights to this software to the public domain
                            " worldwide. This software is distributed without any warranty.
                            " You should have received a copy of the CC0 Public Domain Dedication along
                            " with this software. If not, see
                            " <http://creativecommons.org/publicdomain/zero/1.0/>.
                            
                            " Only load this indent file when no other was loaded.
    2              0.000018 if exists('b:did_indent')
                                finish
    2              0.000004 endif
    2              0.000016 let b:did_indent = 1
                            
    2              0.000088 setlocal nolisp
    2              0.000019 setlocal autoindent
    2              0.000028 setlocal indentexpr=GetPythonPEPIndent(v:lnum)
    2              0.000021 setlocal indentkeys=!^F,o,O,<:>,0),0],0},=elif,=except
                            
    2              0.000040 if !exists('g:python_pep8_indent_multiline_string')
                                let g:python_pep8_indent_multiline_string = 0
    2              0.000004 endif
                            
    2              0.000021 if !exists('g:python_pep8_indent_hang_closing')
                                let g:python_pep8_indent_hang_closing = 0
    2              0.000003 endif
                            
                            " TODO: check required patch for timeout argument, likely lower than 7.3.429 though.
    2              0.000020 if !exists('g:python_pep8_indent_searchpair_timeout')
                                if has('patch-8.0.1483')
                                    let g:python_pep8_indent_searchpair_timeout = 150
                                else
                                    let g:python_pep8_indent_searchpair_timeout = 0
                                endif
    2              0.000003 endif
                            
    2              0.000117 let s:block_rules = {
                                  \ '^\s*elif\>': [['if', 'elif'], ['else']],
                                  \ '^\s*except\>': [['try', 'except'], []],
                                  \ '^\s*finally\>': [['try', 'except', 'else'], []]
                                  \ }
    2              0.000051 let s:block_rules_multiple = {
                                  \ '^\s*else\>': [['if', 'elif', 'for', 'try', 'except'], []]
                                  \ }
                            " Pairs to look for when searching for opening parenthesis.
                            " The value is the maximum offset in lines.
    2              0.000027 let s:paren_pairs = {'()': 50, '[]': 100, '{}': 1000}
                            
    2              0.000023 if &filetype ==# 'pyrex' || &filetype ==# 'cython'
                                let b:control_statement = '\v^\s*(class|def|if|while|with|for|except|cdef|cpdef)>'
    2              0.000006 else
    2              0.000017     let b:control_statement = '\v^\s*(class|def|if|while|with|for|except)>'
    2              0.000006 endif
    2              0.000015 let s:stop_statement = '^\s*\(break\|continue\|raise\|return\|pass\)\>'
                            
    2              0.000027 let s:skip_after_opening_paren = 'synIDattr(synID(line("."), col("."), 0), "name") ' .
                                        \ '=~? "\\vcomment|jedi\\S"'
                            
    2              0.000018 let s:special_chars_syn_pattern = "\\vstring|comment|^pythonbytes%(contents)=$|pythonTodo|jedi\\S"
                            
    2              0.000029 if !get(g:, 'python_pep8_indent_skip_concealed', 0) || !has('conceal')
                                " Skip strings and comments. Return 1 for chars to skip.
                                " jedi* refers to syntax definitions from jedi-vim for call signatures, which
                                " are inserted temporarily into the buffer.
    2              0.000024     function! s:_skip_special_chars(line, col)
                                    return synIDattr(synID(a:line, a:col, 0), 'name')
                                          \ =~? s:special_chars_syn_pattern
                                endfunction
                            else
                                " Also ignore anything concealed.
                                " TODO: doc; likely only necessary with jedi-vim, where a better version is
                                " planned (https://github.com/Vimjas/vim-python-pep8-indent/pull/98).
                            
                                " Wrapper around synconcealed for older Vim (7.3.429, used on Travis CI).
                                function! s:is_concealed(line, col)
                                    let concealed = synconcealed(a:line, a:col)
                                    return len(concealed) && concealed[0]
                                endfunction
                            
                                function! s:_skip_special_chars(line, col)
                                    return synIDattr(synID(a:line, a:col, 0), 'name')
                                          \ =~? s:special_chars_syn_pattern
                                          \ || s:is_concealed(a:line, a:col)
                                endfunction
    2              0.000005 endif
                            
                            " Use 'shiftwidth()' instead of '&sw'.
                            " (Since Vim patch 7.3.629, 'shiftwidth' can be set to 0 to follow 'tabstop').
    2              0.000023 if exists('*shiftwidth')
    2              0.000013     function! s:sw()
                                    return shiftwidth()
                                endfunction
                            else
                                function! s:sw()
                                    return &shiftwidth
                                endfunction
    2              0.000004 endif
                            
                            " Find backwards the closest open parenthesis/bracket/brace.
    2              0.000014 function! s:find_opening_paren(lnum, col)
                                " Return if cursor is in a comment.
                                if synIDattr(synID(a:lnum, a:col, 0), 'name') =~? 'comment'
                                    return [0, 0]
                                endif
                            
                                call cursor(a:lnum, a:col)
                            
                                let nearest = [0, 0]
                                let timeout = g:python_pep8_indent_searchpair_timeout
                                let skip_special_chars = 's:_skip_special_chars(line("."), col("."))'
                                for [p, maxoff] in items(s:paren_pairs)
                                    let stopline = max([0, line('.') - maxoff, nearest[0]])
                                    let next = searchpairpos(
                                       \ '\V'.p[0], '', '\V'.p[1], 'bnW', skip_special_chars, stopline, timeout)
                                    if next[0] && (next[0] > nearest[0] || (next[0] == nearest[0] && next[1] > nearest[1]))
                                        let nearest = next
                                    endif
                                endfor
                                return nearest
                            endfunction
                            
                            " Find the start of a multi-line statement
    2              0.000015 function! s:find_start_of_multiline_statement(lnum)
                                let lnum = a:lnum
                                while lnum > 0
                                    if getline(lnum - 1) =~# '\\$'
                                        let lnum = prevnonblank(lnum - 1)
                                    else
                                        let [paren_lnum, _] = s:find_opening_paren(lnum, 1)
                                        if paren_lnum < 1
                                            return lnum
                                        else
                                            let lnum = paren_lnum
                                        endif
                                    endif
                                endwhile
                            endfunction
                            
                            " Find possible indent(s) of the block starter that matches the current line.
    2              0.000019 function! s:find_start_of_block(lnum, types, skip, multiple) abort
                                let r = []
                                let re = '\V\^\s\*\('.join(a:types, '\|').'\)\>'
                                if !empty(a:skip)
                                  let re_skip = '\V\^\s\*\('.join(a:skip, '\|').'\)\>'
                                else
                                  let re_skip = ''
                                endif
                                let last_indent = indent(a:lnum) + 1
                                let lnum = a:lnum - 1
                                while lnum > 0 && last_indent > 0
                                    let indent = indent(lnum)
                                    if indent < last_indent
                                        let line = getline(lnum)
                                        if !empty(re_skip) && line =~# re_skip
                                            let last_indent = indent
                                        elseif line =~# re
                                            if !a:multiple
                                                return [indent]
                                            endif
                                            if index(r, indent) == -1
                                                let r += [indent]
                                            endif
                                            let last_indent = indent
                                        endif
                                    endif
                                    let lnum = prevnonblank(lnum - 1)
                                endwhile
                                return r
                            endfunction
                            
                            " Is "expr" true for every position in "lnum", beginning at "start"?
                            " (optionally up to a:1 / 4th argument)
    2              0.000015 function! s:match_expr_on_line(expr, lnum, start, ...)
                                let text = getline(a:lnum)
                                let end = a:0 ? a:1 : len(text)
                                if a:start > end
                                    return 1
                                endif
                                let save_pos = getpos('.')
                                let r = 1
                                for i in range(a:start, end)
                                    call cursor(a:lnum, i)
                                    if !(eval(a:expr) || text[i-1] =~# '\s')
                                        let r = 0
                                        break
                                    endif
                                endfor
                                call setpos('.', save_pos)
                                return r
                            endfunction
                            
                            " Line up with open parenthesis/bracket/brace.
    2              0.000016 function! s:indent_like_opening_paren(lnum)
                                let [paren_lnum, paren_col] = s:find_opening_paren(a:lnum, 1)
                                if paren_lnum <= 0
                                    return -2
                                endif
                                let text = getline(paren_lnum)
                                let base = indent(paren_lnum)
                            
                                let nothing_after_opening_paren = s:match_expr_on_line(
                                            \ s:skip_after_opening_paren, paren_lnum, paren_col+1)
                                let starts_with_closing_paren = getline(a:lnum) =~# '^\s*[])}]'
                            
                                let hang_closing = get(b:, 'python_pep8_indent_hang_closing',
                                            \ get(g:, 'python_pep8_indent_hang_closing', 0))
                            
                                if nothing_after_opening_paren
                                    if starts_with_closing_paren && !hang_closing
                                        let res = base
                                    else
                                        let res = base + s:sw()
                            
                                        " Special case for parenthesis.
                                        if text[paren_col-1] ==# '(' && getline(a:lnum) !~# '\v\)\s*:?\s*$'
                                            return res
                                        endif
                                    endif
                                else
                                    " Indent to match position of opening paren.
                                    let res = paren_col
                                endif
                            
                                " If this line is the continuation of a control statement
                                " indent further to distinguish the continuation line
                                " from the next logical line.
                                if text =~# b:control_statement && res == base + s:sw()
                                    " But only if not inside parens itself (Flake's E127).
                                    let [paren_lnum, _] = s:find_opening_paren(paren_lnum, 1)
                                    if paren_lnum <= 0
                                        return res + s:sw()
                                    endif
                                endif
                                return res
                            endfunction
                            
                            " Match indent of first block of this type.
    2              0.000013 function! s:indent_like_block(lnum)
                                let text = getline(a:lnum)
                                for [multiple, block_rules] in [
                                            \ [0, s:block_rules],
                                            \ [1, s:block_rules_multiple],
                                            \ ]
                                    for [line_re, blocks_ignore] in items(block_rules)
                                        if text !~# line_re
                                            continue
                                        endif
                            
                                        let [blocks, skip] = blocks_ignore
                                        let indents = s:find_start_of_block(a:lnum, blocks, skip, multiple)
                                        if empty(indents)
                                            return -1
                                        endif
                                        if len(indents) == 1
                                            return indents[0]
                                        endif
                            
                                        " Multiple valid indents, e.g. for 'else' with both try and if.
                                        let indent = indent(a:lnum)
                                        if index(indents, indent) != -1
                                            " The indent is valid, keep it.
                                            return indent
                                        endif
                                        " Fallback to the first/nearest one.
                                        return indents[0]
                                    endfor
                                endfor
                                return -2
                            endfunction
                            
    2              0.000014 function! s:indent_like_previous_line(lnum)
                                let lnum = prevnonblank(a:lnum - 1)
                            
                                " No previous line, keep current indent.
                                if lnum < 1
                                  return -1
                                endif
                            
                                let text = getline(lnum)
                                let start = s:find_start_of_multiline_statement(lnum)
                                let base = indent(start)
                                let current = indent(a:lnum)
                            
                                " Ignore last character in previous line?
                                let lastcol = len(text)
                                let col = lastcol
                            
                                " Search for final colon that is not inside something to be ignored.
                                while 1
                                    if col == 1 | break | endif
                                    if text[col-1] =~# '\s' || s:_skip_special_chars(lnum, col)
                                        let col = col - 1
                                        continue
                                    elseif text[col-1] ==# ':'
                                        return base + s:sw()
                                    endif
                                    break
                                endwhile
                            
                                if text =~# '\\$' && !s:_skip_special_chars(lnum, lastcol)
                                    " If this line is the continuation of a control statement
                                    " indent further to distinguish the continuation line
                                    " from the next logical line.
                                    if getline(start) =~# b:control_statement
                                        return base + s:sw() * 2
                                    endif
                            
                                    " Nest (other) explicit continuations only one level deeper.
                                    return base + s:sw()
                                endif
                            
                                let empty = getline(a:lnum) =~# '^\s*$'
                            
                                " Current and prev line are empty, next is not -> indent like next.
                                if empty && a:lnum > 1 &&
                                      \ (getline(a:lnum - 1) =~# '^\s*$') &&
                                      \ !(getline(a:lnum + 1) =~# '^\s*$')
                                  return indent(a:lnum + 1)
                                endif
                            
                                " If the previous statement was a stop-execution statement or a pass
                                if getline(start) =~# s:stop_statement
                                    " Remove one level of indentation if the user hasn't already dedented
                                    if empty || current > base - s:sw()
                                        return base - s:sw()
                                    endif
                                    " Otherwise, trust the user
                                    return -1
                                endif
                            
                                if (current || !empty) && s:is_dedented_already(current, base)
                                    return -1
                                endif
                            
                                " In all other cases, line up with the start of the previous statement.
                                return base
                            endfunction
                            
                            " If this line is dedented and the number of indent spaces is valid
                            " (multiple of the indentation size), trust the user.
    2              0.000018 function! s:is_dedented_already(current, base)
                                let dedent_size = a:current - a:base
                                return (dedent_size < 0 && a:current % s:sw() == 0) ? 1 : 0
                            endfunction
                            
                            " Is the syntax at lnum (and optionally cnum) a python string?
    2              0.000012 function! s:is_python_string(lnum, ...)
                                let line = getline(a:lnum)
                                if a:0
                                  let cols = type(a:1) != type([]) ? [a:1] : a:1
                                else
                                  let cols = range(1, max([1, len(line)]))
                                endif
                                for cnum in cols
                                    if match(map(synstack(a:lnum, cnum),
                                                \ "synIDattr(v:val, 'name')"), 'python\S*String') == -1
                                        return 0
                                    end
                                endfor
                                return 1
                            endfunction
                            
    2              0.000012 function! GetPythonPEPIndent(lnum)
                                " First line has indent 0
                                if a:lnum == 1
                                    return 0
                                endif
                            
                                let line = getline(a:lnum)
                                let prevline = getline(a:lnum-1)
                            
                                " Multilinestrings: continous, docstring or starting.
                                if s:is_python_string(a:lnum-1, max([1, len(prevline)]))
                                            \ && (s:is_python_string(a:lnum, 1)
                                            \     || match(line, '^\%("""\|''''''\)') != -1)
                            
                                    " Indent closing quotes as the line with the opening ones.
                                    let match_quotes = match(line, '^\s*\zs\%("""\|''''''\)')
                                    if match_quotes != -1
                                        " closing multiline string
                                        let quotes = line[match_quotes:(match_quotes+2)]
                                        call cursor(a:lnum, 1)
                                        let pairpos = searchpairpos(quotes, '', quotes, 'bW', '', 0, g:python_pep8_indent_searchpair_timeout)
                                        if pairpos[0] != 0
                                            return indent(pairpos[0])
                                        else
                                            return -1
                                        endif
                                    endif
                            
                                    if s:is_python_string(a:lnum-1)
                                        " Previous line is (completely) a string: keep current indent.
                                        return -1
                                    endif
                            
                                    if match(prevline, '^\s*\%("""\|''''''\)') != -1
                                        " docstring.
                                        return indent(a:lnum-1)
                                    endif
                            
                                    let indent_multi = get(b:, 'python_pep8_indent_multiline_string',
                                                \ get(g:, 'python_pep8_indent_multiline_string', 0))
                                    if match(prevline, '\v%("""|'''''')$') != -1
                                        " Opening multiline string, started in previous line.
                                        if (&autoindent && indent(a:lnum) == indent(a:lnum-1))
                                                    \ || match(line, '\v^\s+$') != -1
                                            " <CR> with empty line or to split up 'foo("""bar' into
                                            " 'foo("""' and 'bar'.
                                            if indent_multi == -2
                                                return indent(a:lnum-1) + s:sw()
                                            endif
                                            return indent_multi
                                        endif
                                    endif
                            
                                    " Keep existing indent.
                                    if match(line, '\v^\s*\S') != -1
                                        return -1
                                    endif
                            
                                    if indent_multi != -2
                                        return indent_multi
                                    endif
                            
                                    return s:indent_like_opening_paren(a:lnum)
                                endif
                            
                                " Parens: If we can find an open parenthesis/bracket/brace, line up with it.
                                let indent = s:indent_like_opening_paren(a:lnum)
                                if indent >= -1
                                    return indent
                                endif
                            
                                " Blocks: Match indent of first block of this type.
                                let indent = s:indent_like_block(a:lnum)
                                if indent >= -1
                                    return indent
                                endif
                            
                                return s:indent_like_previous_line(a:lnum)
                            endfunction

SCRIPT  C:\Users\Lenovo\scoop\apps\neovim\0.6.1\share\nvim\runtime\indent\python.vim
Sourced 2 times
Total time:   0.000270
 Self time:   0.000270

count  total (s)   self (s)
                            " Vim indent file
                            " Language:		Python
                            " Maintainer:		Bram Moolenaar <Bram@vim.org>
                            " Original Author:	David Bustos <bustos@caltech.edu>
                            " Last Change:		2021 Sep 26
                            
                            " Only load this indent file when no other was loaded.
    2              0.000048 if exists("b:did_indent")
    2              0.000018   finish
                            endif
                            let b:did_indent = 1
                            
                            " Some preliminary settings
                            setlocal nolisp		" Make sure lisp indenting doesn't supersede us
                            setlocal autoindent	" indentexpr isn't much help otherwise
                            
                            setlocal indentexpr=GetPythonIndent(v:lnum)
                            setlocal indentkeys+=<:>,=elif,=except
                            
                            let b:undo_indent = "setl ai< inde< indk< lisp<"
                            
                            " Only define the function once.
                            if exists("*GetPythonIndent")
                              finish
                            endif
                            let s:keepcpo= &cpo
                            set cpo&vim
                            
                            " Come here when loading the script the first time.
                            
                            let s:maxoff = 50	" maximum number of lines to look backwards for ()
                            
                            " See if the specified line is already user-dedented from the expected value.
                            function s:Dedented(lnum, expected)
                              return indent(a:lnum) <= a:expected - shiftwidth()
                            endfunction
                            
                            function GetPythonIndent(lnum)
                            
                              " If this line is explicitly joined: If the previous line was also joined,
                              " line it up with that one, otherwise add two 'shiftwidth'
                              if getline(a:lnum - 1) =~ '\\$'
                                if a:lnum > 1 && getline(a:lnum - 2) =~ '\\$'
                                  return indent(a:lnum - 1)
                                endif
                                return indent(a:lnum - 1) + (exists("g:pyindent_continue") ? eval(g:pyindent_continue) : (shiftwidth() * 2))
                              endif
                            
                              " If the start of the line is in a string don't change the indent.
                              if has('syntax_items')
                            	\ && synIDattr(synID(a:lnum, 1, 1), "name") =~ "String$"
                                return -1
                              endif
                            
                              " Search backwards for the previous non-empty line.
                              let plnum = prevnonblank(v:lnum - 1)
                            
                              if plnum == 0
                                " This is the first non-empty line, use zero indent.
                                return 0
                              endif
                            
                              call cursor(plnum, 1)
                            
                              " Identing inside parentheses can be very slow, regardless of the searchpair()
                              " timeout, so let the user disable this feature if he doesn't need it
                              let disable_parentheses_indenting = get(g:, "pyindent_disable_parentheses_indenting", 0)
                            
                              if disable_parentheses_indenting == 1
                                let plindent = indent(plnum)
                                let plnumstart = plnum
                              else
                                " searchpair() can be slow sometimes, limit the time to 150 msec or what is
                                " put in g:pyindent_searchpair_timeout
                                let searchpair_stopline = 0
                                let searchpair_timeout = get(g:, 'pyindent_searchpair_timeout', 150)
                            
                                " If the previous line is inside parenthesis, use the indent of the starting
                                " line.
                                " Trick: use the non-existing "dummy" variable to break out of the loop when
                                " going too far back.
                                let parlnum = searchpair('(\|{\|\[', '', ')\|}\|\]', 'nbW',
                                        \ "line('.') < " . (plnum - s:maxoff) . " ? dummy :"
                                        \ . " synIDattr(synID(line('.'), col('.'), 1), 'name')"
                                        \ . " =~ '\\(Comment\\|Todo\\|String\\)$'",
                                        \ searchpair_stopline, searchpair_timeout)
                                if parlnum > 0
                                  let plindent = indent(parlnum)
                                  let plnumstart = parlnum
                                else
                                  let plindent = indent(plnum)
                                  let plnumstart = plnum
                                endif
                            
                                " When inside parenthesis: If at the first line below the parenthesis add
                                " two 'shiftwidth', otherwise same as previous line.
                                " i = (a
                                "       + b
                                "       + c)
                                call cursor(a:lnum, 1)
                                let p = searchpair('(\|{\|\[', '', ')\|}\|\]', 'bW',
                                        \ "line('.') < " . (a:lnum - s:maxoff) . " ? dummy :"
                                        \ . " synIDattr(synID(line('.'), col('.'), 1), 'name')"
                                        \ . " =~ '\\(Comment\\|Todo\\|String\\)$'",
                                        \ searchpair_stopline, searchpair_timeout)
                                if p > 0
                                  if p == plnum
                                    " When the start is inside parenthesis, only indent one 'shiftwidth'.
                                    let pp = searchpair('(\|{\|\[', '', ')\|}\|\]', 'bW',
                                        \ "line('.') < " . (a:lnum - s:maxoff) . " ? dummy :"
                                        \ . " synIDattr(synID(line('.'), col('.'), 1), 'name')"
                                        \ . " =~ '\\(Comment\\|Todo\\|String\\)$'",
                                        \ searchpair_stopline, searchpair_timeout)
                                    if pp > 0
                                      return indent(plnum) + (exists("g:pyindent_nested_paren") ? eval(g:pyindent_nested_paren) : shiftwidth())
                                    endif
                                    return indent(plnum) + (exists("g:pyindent_open_paren") ? eval(g:pyindent_open_paren) : (shiftwidth() * 2))
                                  endif
                                  if plnumstart == p
                                    return indent(plnum)
                                  endif
                                  return plindent
                                endif
                            
                              endif
                            
                            
                              " Get the line and remove a trailing comment.
                              " Use syntax highlighting attributes when possible.
                              let pline = getline(plnum)
                              let pline_len = strlen(pline)
                              if has('syntax_items')
                                " If the last character in the line is a comment, do a binary search for
                                " the start of the comment.  synID() is slow, a linear search would take
                                " too long on a long line.
                                if synIDattr(synID(plnum, pline_len, 1), "name") =~ "\\(Comment\\|Todo\\)$"
                                  let min = 1
                                  let max = pline_len
                                  while min < max
                            	let col = (min + max) / 2
                            	if synIDattr(synID(plnum, col, 1), "name") =~ "\\(Comment\\|Todo\\)$"
                            	  let max = col
                            	else
                            	  let min = col + 1
                            	endif
                                  endwhile
                                  let pline = strpart(pline, 0, min - 1)
                                endif
                              else
                                let col = 0
                                while col < pline_len
                                  if pline[col] == '#'
                            	let pline = strpart(pline, 0, col)
                            	break
                                  endif
                                  let col = col + 1
                                endwhile
                              endif
                            
                              " If the previous line ended with a colon, indent this line
                              if pline =~ ':\s*$'
                                return plindent + shiftwidth()
                              endif
                            
                              " If the previous line was a stop-execution statement...
                              if getline(plnum) =~ '^\s*\(break\|continue\|raise\|return\|pass\)\>'
                                " See if the user has already dedented
                                if s:Dedented(a:lnum, indent(plnum))
                                  " If so, trust the user
                                  return -1
                                endif
                                " If not, recommend one dedent
                                return indent(plnum) - shiftwidth()
                              endif
                            
                              " If the current line begins with a keyword that lines up with "try"
                              if getline(a:lnum) =~ '^\s*\(except\|finally\)\>'
                                let lnum = a:lnum - 1
                                while lnum >= 1
                                  if getline(lnum) =~ '^\s*\(try\|except\)\>'
                            	let ind = indent(lnum)
                            	if ind >= indent(a:lnum)
                            	  return -1	" indent is already less than this
                            	endif
                            	return ind	" line up with previous try or except
                                  endif
                                  let lnum = lnum - 1
                                endwhile
                                return -1		" no matching "try"!
                              endif
                            
                              " If the current line begins with a header keyword, dedent
                              if getline(a:lnum) =~ '^\s*\(elif\|else\)\>'
                            
                                " Unless the previous line was a one-liner
                                if getline(plnumstart) =~ '^\s*\(for\|if\|elif\|try\)\>'
                                  return plindent
                                endif
                            
                                " Or the user has already dedented
                                if s:Dedented(a:lnum, plindent)
                                  return -1
                                endif
                            
                                return plindent - shiftwidth()
                              endif
                            
                              " When after a () construct we probably want to go back to the start line.
                              " a = (b
                              "       + c)
                              " here
                              if parlnum > 0
                                " ...unless the user has already dedented
                                if s:Dedented(a:lnum, plindent)
                                    return -1
                                else
                                    return plindent
                                endif
                              endif
                            
                              return -1
                            
                            endfunction
                            
                            let &cpo = s:keepcpo
                            unlet s:keepcpo
                            
                            " vim:sw=2

SCRIPT  C:\Users\Lenovo\scoop\apps\neovim\0.6.1\share\nvim\runtime\ftplugin\vim.vim
Sourced 1 time
Total time:   0.001264
 Self time:   0.001264

count  total (s)   self (s)
                            " Vim filetype plugin
                            " Language:	Vim
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last Change:	2021 Apr 11
                            
                            " Only do this when not done yet for this buffer
    1              0.000020 if exists("b:did_ftplugin")
                              finish
    1              0.000002 endif
                            
                            " Don't load another plugin for this buffer
    1              0.000008 let b:did_ftplugin = 1
                            
    1              0.000013 let s:cpo_save = &cpo
    1              0.000016 set cpo&vim
                            
    1              0.000010 if !exists('*VimFtpluginUndo')
                              func VimFtpluginUndo()
                                setl fo< isk< com< tw< commentstring< keywordprg<
                                if exists('b:did_add_maps')
                                  silent! nunmap <buffer> [[
                                  silent! vunmap <buffer> [[
                                  silent! nunmap <buffer> ]]
                                  silent! vunmap <buffer> ]]
                                  silent! nunmap <buffer> []
                                  silent! vunmap <buffer> []
                                  silent! nunmap <buffer> ][
                                  silent! vunmap <buffer> ][
                                  silent! nunmap <buffer> ]"
                                  silent! vunmap <buffer> ]"
                                  silent! nunmap <buffer> ["
                                  silent! vunmap <buffer> ["
                                 endif
                                unlet! b:match_ignorecase b:match_words b:match_skip b:did_add_maps
                              endfunc
    1              0.000002 endif
                            
    1              0.000009 let b:undo_ftplugin = "call VimFtpluginUndo()"
                            
                            " Set 'formatoptions' to break comment lines but not other lines,
                            " and insert the comment leader when hitting <CR> or using "o".
    1              0.000018 setlocal fo-=t fo+=croql
                            
                            " To allow tag lookup via CTRL-] for autoload functions, '#' must be a
                            " keyword character.  E.g., for netrw#Nread().
    1              0.000068 setlocal isk+=#
                            
                            " Use :help to lookup the keyword under the cursor with K.
    1              0.000006 setlocal keywordprg=:help
                            
                            " if "\n" .. getline(1, 10)->join("\n") =~# '\n\s*vim9\%[script]\>'
    1              0.000054 if "\n" .. join(getline(1, 10), "\n") =~# '\n\s*vim9\%[script]\>'
                              " Set 'comments' to format dashed lists in comments
                              setlocal com=sO:#\ -,mO:#\ \ ,eO:##,:#
                              " Comments starts with # in Vim9 script
                              setlocal commentstring=#%s
    1              0.000002 else
    1              0.000013   setlocal com=sO:\"\ -,mO:\"\ \ ,eO:\"\",:\"
                              " Comments starts with a double quote in legacy script
    1              0.000006   setlocal commentstring=\"%s
    1              0.000002 endif
                            
                            
                            " Format comments to be up to 78 characters long
    1              0.000005 if &tw == 0
    1              0.000017   setlocal tw=78
    1              0.000002 endif
                            
                            " Prefer Vim help instead of manpages.
    1              0.000005 setlocal keywordprg=:help
                            
    1              0.000011 if !exists("no_plugin_maps") && !exists("no_vim_maps")
    1              0.000005   let b:did_add_maps = 1
                            
                              " Move around functions.
    1              0.000066   nnoremap <silent><buffer> [[ m':call search('^\s*\(fu\%[nction]\\|def\)\>', "bW")<CR>
    1              0.000066   vnoremap <silent><buffer> [[ m':<C-U>exe "normal! gv"<Bar>call search('^\s*\(fu\%[nction]\\|def\)\>', "bW")<CR>
    1              0.000046   nnoremap <silent><buffer> ]] m':call search('^\s*\(fu\%[nction]\\|def\)\>', "W")<CR>
    1              0.000061   vnoremap <silent><buffer> ]] m':<C-U>exe "normal! gv"<Bar>call search('^\s*\(fu\%[nction]\\|def\)\>', "W")<CR>
    1              0.000049   nnoremap <silent><buffer> [] m':call search('^\s*end\(f\%[unction]\\|def\)\>', "bW")<CR>
    1              0.000062   vnoremap <silent><buffer> [] m':<C-U>exe "normal! gv"<Bar>call search('^\s*end\(f\%[unction]\\|def\)\>', "bW")<CR>
    1              0.000055   nnoremap <silent><buffer> ][ m':call search('^\s*end\(f\%[unction]\\|def\)\>', "W")<CR>
    1              0.000062   vnoremap <silent><buffer> ][ m':<C-U>exe "normal! gv"<Bar>call search('^\s*end\(f\%[unction]\\|def\)\>', "W")<CR>
                            
                              " Move around comments
    1              0.000043   nnoremap <silent><buffer> ]" :call search('^\(\s*".*\n\)\@<!\(\s*"\)', "W")<CR>
    1              0.000060   vnoremap <silent><buffer> ]" :<C-U>exe "normal! gv"<Bar>call search('^\(\s*".*\n\)\@<!\(\s*"\)', "W")<CR>
    1              0.000043   nnoremap <silent><buffer> [" :call search('\%(^\s*".*\n\)\%(^\s*"\)\@!', "bW")<CR>
    1              0.000058   vnoremap <silent><buffer> [" :<C-U>exe "normal! gv"<Bar>call search('\%(^\s*".*\n\)\%(^\s*"\)\@!', "bW")<CR>
    1              0.000002 endif
                            
                            " Let the matchit plugin know what items can be matched.
    1              0.000007 if exists("loaded_matchit")
    1              0.000005   let b:match_ignorecase = 0
                              " "func" can also be used as a type:
                              "   var Ref: func
                              " or to list functions:
                              "   func name
                              " require a parenthesis following, then there can be an "endfunc".
    1              0.000064   let b:match_words =
                            	\ '\<\%(fu\%[nction]\|def\)!\=\s\+\S\+(:\%(\%(^\||\)\s*\)\@<=\<retu\%[rn]\>:\%(\%(^\||\)\s*\)\@<=\<\%(endf\%[unction]\|enddef\)\>,' .
                            	\ '\<\(wh\%[ile]\|for\)\>:\%(\%(^\||\)\s*\)\@<=\<brea\%[k]\>:\%(\%(^\||\)\s*\)\@<=\<con\%[tinue]\>:\%(\%(^\||\)\s*\)\@<=\<end\(w\%[hile]\|fo\%[r]\)\>,' .
                            	\ '\<if\>:\%(\%(^\||\)\s*\)\@<=\<el\%[seif]\>:\%(\%(^\||\)\s*\)\@<=\<en\%[dif]\>,' .
                            	\ '{:},' .
                            	\ '\<try\>:\%(\%(^\||\)\s*\)\@<=\<cat\%[ch]\>:\%(\%(^\||\)\s*\)\@<=\<fina\%[lly]\>:\%(\%(^\||\)\s*\)\@<=\<endt\%[ry]\>,' .
                            	\ '\<aug\%[roup]\s\+\%(END\>\)\@!\S:\<aug\%[roup]\s\+END\>,'
                              " Ignore syntax region commands and settings, any 'en*' would clobber
                              " if-endif.
                              " - set spl=de,en
                              " - au! FileType javascript syntax region foldBraces start=/{/ end=/}/ 
    1              0.000008   let b:match_skip = 'synIDattr(synID(line("."),col("."),1),"name")
                                    \ =~? "comment\\|string\\|vimSynReg\\|vimSet"'
    1              0.000001 endif
                            
    1              0.000013 let &cpo = s:cpo_save
    1              0.000005 unlet s:cpo_save
                            
                            " removed this, because 'cpoptions' is a global option.
                            " setlocal cpo+=M		" makes \%( match \)

SCRIPT  C:\Users\Lenovo\scoop\apps\neovim\0.6.1\share\nvim\runtime\syntax\vim\generated.vim
Sourced 1 time
Total time:   0.007038
 Self time:   0.007038

count  total (s)   self (s)
    1              0.003340 syn keyword vimCommand contained  a[ppend] ab[breviate] abc[lear] abo[veleft] al[l] am[enu] an[oremenu] ar[gs] arga[dd] argd[elete] argdo arge[dit] argg[lobal] argl[ocal] argu[ment] as[cii] aun[menu] b[uffer] bN[ext] ba[ll] bad[d] bal[t] bd[elete] be[have] bel[owright] bf[irst] bl[ast] bm[odified] bn[ext] bo[tright] bp[revious] br[ewind] brea[k] breaka[dd] breakd[el] breakl[ist] bro[wse] bu[ffers] bufd[o] bun[load] bw[ipeout] c[hange] cN[ext] cNf[ile] ca[bbrev] cabc[lear] cabo[ve] cad[dbuffer] cadde[xpr] caddf[ile] caf[ter] cal[l] cat[ch] cb[uffer] cbe[fore] cbel[ow] cbo[ttom] cc ccl[ose] cd cdo ce[nter] cex[pr] cf[ile] cfd[o] cfi[rst] cg[etfile] cgetb[uffer] cgete[xpr] ch[dir] cha[nges] che[ckhealth] checkp[ath] checkt[ime] chi[story] cl[ist] cla[st] clo[se] cle[arjumps] cm[ap] cmapc[lear] cme[nu] cn[ext] cnew[er] cnf[ile] cno[remap] cnorea[bbrev]
    1              0.000156 syn keyword vimCommand contained  cnorem[enu] co[py] col[der] colo[rscheme] com[mand] comc[lear] comp[iler] con[tinue] conf[irm] cons[t] cop[en] cp[revious] cpf[ile] cq[uit] cr[ewind] cs[cope] cst[ag] cu[nmap] cuna[bbrev] cunm[enu] cw[indow] d[elete] delm[arks] deb[ug] debugg[reedy] del[command] delf[unction] di[splay] dif[fupdate] diffg[et] diffo[ff] diffp[atch] diffpu[t] diffs[plit] difft[his] dig[raphs] dj[ump] dl[ist] dr[op] ds[earch] dsp[lit] e[dit] ea[rlier] ec[ho] echoe[rr] echoh[l] echom[sg] echon el[se] elsei[f] em[enu] en[dif] endf[unction] endfo[r] endt[ry] endw[hile] ene[w] ev[al] ex exe[cute] exi[t] exu[sage] f[ile] files filet[ype] filt[er] fin[d] fina[lly] fini[sh] fir[st] fo[ld] foldc[lose] foldd[oopen] folddoc[losed] foldo[pen] for fu[nction] g[lobal] go[to] gr[ep] grepa[dd] gu[i] gv[im] h[elp] helpc[lose] helpg[rep] helpt[ags]
    1              0.000174 syn keyword vimCommand contained  ha[rdcopy] hi[ghlight] hid[e] his[tory] i[nsert] ia[bbrev] iabc[lear] if ij[ump] il[ist] im[ap] imapc[lear] ime[nu] in[oremap] inorea[bbrev] inorem[enu] int[ro] is[earch] isp[lit] iu[nmap] iuna[bbrev] iunm[enu] j[oin] ju[mps] k ke[epmarks] keepj[umps] keepp[atterns] keepa[lt] l[ist] lN[ext] lNf[ile] la[st] lab[ove] lan[guage] lad[dexpr] laddb[uffer] laddf[ile] laf[ter] lat[er] lb[uffer] lbe[fore] lbel[ow] lbo[ttom] lc[d] lch[dir] lcl[ose] lcs[cope] ld[o] le[ft] lefta[bove] let lex[pr] lf[ile] lfd[o] lfi[rst] lg[etfile] lgetb[uffer] lgete[xpr] lgr[ep] lgrepa[dd] lh[elpgrep] lhi[story] ll lla[st] lli[st] lm[ap] lmapc[lear] lmak[e] ln[oremap] lne[xt] lnew[er] lnf[ile] lo[adview] loadk[eymap] loc[kmarks] lockv[ar] lol[der] lop[en] lp[revious] lpf[ile] lr[ewind] lt[ag] lu[nmap] lua luad[o] luaf[ile] lv[imgrep] lvimgrepa[dd]
    1              0.000274 syn keyword vimCommand contained  lw[indow] ls m[ove] ma[rk] mak[e] map mapc[lear] mar[ks] mat[ch] me[nu] menut[ranslate] mes[sages] mk[exrc] mks[ession] mksp[ell] mkv[imrc] mkvie[w] mo[de] mz[scheme] mzf[ile] n[ext] new nm[ap] nmapc[lear] nme[nu] nn[oremap] nnoreme[nu] no[remap] noa[utocmd] noh[lsearch] nor[eabbrev] norem[enu] nos[wapfile] nor[mal] nu[mber] nun[map] nunme[nu] o[ldfiles] om[ap] omapc[lear] ome[nu] on[ly] ono[remap] onoreme[nu] op[tions] ou[nmap] ounme[nu] ow[nsyntax] p[rint] pa[ckadd] packl[oadall] pc[lose] pe[rl] perld[o] perlf[ile] ped[it] po[p] popu[p] pp[op] pr[eserve] prev[ious] pro[file] profd[el] ps[earch] pt[ag] ptN[ext] ptf[irst] ptj[ump] ptl[ast] ptn[ext] ptp[revious] ptr[ewind] pts[elect] pu[t] pw[d] py[thon] pyd[o] pyf[ile] py3 py3d[o] pyt[hon3] py3[file] pyx pyxd[o] pyt[honx] pyx[file] q[uit] quita[ll] qa[ll] r[ead]
    1              0.000309 syn keyword vimCommand contained  rec[over] red[o] redi[r] redr[aw] redraws[tatus] redrawt[abline] reg[isters] res[ize] ret[ab] retu[rn] rew[ind] ri[ght] rightb[elow] rs[hada] ru[ntime] rund[o] rub[y] rubyd[o] rubyf[ile] rv[iminfo] s[ubstitute] sN[ext] sa[rgument] sal[l] san[dbox] sav[eas] sb[uffer] sbN[ext] sba[ll] sbf[irst] sbl[ast] sbm[odified] sbn[ext] sbp[revious] sbr[ewind] sc[riptnames] scripte[ncoding] scs[cope] se[t] setf[iletype] setg[lobal] setl[ocal] sf[ind] sfir[st] si[malt] sig[n] sil[ent] sl[eep] sla[st] sm[agic] smap smapc[lear] sme[nu] sn[ext] sno[magic] snor[emap] snoreme[nu] so[urce] sor[t] sp[lit] spe[llgood] spelld[ump] spelli[nfo] spellr[epall] spellra[re] spellu[ndo] spellw[rong] spr[evious] sr[ewind] st[op] sta[g] star[tinsert] startg[replace] startr[eplace] sto[pinsert] stj[ump] sts[elect] su[nhide] sunm[ap] sunme[nu]
    1              0.000160 syn keyword vimCommand contained  sus[pend] sv[iew] sw[apname] sy[ntax] synti[me] sync[bind] t tc[d] tch[dir] tN[ext] ta[g] tags tab tabc[lose] tabd[o] tabe[dit] tabf[ind] tabfir[st] tabm[ove] tabl[ast] tabn[ext] tabnew tabo[nly] tabp[revious] tabN[ext] tabr[ewind] tabs tc[l] tcld[o] tclf[ile] te[rminal] tf[irst] th[row] tj[ump] tl[ast] tm[enu] tma[p] tmapc[lear] tn[ext] tno[remap] to[pleft] tp[revious] tr[ewind] try ts[elect] tu[nmenu] tunma[p] u[ndo] undoj[oin] undol[ist] una[bbreviate] unh[ide] unl[et] unlo[ckvar] unm[ap] unme[nu] uns[ilent] up[date] v[global] ve[rsion] verb[ose] vert[ical] vi[sual] vie[w] vim[grep] vimgrepa[dd] viu[sage] vm[ap] vmapc[lear] vme[nu] vn[oremap] vne[w] vno[remenu] vs[plit] vu[nmap] vunme[nu] w[rite] wN[ext] wa[ll] wh[ile] wi[nsize] winc[md] wind[o] winp[os] wn[ext] wp[revious] wq wqa[ll] ws[hada] wu[ndo] wv[iminfo]
    1              0.000018 syn keyword vimCommand contained  x[it] xa[ll] xm[ap] xmapc[lear] xme[nu] xn[oremap] xnoreme[nu] xu[nmap] xunme[nu] y[ank] N[ext]
                            
    1              0.000100 syn keyword vimOption contained  aleph al arabic arab invarabic noarabic invarab noarab arabicshape arshape invarabicshape noarabicshape invarshape noarshape allowrevins ari invallowrevins noallowrevins invari noari ambiwidth ambw autochdir acd invautochdir noautochdir invacd noacd autoindent ai invautoindent noautoindent invai noai autoread ar invautoread noautoread invar noar autowrite aw invautowrite noautowrite invaw noaw autowriteall awa invautowriteall noautowriteall invawa noawa background bg backspace bs backup bk invbackup nobackup invbk nobk backupcopy bkc backupdir bdir backupext bex backupskip bsk belloff bo binary bin invbinary nobinary invbin nobin bomb invbomb nobomb breakat brk breakindent bri invbreakindent nobreakindent invbri nobri breakindentopt briopt browsedir bsdir bufhidden bh buflisted bl invbuflisted nobuflisted invbl nobl
    1              0.000220 syn keyword vimOption contained  buftype bt casemap cmp cdpath cd cedit channel charconvert ccv cindent cin invcindent nocindent invcin nocin cinkeys cink cinoptions cino cinwords cinw clipboard cb cmdheight ch cmdwinheight cwh colorcolumn cc columns co comments com commentstring cms complete cpt concealcursor cocu conceallevel cole completefunc cfu completeopt cot completeslash csl confirm cf invconfirm noconfirm invcf nocf copyindent ci invcopyindent nocopyindent invci noci cpoptions cpo cscopepathcomp cspc cscopeprg csprg cscopequickfix csqf cscoperelative csre invcscoperelative nocscoperelative invcsre nocsre cscopetag cst invcscopetag nocscopetag invcst nocst cscopetagorder csto cscopeverbose csverb invcscopeverbose nocscopeverbose invcsverb nocsverb cursorbind crb invcursorbind nocursorbind invcrb nocrb cursorcolumn cuc invcursorcolumn nocursorcolumn invcuc nocuc
    1              0.000171 syn keyword vimOption contained  cursorline cul invcursorline nocursorline invcul nocul cursorlineopt culopt debug define def delcombine deco invdelcombine nodelcombine invdeco nodeco dictionary dict diff invdiff nodiff diffexpr dex diffopt dip digraph dg invdigraph nodigraph invdg nodg directory dir display dy eadirection ead emoji emo invemoji noemoji invemo noemo encoding enc endofline eol invendofline noendofline inveol noeol equalalways ea invequalalways noequalalways invea noea equalprg ep errorbells eb inverrorbells noerrorbells inveb noeb errorfile ef errorformat efm eventignore ei expandtab et invexpandtab noexpandtab invet noet exrc ex invexrc noexrc invex noex fileencoding fenc fileencodings fencs fileformat ff fileformats ffs fileignorecase fic invfileignorecase nofileignorecase invfic nofic filetype ft fillchars fcs fixendofline fixeol invfixendofline nofixendofline invfixeol nofixeol
    1              0.000130 syn keyword vimOption contained  foldclose fcl foldcolumn fdc foldenable fen invfoldenable nofoldenable invfen nofen foldexpr fde foldignore fdi foldlevel fdl foldlevelstart fdls foldmarker fmr foldmethod fdm foldminlines fml foldnestmax fdn foldopen fdo foldtext fdt formatexpr fex formatoptions fo formatlistpat flp formatprg fp fsync fs invfsync nofsync invfs nofs gdefault gd invgdefault nogdefault invgd nogd grepformat gfm grepprg gp guicursor gcr guifont gfn guifontwide gfw guioptions go guitablabel gtl guitabtooltip gtt helpfile hf helpheight hh helplang hlg hidden hid invhidden nohidden invhid nohid highlight hl history hi hkmap hk invhkmap nohkmap invhk nohk hkmapp hkp invhkmapp nohkmapp invhkp nohkp hlsearch hls invhlsearch nohlsearch invhls nohls icon invicon noicon iconstring ignorecase ic invignorecase noignorecase invic noic imcmdline imc invimcmdline noimcmdline invimc noimc
    1              0.000141 syn keyword vimOption contained  imdisable imd invimdisable noimdisable invimd noimd iminsert imi imsearch ims inccommand icm include inc includeexpr inex incsearch is invincsearch noincsearch invis nois indentexpr inde indentkeys indk infercase inf invinfercase noinfercase invinf noinf insertmode im invinsertmode noinsertmode invim noim isfname isf isident isi iskeyword isk isprint isp joinspaces js invjoinspaces nojoinspaces invjs nojs jumpoptions jop keymap kmp keymodel km keywordprg kp langmap lmap langmenu lm langnoremap lnr invlangnoremap nolangnoremap invlnr nolnr langremap lrm invlangremap nolangremap invlrm nolrm laststatus ls lazyredraw lz invlazyredraw nolazyredraw invlz nolz linebreak lbr invlinebreak nolinebreak invlbr nolbr lines linespace lsp lisp invlisp nolisp lispwords lw list invlist nolist listchars lcs loadplugins lpl invloadplugins noloadplugins invlpl nolpl
    1              0.000126 syn keyword vimOption contained  magic invmagic nomagic makeef mef makeencoding menc makeprg mp matchpairs mps matchtime mat maxcombine mco maxfuncdepth mfd maxmapdepth mmd maxmempattern mmp menuitems mis mkspellmem msm modeline ml invmodeline nomodeline invml noml modelineexpr mle invmodelineexpr nomodelineexpr invmle nomle modelines mls modifiable ma invmodifiable nomodifiable invma noma modified mod invmodified nomodified invmod nomod more invmore nomore mouse mousefocus mousef invmousefocus nomousefocus invmousef nomousef mousehide mh invmousehide nomousehide invmh nomh mousemodel mousem mouseshape mouses mousetime mouset nrformats nf number nu invnumber nonumber invnu nonu numberwidth nuw omnifunc ofu opendevice odev invopendevice noopendevice invodev noodev operatorfunc opfunc packpath pp paragraphs para paste invpaste nopaste pastetoggle pt
    1              0.000118 syn keyword vimOption contained  patchexpr pex patchmode pm path pa preserveindent pi invpreserveindent nopreserveindent invpi nopi previewheight pvh previewwindow pvw invpreviewwindow nopreviewwindow invpvw nopvw printdevice pdev printencoding penc printexpr pexpr printfont pfn printheader pheader printmbcharset pmbcs printmbfont pmbfn printoptions popt pumblend pb pumheight ph pumwidth pw pyxversion pyx quickfixtextfunc qftf quoteescape qe readonly ro invreadonly noreadonly invro noro redrawdebug rdb redrawtime rdt regexpengine re relativenumber rnu invrelativenumber norelativenumber invrnu nornu remap invremap noremap report revins ri invrevins norevins invri nori rightleft rl invrightleft norightleft invrl norl rightleftcmd rlc ruler ru invruler noruler invru noru rulerformat ruf runtimepath rtp scroll scr scrollback scbk scrollbind scb invscrollbind noscrollbind invscb noscb
    1              0.000108 syn keyword vimOption contained  scrolljump sj scrolloff so scrollopt sbo sections sect secure invsecure nosecure selection sel selectmode slm sessionoptions ssop shada sd shadafile sdf shell sh shellcmdflag shcf shellpipe sp shellquote shq shellredir srr shellslash ssl invshellslash noshellslash invssl nossl shelltemp stmp invshelltemp noshelltemp invstmp nostmp shellxquote sxq shellxescape sxe shiftround sr invshiftround noshiftround invsr nosr shiftwidth sw shortmess shm showbreak sbr showcmd sc invshowcmd noshowcmd invsc nosc showfulltag sft invshowfulltag noshowfulltag invsft nosft showmatch sm invshowmatch noshowmatch invsm nosm showmode smd invshowmode noshowmode invsmd nosmd showtabline stal sidescroll ss sidescrolloff siso signcolumn scl smartcase scs invsmartcase nosmartcase invscs noscs smartindent si invsmartindent nosmartindent invsi nosi
    1              0.000181 syn keyword vimOption contained  smarttab sta invsmarttab nosmarttab invsta nosta softtabstop sts spell invspell nospell spellcapcheck spc spellfile spf spelllang spl spellsuggest sps spelloptions spo splitbelow sb invsplitbelow nosplitbelow invsb nosb splitright spr invsplitright nosplitright invspr nospr startofline sol invstartofline nostartofline invsol nosol statusline stl suffixes su suffixesadd sua swapfile swf invswapfile noswapfile invswf noswf switchbuf swb synmaxcol smc syntax syn tagfunc tfu tabline tal tabpagemax tpm tabstop ts tagbsearch tbs invtagbsearch notagbsearch invtbs notbs tagcase tc taglength tl tagrelative tr invtagrelative notagrelative invtr notr tags tag tagstack tgst invtagstack notagstack invtgst notgst termbidi tbidi invtermbidi notermbidi invtbidi notbidi termencoding tenc termguicolors tgc invtermguicolors notermguicolors invtgc notgc
    1              0.000107 syn keyword vimOption contained  termpastefilter tpf terse invterse noterse textwidth tw thesaurus tsr thesaurusfunc tsrfu tildeop top invtildeop notildeop invtop notop timeout to invtimeout notimeout invto noto timeoutlen tm title invtitle notitle titlelen titleold titlestring ttimeout invttimeout nottimeout ttimeoutlen ttm undodir udir undofile udf invundofile noundofile invudf noudf undolevels ul undoreload ur updatecount uc updatetime ut varsofttabstop vsts vartabstop vts verbose vbs verbosefile vfile viewdir vdir viewoptions vop viminfo vi viminfofile vif virtualedit ve visualbell vb invvisualbell novisualbell invvb novb warn invwarn nowarn whichwrap ww wildchar wc wildcharm wcm wildignore wig wildignorecase wic invwildignorecase nowildignorecase invwic nowic wildmenu wmnu invwildmenu nowildmenu invwmnu nowmnu wildmode wim wildoptions wop
    1              0.000045 syn keyword vimOption contained  winaltkeys wak winblend winbl winhighlight winhl window wi winheight wh winfixheight wfh invwinfixheight nowinfixheight invwfh nowfh winfixwidth wfw invwinfixwidth nowinfixwidth invwfw nowfw winminheight wmh winminwidth wmw winwidth wiw wrap invwrap nowrap wrapmargin wm wrapscan ws invwrapscan nowrapscan invws nows write invwrite nowrite writeany wa invwriteany nowriteany invwa nowa writebackup wb invwritebackup nowritebackup invwb nowb writedelay wd
                            
    1              0.000006 syn case ignore
                            
    1              0.000106 syn keyword vimAutoEvent contained  BufAdd BufDelete BufEnter BufFilePost BufFilePre BufHidden BufLeave BufNew BufNewFile BufReadCmd BufReadPost BufReadPre BufUnload BufWinEnter BufWinLeave BufWipeout BufWriteCmd BufWritePost BufWritePre ChanInfo ChanOpen CmdUndefined CmdWinEnter CmdWinLeave CmdlineChanged CmdlineEnter CmdlineLeave ColorScheme ColorSchemePre CompleteChanged CompleteDone CompleteDonePre CursorHold CursorHoldI CursorMoved CursorMovedI DiffUpdated EncodingChanged ExitPre FileAppendCmd FileAppendPost FileAppendPre FileChangedRO FileChangedShell FileChangedShellPost FileReadCmd FileReadPost FileReadPre FileType FileWriteCmd FileWritePost FileWritePre FilterReadPost FilterReadPre FilterWritePost FilterWritePre FocusGained FocusLost FuncUndefined GUIEnter GUIFailed InsertChange InsertCharPre InsertEnter InsertLeave InsertLeavePre
    1              0.000069 syn keyword vimAutoEvent contained  MenuPopup OptionSet QuickFixCmdPost QuickFixCmdPre QuitPre RemoteReply SessionLoadPost ShellCmdPost ShellFilterPost SourceCmd SourcePost SourcePre SpellFileMissing StdinReadPost StdinReadPre SwapExists Syntax TabEnter TabLeave TermChanged TermEnter TermLeave TermResponse TextChanged TextChangedI TextChangedP TextYankPost User VimEnter VimLeave VimLeavePre VimResized VimResume VimSuspend WinEnter WinLeave WinNew FileEncoding BufCreate BufRead BufWrite
                            
    1              0.000020 syn keyword nvimAutoEvent contained  TermOpen DirChanged DiagnosticChanged UIEnter TabClosed BufModifiedSet UILeave TabNew TabNewEntered WinScrolled TermClose Signal WinClosed
                            
    1              0.000006 syn case match
                            
    1              0.000118 syn keyword vimFuncName contained  sign_getdefined sign_getplaced sign_jump execute rename sign_unplace getenv simplify nvim_tabpage_get_number sockconnect soundfold len spellbadword reverse confirm and match function abs floor ceil sqrt log10 exp sin cos tan asin acos atan sinh cosh tanh log search atan2 pow fmod type extend expand foldlevel chdir foldtext copy delete split swapname byte2line eval byteidxcomp changenr chanclose chansend char2nr charidx clearmatches col filter complete_check winwidth count cscope_connection ctxget ctxpop ctxpush ctxset ctxsize cursor debugbreak deepcopy deletebufline dictwatcheradd dictwatcherdel did_filetype diff_filler diff_hlID empty environ escape eventhandler executable exepath exists json_decode expandcmd feedkeys file_readable line filereadable filewritable finddir findfile flatten float2nr maparg mapcheck
    1              0.000082 syn keyword vimFuncName contained  matchadd matchaddpos matcharg matchdelete matchend matchlist matchstr matchstrpos menu_get mkdir msgpackdump msgpackparse nextnonblank nr2char pathshorten prevnonblank printf prompt_getprompt prompt_setcallback prompt_setinterrupt prompt_setprompt pum_getpos pumvisible py3eval pyeval pyxeval perleval range readdir readfile reg_executing reg_recording reltime nvim_parse_expression nvim_open_win nvim_win_set_config nvim_win_get_config nvim_win_get_buf shiftwidth nvim_win_set_buf nvim_win_get_cursor nvim_win_set_cursor nvim_win_get_height nvim_win_set_height nvim_win_get_width nvim_win_set_width nvim_win_get_var nvim_win_set_var nvim_win_del_var nvim_win_get_option nvim_win_set_option nvim_win_get_position nvim_win_get_tabpage nvim_win_get_number nvim_win_is_valid nvim_win_hide nvim_win_close nvim_call_dict_function
    1              0.000076 syn keyword vimFuncName contained  nvim_eval nvim_command nvim_exec nvim_eval_statusline nvim_get_mark nvim_del_mark nvim__screenshot nvim__inspect_cell nvim_select_popupmenu_item nvim_get_proc nvim_get_proc_children nvim_list_uis nvim__id_float nvim_buf_del_extmark nvim_buf_add_highlight nvim_tabpage_set_var nvim_tabpage_del_var line2byte libcallnr nvim_get_hl_by_id nvim_get_hl_id_by_name nvim_set_hl nvim_feedkeys sign_placelist nvim_strwidth nvim_get_runtime_file nvim_set_vvar substitute nvim_set_option nvim_out_write nvim_del_current_line nvim_get_current_line sha256 nvim_list_runtime_paths nvim_notify nvim_replace_termcodes nvim_input_mouse nvim__set_hl_ns nvim__get_hl_defs nvim_tabpage_get_var nvim_tabpage_list_wins nvim_buf_clear_namespace stdpath str2float str2list str2nr strcharpart strchars strdisplaywidth strftime strgetchar stridx
    1              0.000102 syn keyword vimFuncName contained  strlen strpart strptime fnameescape fnamemodify foldclosed foldclosedend foldtextresult foreground funcref garbagecollect get getbufinfo getbufline getbufvar getchangelist getchar getcharmod getcharsearch getcharstr getcmdline getcmdpos getcmdtype getcmdwintype getcompletion getcurpos getcwd spellsuggest getfperm getfsize getftime getftype getjumplist getloclist getmarklist getmatches getmousepos getpid getpos getqflist getreg getreginfo getregtype gettabinfo gettabvar gettabwinvar gettagstack getwininfo getwinpos getwinposx getwinposy getwinvar glob glob2regpat globpath has has_key hasmapto highlightID highlight_exists winsaveview histadd histdel histget histnr hlID hlexists hostname iconv indent index inputdialog tr append stdioopen sign_unplacelist sign_undefine sign_place nvim_buf_get_offset or string
    1              0.000151 syn keyword vimFuncName contained  setwinvar nvim_buf_del_keymap undofile settabwinvar getfontname inputsave byteidx complete_add complete_info browse nvim_get_chan_info setline setfperm setenv setcmdpos setcharsearch setbufvar setbufline serverstop serverstart serverlist searchpos nvim_buf_set_keymap repeat buflisted browsedir max nvim_get_hl_by_name buffer_number nvim_set_var map inputlist inputrestore call inputsecret interrupt invert nvim_tabpage_get_win nvim_put nvim_get_color_by_name nvim_get_color_map nvim_tabpage_is_valid nvim_get_context nvim_buf_attach nvim_load_context nvim__buf_redraw_range nvim_get_mode nvim_buf_get_lines nvim_del_keymap nvim_buf_set_lines cindent nvim_list_chans bufexists nvim_buf_set_extmark nvim__id nvim_buf_get_extmarks nvim__id_array api_info appendbufline nvim_get_namespaces argc nvim_create_namespace nvim__id_dictionary
    1              0.000085 syn keyword vimFuncName contained  nvim_buf_get_name arglistid nvim_buf_set_option argv nvim_buf_del_var nvim__stats nvim_buf_set_var assert_beeps nvim_buf_get_changedtick nvim_buf_get_commands nvim_buf_get_var nvim_buf_get_option winheight nvim_buf_set_name nvim_buf_set_text nvim_buf_is_loaded nvim_buf_line_count nvim_buf_delete xor writefile winrestview winrestcmd winnr winline winlayout argidx wincol winbufnr win_splitmove win_screenpos nvim_buf_get_extmark_by_id nvim_set_current_dir nvim_buf_get_keymap nvim__buf_stats wordcount getline haslocaldir isdirectory isinf islocked isnan id items jobclose assert_equal jobpid jobresize jobsend assert_fails jobstart jobstop jobwait json_encode keys last_buffer_nr libcall lispindent list2str localtime luaeval nvim__runtime_inspect nvim_err_write strridx strtrans strwidth submatch swapinfo synID synIDattr
    1              0.000091 syn keyword vimFuncName contained  synIDtrans synconcealed synstack system systemlist tabpagebuflist tabpagenr tabpagewinnr tagfiles taglist tempname termopen test_garbagecollect_now test_write_list_log timer_info timer_pause timer_start timer_stop timer_stopall tolower toupper trim trunc assert_exception nvim_input assert_equalfile undotree uniq values virtcol visualmode wait wildmenumode win_execute win_findbuf win_getid win_gettype win_gotoid win_id2tabwin win_id2win reltimefloat reltimestr resolve round add windowsversion rpcnotify rpcrequest rpcstart rpcstop rubyeval screenattr screenchar screenchars screencol screenpos screenrow screenstring searchcount searchdecl searchpair searchpairpos assert_false assert_inrange assert_match assert_nobeep assert_notequal assert_notmatch assert_report assert_true bufadd join buffer_exists setloclist
    1              0.000069 syn keyword vimFuncName contained  nvim_call_function nvim_get_commands buffer_name nvim_set_keymap mode nvim_get_keymap bufload bufloaded bufname bufnr bufwinid bufwinnr nvim_paste nvim_set_current_tabpage nvim_get_current_tabpage nvim_list_tabpages nvim_open_term nvim_create_buf nvim_set_current_win nvim_get_current_win nvim_list_wins nvim_set_current_buf nvim_get_current_buf nvim_list_bufs nvim_err_writeln nvim_buf_set_virtual_text min nvim_echo nvim_buf_clear_highlight nvim_get_option_info nvim_get_all_options_info nvim_get_option nvim_buf_get_number nvim_get_vvar nvim_del_var insert remove nvim_get_var nvim_command_output sort nvim_set_current_line nvim__get_runtime nvim_buf_get_mark nvim__get_lib_dir nvim_buf_set_mark nvim_buf_del_mark nvim_buf_is_valid setmatches setpos setqflist setreg settabvar complete settagstack input shellescape
    1              0.000038 syn keyword vimFuncName contained  sign_define

SCRIPT  C:\Users\Lenovo\scoop\apps\neovim\0.6.1\share\nvim\runtime\indent\vim.vim
Sourced 1 time
Total time:   0.000147
 Self time:   0.000147

count  total (s)   self (s)
                            " Vim indent file
                            " Language:	Vim script
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last Change:	2021 Nov 03
                            
                            " Only load this indent file when no other was loaded.
    1              0.000014 if exists("b:did_indent")
                              finish
    1              0.000002 endif
    1              0.000007 let b:did_indent = 1
                            
    1              0.000014 setlocal indentexpr=GetVimIndent()
    1              0.000010 setlocal indentkeys+==end,=},=else,=cat,=finall,=END,0\\,0=\"\\\ 
    1              0.000006 setlocal indentkeys-=0#
                            
    1              0.000006 let b:undo_indent = "setl indentkeys< indentexpr<"
                            
                            " Only define the function once.
    1              0.000008 if exists("*GetVimIndent")
    1              0.000002   finish
                            endif
                            let s:keepcpo= &cpo
                            set cpo&vim
                            
                            function GetVimIndent()
                              let ignorecase_save = &ignorecase
                              try
                                let &ignorecase = 0
                                return GetVimIndentIntern()
                              finally
                                let &ignorecase = ignorecase_save
                              endtry
                            endfunc
                            
                            let s:lineContPat = '^\s*\(\\\|"\\ \)'
                            
                            function GetVimIndentIntern()
                              " Find a non-blank line above the current line.
                              let lnum = prevnonblank(v:lnum - 1)
                            
                              " The previous line, ignoring line continuation
                              let prev_text_end = lnum > 0 ? getline(lnum) : ''
                            
                              " If the current line doesn't start with '\' or '"\ ' and below a line that
                              " starts with '\' or '"\ ', use the indent of the line above it.
                              let cur_text = getline(v:lnum)
                              if cur_text !~ s:lineContPat
                                while lnum > 0 && getline(lnum) =~ s:lineContPat
                                  let lnum = lnum - 1
                                endwhile
                              endif
                            
                              " At the start of the file use zero indent.
                              if lnum == 0
                                return 0
                              endif
                            
                              " the start of the previous line, skipping over line continuation
                              let prev_text = getline(lnum)
                              let found_cont = 0
                            
                              " Add a 'shiftwidth' after :if, :while, :try, :catch, :finally, :function
                              " and :else.  Add it three times for a line that starts with '\' or '"\ '
                              " after a line that doesn't (or g:vim_indent_cont if it exists).
                              let ind = indent(lnum)
                            
                              " In heredoc indenting works completely differently.
                              if has('syntax_items') 
                                let syn_here = synIDattr(synID(v:lnum, 1, 1), "name")
                                if syn_here =~ 'vimLetHereDocStop'
                                  " End of heredoc: use indent of matching start line
                                  let lnum = v:lnum - 1
                                  while lnum > 0
                            	let attr = synIDattr(synID(lnum, 1, 1), "name")
                            	if attr != '' && attr !~ 'vimLetHereDoc'
                            	  return indent(lnum)
                            	endif
                            	let lnum -= 1
                                  endwhile
                                  return 0
                                endif
                                if syn_here =~ 'vimLetHereDoc'
                                  if synIDattr(synID(lnum, 1, 1), "name") !~ 'vimLetHereDoc'
                            	" First line in heredoc: increase indent
                            	return ind + shiftwidth()
                                  endif
                                  " Heredoc continues: no change in indent
                                  return ind
                                endif
                              endif
                            
                              if cur_text =~ s:lineContPat && v:lnum > 1 && prev_text !~ s:lineContPat
                                let found_cont = 1
                                if exists("g:vim_indent_cont")
                                  let ind = ind + g:vim_indent_cont
                                else
                                  let ind = ind + shiftwidth() * 3
                                endif
                              elseif prev_text =~ '^\s*aug\%[roup]\s\+' && prev_text !~ '^\s*aug\%[roup]\s\+[eE][nN][dD]\>'
                                let ind = ind + shiftwidth()
                              else
                                " A line starting with :au does not increment/decrement indent.
                                " A { may start a block or a dict.  Assume that when a } follows it's a
                                " terminated dict.
                                if prev_text !~ '^\s*au\%[tocmd]' && prev_text !~ '^\s*{.*}'
                                  let i = match(prev_text, '\(^\||\)\s*\(export\s\+\)\?\({\|\(if\|wh\%[ile]\|for\|try\|cat\%[ch]\|fina\|finall\%[y]\|fu\%[nction]\|def\|el\%[seif]\)\>\)')
                                  if i >= 0
                            	let ind += shiftwidth()
                            	if strpart(prev_text, i, 1) == '|' && has('syntax_items')
                            	      \ && synIDattr(synID(lnum, i, 1), "name") =~ '\(Comment\|String\|PatSep\)$'
                            	  let ind -= shiftwidth()
                            	endif
                                  endif
                                endif
                              endif
                            
                              " If the previous line contains an "end" after a pipe, but not in an ":au"
                              " command.  And not when there is a backslash before the pipe.
                              " And when syntax HL is enabled avoid a match inside a string.
                              let i = match(prev_text, '[^\\]|\s*\(ene\@!\)')
                              if i > 0 && prev_text !~ '^\s*au\%[tocmd]'
                                if !has('syntax_items') || synIDattr(synID(lnum, i + 2, 1), "name") !~ '\(Comment\|String\)$'
                                  let ind = ind - shiftwidth()
                                endif
                              endif
                            
                              " For a line starting with "}" find the matching "{".  If it is at the start
                              " of the line align with it, probably end of a block.
                              " Use the mapped "%" from matchit to find the match, otherwise we may match
                              " a { inside a comment or string.
                              if cur_text =~ '^\s*}'
                                if maparg('%') != ''
                                  exe v:lnum
                                  silent! normal %
                                  if line('.') < v:lnum && getline('.') =~ '^\s*{'
                            	let ind = indent('.')
                                  endif
                                else
                                  " todo: use searchpair() to find a match
                                endif
                              endif
                            
                              " Below a line starting with "}" find the matching "{".  If it is at the
                              " end of the line we must be below the end of a dictionary.
                              if prev_text =~ '^\s*}'
                                if maparg('%') != ''
                                  exe lnum
                                  silent! normal %
                                  if line('.') == lnum || getline('.') !~ '^\s*{'
                            	let ind = ind - shiftwidth()
                                  endif
                                else
                                  " todo: use searchpair() to find a match
                                endif
                              endif
                            
                              " Below a line starting with "]" we must be below the end of a list.
                              " Include a "}" and "},} in case a dictionary ends too.
                              if prev_text_end =~ '^\s*\(},\=\s*\)\=]'
                                let ind = ind - shiftwidth()
                              endif
                            
                              let ends_in_comment = has('syntax_items')
                            	\ && synIDattr(synID(lnum, len(getline(lnum)), 1), "name") =~ '\(Comment\|String\)$'
                            
                              " A line ending in "{" or "[" is most likely the start of a dict/list literal,
                              " indent the next line more.  Not for a continuation line or {{{.
                              if !ends_in_comment && prev_text_end =~ '\s[{[]\s*$' && !found_cont
                                let ind = ind + shiftwidth()
                              endif
                            
                              " Subtract a 'shiftwidth' on a :endif, :endwhile, :catch, :finally, :endtry,
                              " :endfun, :else and :augroup END.
                              if cur_text =~ '^\s*\(ene\@!\|cat\|finall\|el\|aug\%[roup]\s\+[eE][nN][dD]\)'
                                let ind = ind - shiftwidth()
                              endif
                            
                              return ind
                            endfunction
                            
                            let &cpo = s:keepcpo
                            unlet s:keepcpo
                            
                            " vim:sw=2

SCRIPT  C:\Users\Lenovo\scoop\apps\neovim\0.6.1\share\nvim\runtime\scripts.vim
Sourced 2 times
Total time:   0.007378
 Self time:   0.007378

count  total (s)   self (s)
                            " Vim support file to detect file types in scripts
                            "
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last change:	2021 Jan 22
                            
                            " This file is called by an autocommand for every file that has just been
                            " loaded into a buffer.  It checks if the type of file can be recognized by
                            " the file contents.  The autocommand is in $VIMRUNTIME/filetype.vim.
                            "
                            " Note that the pattern matches are done with =~# to avoid the value of the
                            " 'ignorecase' option making a difference.  Where case is to be ignored use
                            " =~? instead.  Do not use =~ anywhere.
                            
                            
                            " Only do the rest when the FileType autocommand has not been triggered yet.
    2              0.000068 if did_filetype()
                              finish
    2              0.000008 endif
                            
                            " Load the user defined scripts file first
                            " Only do this when the FileType autocommand has not been triggered yet
    2              0.000057 if exists("myscriptsfile") && filereadable(expand(myscriptsfile))
                              execute "source " . myscriptsfile
                              if did_filetype()
                                finish
                              endif
    2              0.000005 endif
                            
                            " Line continuation is used here, remove 'C' from 'cpoptions'
    2              0.000101 let s:cpo_save = &cpo
    2              0.000075 set cpo&vim
                            
    2              0.000046 let s:line1 = getline(1)
                            
    2              0.000064 if s:line1 =~# "^#!"
                              " A script that starts with "#!".
                            
                              " Check for a line like "#!/usr/bin/env {options} bash".  Turn it into
                              " "#!/usr/bin/bash" to make matching easier.
                              " Recognize only a few {options} that are commonly used.
                              if s:line1 =~# '^#!\s*\S*\<env\s'
                                let s:line1 = substitute(s:line1, '\S\+=\S\+', '', 'g')
                                let s:line1 = substitute(s:line1, '\(-[iS]\|--ignore-environment\|--split-string\)', '', '')
                                let s:line1 = substitute(s:line1, '\<env\s\+', '', '')
                              endif
                            
                              " Get the program name.
                              " Only accept spaces in PC style paths: "#!c:/program files/perl [args]".
                              " If the word env is used, use the first word after the space:
                              " "#!/usr/bin/env perl [path/args]"
                              " If there is no path use the first word: "#!perl [path/args]".
                              " Otherwise get the last word after a slash: "#!/usr/bin/perl [path/args]".
                              if s:line1 =~# '^#!\s*\a:[/\\]'
                                let s:name = substitute(s:line1, '^#!.*[/\\]\(\i\+\).*', '\1', '')
                              elseif s:line1 =~# '^#!.*\<env\>'
                                let s:name = substitute(s:line1, '^#!.*\<env\>\s\+\(\i\+\).*', '\1', '')
                              elseif s:line1 =~# '^#!\s*[^/\\ ]*\>\([^/\\]\|$\)'
                                let s:name = substitute(s:line1, '^#!\s*\([^/\\ ]*\>\).*', '\1', '')
                              else
                                let s:name = substitute(s:line1, '^#!\s*\S*[/\\]\(\i\+\).*', '\1', '')
                              endif
                            
                              " tcl scripts may have #!/bin/sh in the first line and "exec wish" in the
                              " third line.  Suggested by Steven Atkinson.
                              if getline(3) =~# '^exec wish'
                                let s:name = 'wish'
                              endif
                            
                              " Bourne-like shell scripts: bash bash2 ksh ksh93 sh
                              if s:name =~# '^\(bash\d*\|\|ksh\d*\|sh\)\>'
                                call dist#ft#SetFileTypeSH(s:line1)	" defined in filetype.vim
                            
                                " csh scripts
                              elseif s:name =~# '^csh\>'
                                if exists("g:filetype_csh")
                                  call dist#ft#SetFileTypeShell(g:filetype_csh)
                                else
                                  call dist#ft#SetFileTypeShell("csh")
                                endif
                            
                                " tcsh scripts
                              elseif s:name =~# '^tcsh\>'
                                call dist#ft#SetFileTypeShell("tcsh")
                            
                                " Z shell scripts
                              elseif s:name =~# '^zsh\>'
                                set ft=zsh
                            
                                " TCL scripts
                              elseif s:name =~# '^\(tclsh\|wish\|expectk\|itclsh\|itkwish\)\>'
                                set ft=tcl
                            
                                " Expect scripts
                              elseif s:name =~# '^expect\>'
                                set ft=expect
                            
                                " Gnuplot scripts
                              elseif s:name =~# '^gnuplot\>'
                                set ft=gnuplot
                            
                                " Makefiles
                              elseif s:name =~# 'make\>'
                                set ft=make
                            
                                " Pike
                              elseif s:name =~# '^pike\%(\>\|[0-9]\)'
                                set ft=pike
                            
                                " Lua
                              elseif s:name =~# 'lua'
                                set ft=lua
                            
                                " Perl
                              elseif s:name =~# 'perl'
                                set ft=perl
                            
                                " PHP
                              elseif s:name =~# 'php'
                                set ft=php
                            
                                " Python
                              elseif s:name =~# 'python'
                                set ft=python
                            
                                " Groovy
                              elseif s:name =~# '^groovy\>'
                                set ft=groovy
                            
                                " Raku
                              elseif s:name =~# 'raku'
                                set ft=raku
                            
                                " Ruby
                              elseif s:name =~# 'ruby'
                                set ft=ruby
                            
                                " JavaScript
                              elseif s:name =~# 'node\(js\)\=\>\|js\>' || s:name =~# 'rhino\>'
                                set ft=javascript
                            
                                " BC calculator
                              elseif s:name =~# '^bc\>'
                                set ft=bc
                            
                                " sed
                              elseif s:name =~# 'sed\>'
                                set ft=sed
                            
                                " OCaml-scripts
                              elseif s:name =~# 'ocaml'
                                set ft=ocaml
                            
                                " Awk scripts; also finds "gawk"
                              elseif s:name =~# 'awk\>'
                                set ft=awk
                            
                                " Website MetaLanguage
                              elseif s:name =~# 'wml'
                                set ft=wml
                            
                                " Scheme scripts
                              elseif s:name =~# 'scheme'
                                set ft=scheme
                            
                                " CFEngine scripts
                              elseif s:name =~# 'cfengine'
                                set ft=cfengine
                            
                                " Erlang scripts
                              elseif s:name =~# 'escript'
                                set ft=erlang
                            
                                " Haskell
                              elseif s:name =~# 'haskell'
                                set ft=haskell
                            
                                " Scala
                              elseif s:name =~# 'scala\>'
                                set ft=scala
                            
                                " Clojure
                              elseif s:name =~# 'clojure'
                                set ft=clojure
                            
                                " Free Pascal
                              elseif s:name =~# 'instantfpc\>'
                                set ft=pascal
                            
                                " Fennel
                              elseif s:name =~# 'fennel\>'
                                set ft=fennel
                            
                                " MikroTik RouterOS script
                              elseif s:name =~# 'rsc\>'
                                set ft=routeros
                            
                                " Fish shell
                              elseif s:name =~# 'fish\>'
                                set ft=fish
                            
                                " Gforth
                              elseif s:name =~# 'gforth\>'
                                set ft=forth
                            
                              endif
                              unlet s:name
                            
    2              0.000008 else
                              " File does not start with "#!".
                            
    2              0.000035   let s:line2 = getline(2)
    2              0.000017   let s:line3 = getline(3)
    2              0.000015   let s:line4 = getline(4)
    2              0.000014   let s:line5 = getline(5)
                            
                              " Bourne-like shell scripts: sh ksh bash bash2
    2              0.000070   if s:line1 =~# '^:$'
                                call dist#ft#SetFileTypeSH(s:line1)	" defined in filetype.vim
                            
                              " Z shell scripts
    2              0.000219   elseif s:line1 =~# '^#compdef\>' || s:line1 =~# '^#autoload\>' ||
                                    \ "\n".s:line1."\n".s:line2."\n".s:line3."\n".s:line4."\n".s:line5 =~# '\n\s*emulate\s\+\%(-[LR]\s\+\)\=[ckz]\=sh\>'
                                set ft=zsh
                            
                              " ELM Mail files
    2              0.000083   elseif s:line1 =~# '^From \([a-zA-Z][a-zA-Z_0-9\.=-]*\(@[^ ]*\)\=\|-\) .* \(19\|20\)\d\d$'
                                set ft=mail
                            
                              " Mason
    2              0.000034   elseif s:line1 =~# '^<[%&].*>'
                                set ft=mason
                            
                              " Vim scripts (must have '" vim' as the first line to trigger this)
    2              0.000030   elseif s:line1 =~# '^" *[vV]im$'
                                set ft=vim
                            
                              " libcxx and libstdc++ standard library headers like "iostream" do not have
                              " an extension, recognize the Emacs file mode.
    2              0.000037   elseif s:line1 =~? '-\*-.*C++.*-\*-'
                                set ft=cpp
                            
                              " MOO
    2              0.000071   elseif s:line1 =~# '^\*\* LambdaMOO Database, Format Version \%([1-3]\>\)\@!\d\+ \*\*$'
                                set ft=moo
                            
                                " Diff file:
                                " - "diff" in first line (context diff)
                                " - "Only in " in first line
                                " - "--- " in first line and "+++ " in second line (unified diff).
                                " - "*** " in first line and "--- " in second line (context diff).
                                " - "# It was generated by makepatch " in the second line (makepatch diff).
                                " - "Index: <filename>" in the first line (CVS file)
                                " - "=== ", line of "=", "---", "+++ " (SVK diff)
                                " - "=== ", "--- ", "+++ " (bzr diff, common case)
                                " - "=== (removed|added|renamed|modified)" (bzr diff, alternative)
                                " - "# HG changeset patch" in first line (Mercurial export format)
    2              0.000484   elseif s:line1 =~# '^\(diff\>\|Only in \|\d\+\(,\d\+\)\=[cda]\d\+\>\|# It was generated by makepatch \|Index:\s\+\f\+\r\=$\|===== \f\+ \d\+\.\d\+ vs edited\|==== //\f\+#\d\+\|# HG changeset patch\)'
                            	\ || (s:line1 =~# '^--- ' && s:line2 =~# '^+++ ')
                            	\ || (s:line1 =~# '^\* looking for ' && s:line2 =~# '^\* comparing to ')
                            	\ || (s:line1 =~# '^\*\*\* ' && s:line2 =~# '^--- ')
                            	\ || (s:line1 =~# '^=== ' && ((s:line2 =~# '^=\{66\}' && s:line3 =~# '^--- ' && s:line4 =~# '^+++') || (s:line2 =~# '^--- ' && s:line3 =~# '^+++ ')))
                            	\ || (s:line1 =~# '^=== \(removed\|added\|renamed\|modified\)')
                                set ft=diff
                            
                                " PostScript Files (must have %!PS as the first line, like a2ps output)
    2              0.000032   elseif s:line1 =~# '^%![ \t]*PS'
                                set ft=postscr
                            
                                " M4 scripts: Guess there is a line that starts with "dnl".
    2              0.000116   elseif s:line1 =~# '^\s*dnl\>'
                            	\ || s:line2 =~# '^\s*dnl\>'
                            	\ || s:line3 =~# '^\s*dnl\>'
                            	\ || s:line4 =~# '^\s*dnl\>'
                            	\ || s:line5 =~# '^\s*dnl\>'
                                set ft=m4
                            
                                " AmigaDos scripts
    2              0.000088   elseif $TERM == "amiga"
                            	\ && (s:line1 =~# "^;" || s:line1 =~? '^\.bra')
                                set ft=amiga
                            
                                " SiCAD scripts (must have procn or procd as the first line to trigger this)
    2              0.000051   elseif s:line1 =~? '^ *proc[nd] *$'
                                set ft=sicad
                            
                                " Purify log files start with "****  Purify"
    2              0.000035   elseif s:line1 =~# '^\*\*\*\*  Purify'
                                set ft=purifylog
                            
                                " XML
    2              0.000030   elseif s:line1 =~# '<?\s*xml.*?>'
                                set ft=xml
                            
                                " XHTML (e.g.: PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN")
    2              0.000030   elseif s:line1 =~# '\<DTD\s\+XHTML\s'
                                set ft=xhtml
                            
                                " HTML (e.g.: <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN")
                                " Avoid "doctype html", used by slim.
    2              0.000036   elseif s:line1 =~? '<!DOCTYPE\s\+html\>'
                                set ft=html
                            
                                " PDF
    2              0.000039   elseif s:line1 =~# '^%PDF-'
                                set ft=pdf
                            
                                " XXD output
    2              0.000106   elseif s:line1 =~# '^\x\{7}: \x\{2} \=\x\{2} \=\x\{2} \=\x\{2} '
                                set ft=xxd
                            
                                " RCS/CVS log output
    2              0.000053   elseif s:line1 =~# '^RCS file:' || s:line2 =~# '^RCS file:'
                                set ft=rcslog
                            
                                " CVS commit
    2              0.000053   elseif s:line2 =~# '^CVS:' || getline("$") =~# '^CVS: '
                                set ft=cvs
                            
                                " Prescribe
    2              0.000023   elseif s:line1 =~# '^!R!'
                                set ft=prescribe
                            
                                " Send-pr
    2              0.000025   elseif s:line1 =~# '^SEND-PR:'
                                set ft=sendpr
                            
                                " SNNS files
    2              0.000042   elseif s:line1 =~# '^SNNS network definition file'
                                set ft=snnsnet
    2              0.000039   elseif s:line1 =~# '^SNNS pattern definition file'
                                set ft=snnspat
    2              0.000030   elseif s:line1 =~# '^SNNS result file'
                                set ft=snnsres
                            
                                " Virata
    2              0.000130   elseif s:line1 =~# '^%.\{-}[Vv]irata'
                            	\ || s:line2 =~# '^%.\{-}[Vv]irata'
                            	\ || s:line3 =~# '^%.\{-}[Vv]irata'
                            	\ || s:line4 =~# '^%.\{-}[Vv]irata'
                            	\ || s:line5 =~# '^%.\{-}[Vv]irata'
                                set ft=virata
                            
                                " Strace
    2              0.000078   elseif s:line1 =~# '[0-9:.]* *execve(' || s:line1 =~# '^__libc_start_main'
                                set ft=strace
                            
                                " VSE JCL
    2              0.000075   elseif s:line1 =~# '^\* $$ JOB\>' || s:line1 =~# '^// *JOB\>'
                                set ft=vsejcl
                            
                                " TAK and SINDA
    2              0.000054   elseif s:line4 =~# 'K & K  Associates' || s:line2 =~# 'TAK 2000'
                                set ft=takout
    2              0.000105   elseif s:line3 =~# 'S Y S T E M S   I M P R O V E D '
                                set ft=sindaout
    2              0.000048   elseif getline(6) =~# 'Run Date: '
                                set ft=takcmp
    2              0.000036   elseif getline(9) =~# 'Node    File  1'
                                set ft=sindacmp
                            
                                " DNS zone files
    2              0.000100   elseif s:line1.s:line2.s:line3.s:line4 =~# '^; <<>> DiG [0-9.]\+.* <<>>\|$ORIGIN\|$TTL\|IN\s\+SOA'
                                set ft=bindzone
                            
                                " BAAN
    2              0.000165   elseif s:line1 =~# '|\*\{1,80}' && s:line2 =~# 'VRC '
                            	\ || s:line2 =~# '|\*\{1,80}' && s:line3 =~# 'VRC '
                                set ft=baan
                            
                              " Valgrind
    2              0.000077   elseif s:line1 =~# '^==\d\+== valgrind' || s:line3 =~# '^==\d\+== Using valgrind'
                                set ft=valgrind
                            
                              " Go docs
    2              0.000101   elseif s:line1 =~# '^PACKAGE DOCUMENTATION$'
                                set ft=godoc
                            
                              " Renderman Interface Bytestream
    2              0.000044   elseif s:line1 =~# '^##RenderMan'
                                set ft=rib
                            
                              " Scheme scripts
    2              0.000054   elseif s:line1 =~# 'exec\s\+\S*scheme' || s:line2 =~# 'exec\s\+\S*scheme'
                                set ft=scheme
                            
                              " Git output
    2              0.000097   elseif s:line1 =~# '^\(commit\|tree\|object\) \x\{40\}\>\|^tag \S\+$'
                                set ft=git
                            
                               " Gprof (gnu profiler)
    2              0.000036    elseif s:line1 == 'Flat profile:'
                                 \ && s:line2 == ''
                                 \ && s:line3 =~# '^Each sample counts as .* seconds.$'
                                 set ft=gprof
                            
                              " Erlang terms
                              " (See also: http://www.gnu.org/software/emacs/manual/html_node/emacs/Choosing-Modes.html#Choosing-Modes)
    2              0.000034   elseif s:line1 =~? '-\*-.*erlang.*-\*-'
                                set ft=erlang
                            
                              " YAML
    2              0.000023   elseif s:line1 =~# '^%YAML'
                                set ft=yaml
                            
                              " MikroTik RouterOS script
    2              0.000032   elseif s:line1 =~# '^#.*by RouterOS.*$'
                                set ft=routeros
                            
                              " CVS diff
    2              0.000006   else
    2              0.000024     let s:lnum = 1
    2              0.000049     while getline(s:lnum) =~# "^? " && s:lnum < line("$")
                                  let s:lnum += 1
    2              0.000013     endwhile
    2              0.000039     if getline(s:lnum) =~# '^Index:\s\+\f\+$'
                                  set ft=diff
                            
                                  " locale input files: Formal Definitions of Cultural Conventions
                                  " filename must be like en_US, fr_FR@euro or en_US.UTF-8
    2              0.000105     elseif expand("%") =~# '\a\a_\a\a\($\|[.@]\)\|i18n$\|POSIX$\|translit_'
                                  let s:lnum = 1
                                  while s:lnum < 100 && s:lnum < line("$")
                            	if getline(s:lnum) =~# '^LC_\(IDENTIFICATION\|CTYPE\|COLLATE\|MONETARY\|NUMERIC\|TIME\|MESSAGES\|PAPER\|TELEPHONE\|MEASUREMENT\|NAME\|ADDRESS\)$'
                            	  setf fdcc
                            	  break
                            	endif
                            	let s:lnum += 1
                                  endwhile
    2              0.000008     endif
    2              0.000018     unlet s:lnum
                            
    2              0.000006   endif
                            
    2              0.000018   unlet s:line2 s:line3 s:line4 s:line5
                            
    2              0.000005 endif
                            
                            " Restore 'cpoptions'
    2              0.000087 let &cpo = s:cpo_save
                            
    2              0.000111 unlet s:cpo_save s:line1

SCRIPT  C:\Users\Lenovo\AppData\Local\nvim-data\plugged\tagbar\autoload\tagbar.vim
Sourced 1 time
Total time:   0.015468
 Self time:   0.015468

count  total (s)   self (s)
                            " ============================================================================
                            " File:        tagbar.vim
                            " Description: List the current file's tags in a sidebar, ordered by class etc
                            " Author:      Jan Larres <jan@majutsushi.net>
                            " Licence:     Vim licence
                            " Website:     https://preservim.github.io/tagbar
                            " Version:     3.0.0
                            " Note:        This plugin was heavily inspired by the 'Taglist' plugin by
                            "              Yegappan Lakshmanan and uses a small amount of code from it.
                            "
                            " Original taglist copyright notice:
                            "              Permission is hereby granted to use and distribute this code,
                            "              with or without modifications, provided that this copyright
                            "              notice is copied with it. Like anything else that's free,
                            "              taglist.vim is provided *as is* and comes with no warranty of
                            "              any kind, either expressed or implied. In no event will the
                            "              copyright holder be liable for any damamges resulting from the
                            "              use of this software.
                            " ============================================================================
                            
    1              0.000018 scriptencoding utf-8
                            
                            " Initialization {{{1
                            
                            " If another plugin calls an autoloaded Tagbar function on startup before the
                            " plugin/tagbar.vim file got loaded, load it explicitly
    1              0.000042 if exists(':Tagbar') == 0
                                runtime plugin/tagbar.vim
    1              0.000004 endif
                            
    1              0.000014 if exists(':Tagbar') == 0
                                echomsg 'Tagbar: Could not load plugin code, check your runtimepath!'
                                finish
    1              0.000003 endif
                            
                            " Basic init {{{2
                            
    1              0.000020 redir => s:ftype_out
    1              0.000021 silent filetype
    1              0.000014 redir END
    1              0.000054 if s:ftype_out !~# 'detection:ON'
                                echomsg 'Tagbar: Filetype detection is turned off, skipping plugin'
                                unlet s:ftype_out
                                finish
    1              0.000003 endif
    1              0.000007 unlet s:ftype_out
                            
    1              0.000031 let g:tagbar#icon_closed = g:tagbar_iconchars[0]
    1              0.000022 let g:tagbar#icon_open   = g:tagbar_iconchars[1]
                            
    1              0.000009 let s:type_init_done    = 0
    1              0.000007 let s:autocommands_done = 0
    1              0.000007 let s:statusline_in_use = 0
    1              0.000006 let s:init_done = 0
                            
                            " 0: not checked yet; 1: checked and found; 2: checked and not found
    1              0.000007 let s:checked_ctags       = 0
    1              0.000007 let s:checked_ctags_types = 0
    1              0.000007 let s:ctags_is_uctags     = 0
                            
    1              0.000007 let s:new_window      = 1
    1              0.000007 let s:is_maximized    = 0
    1              0.000007 let s:winrestcmd      = ''
    1              0.000006 let s:short_help      = 1
    1              0.000007 let s:nearby_disabled = 0
    1              0.000006 let s:paused = 0
    1              0.000007 let s:pwin_by_tagbar = 0
    1              0.000009 let s:buffer_seqno = 0
    1              0.000006 let s:vim_quitting = 0
    1              0.000007 let s:last_alt_bufnr = -1
                            
    1              0.000007 let s:window_expanded   = 0
    1              0.000007 let s:expand_bufnr = -1
    1              0.000035 let s:window_pos = {
                                \ 'pre'  : { 'x' : 0, 'y' : 0 },
                                \ 'post' : { 'x' : 0, 'y' : 0 }
                            \}
                            
    1              0.000009 let s:delayed_update_files = []
                            
    1              0.000010 let g:loaded_tagbar = 1
                            
    1              0.000007 let s:last_highlight_tline = 0
                            
    1              0.000019 let s:warnings = {
                                \ 'type': [],
                                \ 'encoding': 0
                            \ }
                            
    1              0.002000 let s:singular_types = {
                                        \ 'Classes': 'Class',
                                        \ 'Delegates': 'Delegate',
                                        \ 'Enumeration values': 'Enumeration value',
                                        \ 'Enumerations': 'Enumeration',
                                        \ 'Error codes': 'Error code',
                                        \ 'Error domains': 'Error domain',
                                        \ 'Fields': 'Field',
                                        \ 'Interfaces': 'Interface',
                                        \ 'JavaScript funtions': 'JavaScript function',
                                        \ 'Methods': 'Method',
                                        \ 'MobiLink Conn Scripts': 'MobiLink Conn Script',
                                        \ 'MobiLink Properties': 'MobiLink Property',
                                        \ 'MobiLink Table Scripts': 'MobiLink Table Script',
                                        \ 'Properties': 'Property',
                                        \ 'Signals': 'Signal',
                                        \ 'Structures': 'Structure',
                                        \ 'autocommand groups': 'autocommand group',
                                        \ 'block data': 'block data',
                                        \ 'block label': 'block label',
                                        \ 'chapters': 'chapter',
                                        \ 'classes': 'class',
                                        \ 'commands': 'command',
                                        \ 'common blocks': 'common block',
                                        \ 'components': 'component',
                                        \ 'constant definitions': 'constant definition',
                                        \ 'constants': 'constant',
                                        \ 'constructors': 'constructor',
                                        \ 'cursors': 'cursor',
                                        \ 'data items': 'data item',
                                        \ 'defines': 'define',
                                        \ 'derived types and structures': 'derived type and structure',
                                        \ 'domains': 'domain',
                                        \ 'entities': 'entity',
                                        \ 'entry points': 'entry point',
                                        \ 'embedded': 'embedded',
                                        \ 'enum constants': 'enum constant',
                                        \ 'enum types': 'enum type',
                                        \ 'enumerations': 'enumeration',
                                        \ 'enumerators': 'enumerator',
                                        \ 'enums': 'enum',
                                        \ 'events': 'event',
                                        \ 'exception declarations': 'exception declaration',
                                        \ 'exceptions': 'exception',
                                        \ 'features': 'feature',
                                        \ 'fields': 'field',
                                        \ 'file descriptions': 'file description',
                                        \ 'formats': 'format',
                                        \ 'fragments': 'fragment',
                                        \ 'function definitions': 'function definition',
                                        \ 'functions': 'function',
                                        \ 'functor definitions': 'functor definition',
                                        \ 'global variables': 'global variable',
                                        \ 'group items': 'group item',
                                        \ 'imports': 'import',
                                        \ 'includes': 'include',
                                        \ 'indexes': 'index',
                                        \ 'interfaces': 'interface',
                                        \ 'javascript functions': 'JavaScript function',
                                        \ 'labels': 'label',
                                        \ 'macro definitions': 'macro definition',
                                        \ 'macros': 'macro',
                                        \ 'maps': 'map',
                                        \ 'members': 'member',
                                        \ 'methods': 'method',
                                        \ 'modules or functors': 'module or function',
                                        \ 'modules': 'module',
                                        \ 'mxtags': 'mxtag',
                                        \ 'named anchors': 'named anchor',
                                        \ 'namelists': 'namelist',
                                        \ 'namespaces': 'namespace',
                                        \ 'net data types': 'net data type',
                                        \ 'packages': 'package',
                                        \ 'package': 'package',
                                        \ 'paragraphs': 'paragraph',
                                        \ 'parts': 'part',
                                        \ 'patterns': 'pattern',
                                        \ 'ports': 'port',
                                        \ 'procedures': 'procedure',
                                        \ 'program ids': 'program id',
                                        \ 'programs': 'program',
                                        \ 'projects': 'project',
                                        \ 'properties': 'property',
                                        \ 'prototypes': 'prototype',
                                        \ 'publications': 'publication',
                                        \ 'record definitions': 'record definition',
                                        \ 'record fields': 'record field',
                                        \ 'records': 'record',
                                        \ 'register data types': 'register data type',
                                        \ 'sections': 'section',
                                        \ 'services': 'services',
                                        \ 'sets': 'sets',
                                        \ 'signature declarations': 'signature declaration',
                                        \ 'singleton methods': 'singleton method',
                                        \ 'slots': 'slot',
                                        \ 'structs': 'struct',
                                        \ 'structure declarations': 'structure declaration',
                                        \ 'structure fields': 'structure field',
                                        \ 'subparagraphs': 'subparagraph',
                                        \ 'subroutines': 'subroutine',
                                        \ 'subsections': 'subsection',
                                        \ 'subsubsections': 'subsubsection',
                                        \ 'subtypes': 'subtype',
                                        \ 'synonyms': 'synonym',
                                        \ 'tables': 'table',
                                        \ 'targets': 'target',
                                        \ 'tasks': 'task',
                                        \ 'triggers': 'trigger',
                                        \ 'type definitions': 'type definition',
                                        \ 'type names': 'type name',
                                        \ 'typedefs': 'typedef',
                                        \ 'types': 'type',
                                        \ 'unions': 'union',
                                        \ 'value bindings': 'value binding',
                                        \ 'variables': 'variable',
                                        \ 'views': 'view',
                                        \ 'vimball filenames': 'vimball filename'}
                            
                            " s:Init() {{{2
    1              0.000019 function! s:Init(silent) abort
                                if s:checked_ctags == 2 && a:silent
                                    return 0
                                elseif s:checked_ctags != 1
                                    if !s:CheckForExCtags(a:silent)
                                        return 0
                                    endif
                                endif
                            
                                if !s:type_init_done
                                    call s:InitTypes()
                                endif
                            
                                if !s:autocommands_done
                                    call s:CreateAutocommands()
                                    call s:AutoUpdate(fnamemodify(expand('%'), ':p'), 0)
                                endif
                            
                                let s:init_done = 1
                                return 1
                            endfunction
                            
                            " s:InitTypes() {{{2
    1              0.000010 function! s:InitTypes() abort
                                call tagbar#debug#log('Initializing types')
                            
                                let supported_types = s:GetSupportedFiletypes()
                            
                                if s:ctags_is_uctags
                                    let s:known_types = tagbar#types#uctags#init(supported_types)
                                else
                                    let s:known_types = tagbar#types#ctags#init(supported_types)
                                endif
                            
                                " Use dart_ctags if available
                                let dart_ctags = s:CheckFTCtags('dart_ctags', 'dart')
                                if dart_ctags !=# ''
                                    let supported_types['dart'] = 1
                                    call tagbar#debug#log('Detected dart_ctags, overriding typedef')
                                    let type_dart = tagbar#prototypes#typeinfo#new()
                                    let type_dart.ctagstype = 'dart'
                                    let type_dart.kinds = [
                                        \ {'short' : 'l', 'long' : 'library',            'fold' : 0, 'stl' : 0},
                                        \ {'short' : 't', 'long' : 'export',             'fold' : 0, 'stl' : 0},
                                        \ {'short' : 'i', 'long' : 'imports',            'fold' : 1, 'stl' : 0},
                                        \ {'short' : 'D', 'long' : 'dart',               'fold' : 0, 'stl' : 0},
                                        \ {'short' : 'U', 'long' : 'pub',                'fold' : 0, 'stl' : 0},
                                        \ {'short' : 'L', 'long' : 'local',              'fold' : 0, 'stl' : 0},
                                        \ {'short' : 'P', 'long' : 'part',               'fold' : 0, 'stl' : 0},
                                        \ {'short' : 'p', 'long' : 'part of',            'fold' : 0, 'stl' : 0},
                                        \ {'short' : 'C', 'long' : 'consts',             'fold' : 0, 'stl' : 0},
                                        \ {'short' : 'v', 'long' : 'variables',          'fold' : 0, 'stl' : 0},
                                        \ {'short' : 'F', 'long' : 'functions',          'fold' : 0, 'stl' : 0},
                                        \ {'short' : 'E', 'long' : 'enums',              'fold' : 0, 'stl' : 0},
                                        \ {'short' : 'e', 'long' : 'constants',          'fold' : 0, 'stl' : 0},
                                        \ {'short' : 'x', 'long' : 'mixins',             'fold' : 0, 'stl' : 0},
                                        \ {'short' : 'c', 'long' : 'classes',            'fold' : 0, 'stl' : 0},
                                        \ {'short' : 'd', 'long' : 'extends',            'fold' : 0, 'stl' : 0},
                                        \ {'short' : 'w', 'long' : 'with',               'fold' : 0, 'stl' : 0},
                                        \ {'short' : 'z', 'long' : 'implements',         'fold' : 0, 'stl' : 0},
                                        \ {'short' : 'r', 'long' : 'constructors',       'fold' : 0, 'stl' : 0},
                                        \ {'short' : 'a', 'long' : 'abstract functions', 'fold' : 0, 'stl' : 0},
                                        \ {'short' : 'f', 'long' : 'fields',             'fold' : 0, 'stl' : 0},
                                        \ {'short' : 'm', 'long' : 'methods',            'fold' : 0, 'stl' : 0},
                                        \ {'short' : 'M', 'long' : 'static methods',     'fold' : 0, 'stl' : 0},
                                        \ {'short' : 'g', 'long' : 'getters',            'fold' : 0, 'stl' : 0},
                                        \ {'short' : 's', 'long' : 'setters',            'fold' : 0, 'stl' : 0},
                                        \ {'short' : 'o', 'long' : 'operators',          'fold' : 0, 'stl' : 0},
                                   \ ]
                                    let type_dart.sro        = ':'
                                    let type_dart.kind2scope = {
                                        \ 'c' : 'class',
                                        \ 'E' : 'enum',
                                        \ 'x' : 'mixin',
                                        \ 'i' : 'directive'
                                    \ }
                                    let type_dart.scope2kind = {
                                        \ 'class'  : 'c',
                                        \ 'enum'   : 'E',
                                        \ 'mixin'  : 'x',
                                        \ 'directive' : 'i'
                                    \ }
                                    let type_dart.ctagsbin   = dart_ctags
                                    let type_dart.ctagsargs  = '-l'
                                    let type_dart.ftype      = 'dart'
                                    call type_dart.createKinddict()
                                    let s:known_types.dart   = type_dart
                                endif
                            
                                " Use jsctags/doctorjs if available
                                let jsctags = s:CheckFTCtags('jsctags', 'javascript')
                                if jsctags !=# ''
                                    call tagbar#debug#log('Detected jsctags, overriding typedef')
                                    let type_javascript = tagbar#prototypes#typeinfo#new()
                                    let type_javascript.ctagstype = 'javascript'
                                    let type_javascript.kinds = [
                                        \ {'short' : 'v', 'long' : 'variables', 'fold' : 0, 'stl' : 0},
                                        \ {'short' : 'f', 'long' : 'functions', 'fold' : 0, 'stl' : 1}
                                    \ ]
                                    let type_javascript.sro        = '.'
                                    let type_javascript.kind2scope = {
                                        \ 'v' : 'namespace',
                                        \ 'f' : 'namespace'
                                    \ }
                                    let type_javascript.scope2kind = {
                                        \ 'namespace' : 'f'
                                    \ }
                                    let type_javascript.ctagsbin   = jsctags
                                    let type_javascript.ctagsargs  = '-f -'
                                    let type_javascript.ftype = 'javascript'
                                    call type_javascript.createKinddict()
                                    let s:known_types.javascript = type_javascript
                                endif
                            
                                " Use gotags if available
                                let gotags = s:CheckFTCtags('gotags', 'go')
                                if gotags !=# ''
                                    call tagbar#debug#log('Detected gotags, overriding typedef')
                                    let type_go = tagbar#prototypes#typeinfo#new()
                                    let type_go.ctagstype = 'go'
                                    let type_go.kinds = [
                                        \ {'short' : 'p', 'long' : 'package',      'fold' : 0, 'stl' : 0},
                                        \ {'short' : 'i', 'long' : 'imports',      'fold' : 1, 'stl' : 0},
                                        \ {'short' : 'c', 'long' : 'constants',    'fold' : 0, 'stl' : 0},
                                        \ {'short' : 'v', 'long' : 'variables',    'fold' : 0, 'stl' : 0},
                                        \ {'short' : 't', 'long' : 'types',        'fold' : 0, 'stl' : 0},
                                        \ {'short' : 'n', 'long' : 'intefaces',    'fold' : 0, 'stl' : 0},
                                        \ {'short' : 'w', 'long' : 'fields',       'fold' : 0, 'stl' : 0},
                                        \ {'short' : 'e', 'long' : 'embedded',     'fold' : 0, 'stl' : 0},
                                        \ {'short' : 'm', 'long' : 'methods',      'fold' : 0, 'stl' : 0},
                                        \ {'short' : 'r', 'long' : 'constructors', 'fold' : 0, 'stl' : 0},
                                        \ {'short' : 'f', 'long' : 'functions',    'fold' : 0, 'stl' : 0},
                                    \ ]
                                    let type_go.sro        = '.'
                                    let type_go.kind2scope = {
                                        \ 't' : 'ctype',
                                        \ 'n' : 'ntype'
                                    \ }
                                    let type_go.scope2kind = {
                                        \ 'ctype' : 't',
                                        \ 'ntype' : 'n'
                                    \ }
                                    let type_go.ctagsbin   = gotags
                                    let type_go.ctagsargs  = '-sort -silent'
                                    let type_go.ftype = 'go'
                                    call type_go.createKinddict()
                                    let s:known_types.go = type_go
                                endif
                            
                                call s:LoadUserTypeDefs()
                            
                                " Add an 'unknown' kind to the types for pseudotags that we can't
                                " determine the correct kind for since they don't have any children that
                                " are not pseudotags and that therefore don't provide scope information
                                for typeinfo in values(s:known_types)
                                    if has_key(typeinfo, 'kind2scope')
                                        let unknown_kind =
                                            \ {'short' : '?', 'long' : 'unknown',  'fold' : 0, 'stl' : 1}
                                        " Check for existence first since some types exist under more than
                                        " one name
                                        if index(typeinfo.kinds, unknown_kind) == -1
                                            call add(typeinfo.kinds, unknown_kind)
                                        endif
                                        let typeinfo.kind2scope['?'] = 'unknown'
                                    endif
                                endfor
                            
                                let s:type_init_done = 1
                            endfunction
                            
                            " s:LoadUserTypeDefs() {{{2
    1              0.000022 function! s:LoadUserTypeDefs(...) abort
                                if a:0 > 0
                                    let type = a:1
                            
                                    let defdict = {}
                                    let defdict[type] = g:tagbar_type_{type}
                                else
                                    let defdict = tagbar#getusertypes()
                                endif
                            
                                let transformed = {}
                                for [type, def] in items(defdict)
                                    let transformed[type] = s:TransformUserTypeDef(def)
                                    let transformed[type].ftype = type
                                endfor
                            
                                for [key, value] in items(transformed)
                                    call tagbar#debug#log("Initializing user type '" . key . "'")
                                    if !has_key(s:known_types, key) || get(value, 'replace', 0)
                                        let s:known_types[key] = tagbar#prototypes#typeinfo#new(value)
                                    else
                                        call extend(s:known_types[key], value)
                                    endif
                                    call s:known_types[key].createKinddict()
                                endfor
                            endfunction
                            
                            " s:TransformUserTypeDef() {{{2
                            " Transform the user definitions into the internal format
    1              0.000013 function! s:TransformUserTypeDef(def) abort
                                let newdef = copy(a:def)
                            
                                if has_key(a:def, 'kinds')
                                    let newdef.kinds = []
                                    let kinds = a:def.kinds
                                    for kind in kinds
                                        let kindlist = split(kind, ':')
                                        let kinddict = {'short' : kindlist[0], 'long' : kindlist[1]}
                                        let kinddict.fold = get(kindlist, 2, 0)
                                        let kinddict.stl  = get(kindlist, 3, 1)
                                        call add(newdef.kinds, kinddict)
                                    endfor
                                endif
                            
                                " If the user only specified one of kind2scope and scope2kind then use it
                                " to generate the respective other
                                if has_key(a:def, 'kind2scope') && !has_key(a:def, 'scope2kind')
                                    let newdef.scope2kind = {}
                                    for [key, value] in items(a:def.kind2scope)
                                        let newdef.scope2kind[value] = key
                                    endfor
                                elseif has_key(a:def, 'scope2kind') && !has_key(a:def, 'kind2scope')
                                    let newdef.kind2scope = {}
                                    for [key, value] in items(a:def.scope2kind)
                                        let newdef.kind2scope[value] = key
                                    endfor
                                endif
                            
                                return newdef
                            endfunction
                            
                            " s:RestoreSession() {{{2
                            " Properly restore Tagbar after a session got loaded
    1              0.000007 function! s:RestoreSession() abort
                                if s:init_done
                                    call tagbar#debug#log('Tagbar already initialized; not restoring session')
                                    return
                                endif
                            
                                call tagbar#debug#log('Restoring session')
                            
                                let curfile = fnamemodify(bufname('%'), ':p')
                            
                                let tagbarwinnr = bufwinnr(s:TagbarBufName())
                                if tagbarwinnr == -1
                                    " Tagbar wasn't open in the saved session, nothing to do
                                    return
                                endif
                            
                                let in_tagbar = 1
                                if winnr() != tagbarwinnr
                                    call s:goto_win(tagbarwinnr, 1)
                                    let in_tagbar = 0
                                endif
                            
                                let s:last_autofocus = 0
                            
                                call s:Init(0)
                            
                                call s:InitWindow(g:tagbar_autoclose)
                            
                                call s:AutoUpdate(curfile, 0)
                            
                                if !in_tagbar
                                    call s:goto_win('p')
                                endif
                            endfunction
                            
                            " s:MapKeys() {{{2
    1              0.000007 function! s:MapKeys() abort
                                call tagbar#debug#log('Mapping keys')
                            
                                nnoremap <script> <silent> <buffer> <2-LeftMouse>
                                                                          \ :call <SID>JumpToTag(0)<CR>
                                nnoremap <script> <silent> <buffer> <LeftRelease>
                                                             \ <LeftRelease>:call <SID>CheckMouseClick()<CR>
                            
                                inoremap <script> <silent> <buffer> <2-LeftMouse>
                                                                          \ <C-o>:call <SID>JumpToTag(0)<CR>
                                inoremap <script> <silent> <buffer> <LeftRelease>
                                                        \ <LeftRelease><C-o>:call <SID>CheckMouseClick()<CR>
                            
                                let maps = [
                                    \ ['jump',          'JumpToTag(0)'],
                                    \ ['preview',       'JumpToTag(1)'],
                                    \ ['previewwin',    'ShowInPreviewWin()'],
                                    \ ['nexttag',       'GotoNextToplevelTag(1)'],
                                    \ ['prevtag',       'GotoNextToplevelTag(-1)'],
                                    \ ['showproto',     'ShowPrototype(0)'],
                                    \ ['hidenonpublic', 'ToggleHideNonPublicTags()'],
                                    \
                                    \ ['openfold',      'OpenFold()'],
                                    \ ['closefold',     'CloseFold()'],
                                    \ ['togglefold',    'ToggleFold()'],
                                    \ ['openallfolds',  'SetFoldLevel(99, 1)'],
                                    \ ['closeallfolds', 'SetFoldLevel(0, 1)'],
                                    \ ['incrementfolds',  'ChangeFoldLevel(1, 1)'],
                                    \ ['decrementfolds',  'ChangeFoldLevel(-1, 1)'],
                                    \ ['nextfold',      'GotoNextFold()'],
                                    \ ['prevfold',      'GotoPrevFold()'],
                                    \
                                    \ ['togglesort',            'ToggleSort()'],
                                    \ ['togglecaseinsensitive', 'ToggleCaseInsensitive()'],
                                    \ ['toggleautoclose',       'ToggleAutoclose()'],
                                    \ ['togglepause',           'TogglePause()'],
                                    \ ['zoomwin',               'ZoomWindow()'],
                                    \ ['close',                 'CloseWindow()'],
                                    \ ['help',                  'ToggleHelp()'],
                                \ ]
                            
                                let map_options = ' <script> <silent> <buffer> '
                                if v:version > 703 || (v:version == 703 && has('patch1261'))
                                    let map_options .= ' <nowait> '
                                endif
                            
                                for [map, func] in maps
                                    let def = get(g:, 'tagbar_map_' . map)
                                    if type(def) == type('')
                                        let keys = [def]
                                    else
                                        let keys = def
                                    endif
                                    for key in keys
                                        if !empty(key)
                                            execute 'nnoremap' . map_options . key .
                                                        \ ' :call <SID>' . func . '<CR>'
                                        endif
                                    endfor
                                    unlet def
                                endfor
                            
                                let b:tagbar_mapped_keys = 1
                            endfunction
                            
                            " s:CreateAutocommands() {{{2
    1              0.000009 function! s:CreateAutocommands() abort
                                call tagbar#debug#log('Creating autocommands')
                            
                                augroup TagbarAutoCmds
                                    autocmd!
                            
                                    autocmd BufEnter * if expand('<amatch>') !~ '__Tagbar__.*' |
                                                     \     let s:last_alt_bufnr = bufnr('#') |
                                                     \ endif
                                    if exists('##QuitPre')
                                        autocmd QuitPre * let s:vim_quitting = 1
                                    endif
                                    autocmd WinEnter * nested call s:HandleOnlyWindow()
                            
                                    if !g:tagbar_no_autocmds
                                        if !g:tagbar_silent
                                            autocmd CursorHold __Tagbar__.* call s:ShowPrototype(1)
                                        endif
                                        autocmd WinEnter   __Tagbar__.* call s:SetStatusLine()
                                        autocmd WinLeave   __Tagbar__.* call s:SetStatusLine()
                            
                                        if g:tagbar_show_balloon == 1 && has('balloon_eval')
                                            autocmd WinEnter __Tagbar__.*
                                                    \ let s:beval = &beval |
                                                    \ set ballooneval
                                            autocmd WinLeave __Tagbar__.*
                                                    \ if exists("s:beval") |
                                                    \   let &beval = s:beval |
                                                    \ endif
                                        endif
                            
                                        if g:tagbar_autopreview
                                            autocmd CursorMoved __Tagbar__.* nested call s:ShowInPreviewWin()
                                        endif
                            
                                        autocmd WinEnter * if bufwinnr(s:TagbarBufName()) == -1 |
                                                    \     call s:ShrinkIfExpanded() |
                                                    \ endif
                            
                                        autocmd BufWritePost *
                                                    \ call s:HandleBufWrite(fnamemodify(expand('<afile>'), ':p'))
                                        autocmd CursorHold,CursorHoldI * call s:do_delayed_update()
                                        " BufReadPost is needed for reloading the current buffer if the file
                                        " was changed by an external command; see commit 17d199f
                                        autocmd BufReadPost,BufEnter,CursorHold,FileType * call
                                                    \ s:AutoUpdate(fnamemodify(expand('<afile>'), ':p'), 0)
                                        if g:tagbar_highlight_follow_insert
                                            autocmd CursorHoldI * call
                                                    \ s:AutoUpdate(fnamemodify(expand('<afile>'), ':p'), 0)
                                        endif
                            
                                        " Suspend Tagbar while grep commands are running, since we don't want
                                        " to process files that only get loaded temporarily to search them
                                        autocmd QuickFixCmdPre  *grep* let s:tagbar_qf_active = 1
                                        autocmd QuickFixCmdPost *grep* if exists('s:tagbar_qf_active') |
                                                    \     unlet s:tagbar_qf_active |
                                                    \ endif
                            
                                        autocmd VimEnter * call s:CorrectFocusOnStartup()
                                    endif
                                augroup END
                            
                                " Separate these autocmds out from the others as we want to always perform
                                " these actions even if the tagbar window closes.
                                augroup TagbarCleanupAutoCmds
                                    autocmd!
                            
                                    if !g:tagbar_no_autocmds
                                        autocmd BufDelete,BufWipeout *
                                                    \ nested call s:HandleBufDelete(expand('<afile>'), expand('<abuf>'))
                                    endif
                                augroup END
                            
                                let s:autocommands_done = 1
                            endfunction
                            
                            " s:CheckForExCtags() {{{2
                            " Test whether the ctags binary is actually Exuberant Ctags and not BSD ctags
                            " (or something else)
    1              0.000009 function! s:CheckForExCtags(silent) abort
                                call tagbar#debug#log('Checking for Exuberant Ctags')
                            
                                if !exists('g:tagbar_ctags_bin')
                                    let ctagsbins  = []
                                    let ctagsbins += ['ctags-exuberant'] " Debian
                                    let ctagsbins += ['exuberant-ctags']
                                    let ctagsbins += ['exctags'] " FreeBSD, NetBSD
                                    let ctagsbins += ['/usr/local/bin/ctags'] " Homebrew
                                    let ctagsbins += ['/opt/local/bin/ctags'] " Macports
                                    let ctagsbins += ['ectags'] " OpenBSD
                                    let ctagsbins += ['ctags']
                                    let ctagsbins += ['ctags.exe']
                                    let ctagsbins += ['tags']
                                    let ctagsbins += ['universal-ctags']
                                    for ctags in ctagsbins
                                        if executable(ctags)
                                            let g:tagbar_ctags_bin = ctags
                                            break
                                        endif
                                    endfor
                                    if !exists('g:tagbar_ctags_bin')
                                        let l:errmsg = 'Tagbar: Exuberant ctags not found!'
                                        let l:infomsg = 'Please download Exuberant Ctags from' .
                                                    \ ' ctags.sourceforge.net and install it in a' .
                                                    \ ' directory in your $PATH or set g:tagbar_ctags_bin.'
                                        call s:CtagsErrMsg(l:errmsg, l:infomsg, a:silent)
                                        let s:checked_ctags = 2
                                        return 0
                                    endif
                                else
                                    " reset 'wildignore' temporarily in case *.exe is included in it
                                    let wildignore_save = &wildignore
                                    set wildignore&
                            
                                    let g:tagbar_ctags_bin = expand(g:tagbar_ctags_bin)
                            
                                    let &wildignore = wildignore_save
                            
                                    if !executable(g:tagbar_ctags_bin)
                                        let l:errmsg = 'Tagbar: Exuberant ctags not found at ' .
                                                   \ "'" . g:tagbar_ctags_bin . "'!"
                                        let l:infomsg = 'Please check your g:tagbar_ctags_bin setting.'
                                        call s:CtagsErrMsg(l:errmsg, l:infomsg, a:silent)
                                        let s:checked_ctags = 2
                                        return 0
                                    endif
                                endif
                            
                                let ctags_cmd = s:EscapeCtagsCmd(g:tagbar_ctags_bin, '--version')
                                if ctags_cmd ==# ''
                                    let s:checked_ctags = 2
                                    return 0
                                endif
                            
                                let ctags_output = s:ExecuteCtags(ctags_cmd)
                            
                                call tagbar#debug#log("Command output:\n" . ctags_output)
                                call tagbar#debug#log('Exit code: ' . v:shell_error)
                            
                                if v:shell_error || ctags_output !~# '\(Exuberant\|Universal\) Ctags'
                                    let l:errmsg = 'Tagbar: Ctags doesn''t seem to be Exuberant Ctags!'
                                    let l:infomsg = 'BSD ctags will NOT WORK.' .
                                        \ ' Please download Exuberant Ctags from ctags.sourceforge.net' .
                                        \ ' and install it in a directory in your $PATH' .
                                        \ ' or set g:tagbar_ctags_bin.'
                                    call s:CtagsErrMsg(l:errmsg, l:infomsg, a:silent,
                                                     \ ctags_cmd, ctags_output, v:shell_error)
                                    let s:checked_ctags = 2
                                    return 0
                                elseif !s:CheckExCtagsVersion(ctags_output)
                                    let l:errmsg = 'Tagbar: Exuberant Ctags is too old!'
                                    let l:infomsg = 'You need at least version 5.5 for Tagbar to work.' .
                                        \ ' Please download a newer version from ctags.sourceforge.net.'
                                    call s:CtagsErrMsg(l:errmsg, l:infomsg, a:silent, ctags_cmd, ctags_output)
                                    let s:checked_ctags = 2
                                    return 0
                                else
                                    let s:checked_ctags = 1
                                    return 1
                                endif
                            endfunction
                            
                            " s:CtagsErrMsg() {{{2
    1              0.000012 function! s:CtagsErrMsg(errmsg, infomsg, silent, ...) abort
                                call tagbar#debug#log(a:errmsg)
                                let ctags_cmd    = a:0 > 0 ? a:1 : ''
                                let ctags_output = a:0 > 1 ? a:2 : ''
                            
                                let exit_code_set = a:0 > 2
                                if exit_code_set
                                    let exit_code = a:3
                                endif
                            
                                if !a:silent
                                    call s:warning(a:errmsg)
                                    echomsg a:infomsg
                            
                                    if ctags_cmd ==# ''
                                        return
                                    endif
                            
                                    echomsg 'Executed command: "' . ctags_cmd . '"'
                                    if ctags_output !=# ''
                                        echomsg 'Command output:'
                                        for line in split(ctags_output, '\n')
                                            echomsg line
                                        endfor
                                    else
                                        echomsg 'Command output is empty.'
                                    endif
                                    if exit_code_set
                                        echomsg 'Exit code: ' . exit_code
                                    endif
                                endif
                            endfunction
                            
                            
                            " s:CheckExCtagsVersion() {{{2
    1              0.000010 function! s:CheckExCtagsVersion(output) abort
                                call tagbar#debug#log('Checking Exuberant Ctags version')
                            
                                if a:output =~? 'Universal Ctags'
                                    call tagbar#debug#log('Found Universal Ctags, assuming compatibility')
                                    let s:ctags_is_uctags = 1
                                    return 1
                                endif
                            
                                if a:output =~? 'Exuberant Ctags compatiable PHP enhancement'
                                    call tagbar#debug#log('Found phpctags, assuming compatibility')
                                    return 1
                                endif
                            
                                if a:output =~? 'Exuberant Ctags Development'
                                    call tagbar#debug#log('Found development version, assuming compatibility')
                                    return 1
                                endif
                            
                                let matchlist = matchlist(a:output, '\vExuberant Ctags (\d+)\.(\d+)')
                                let major     = matchlist[1]
                                let minor     = matchlist[2]
                            
                                call tagbar#debug#log("Ctags version: major='" . major . "', minor='" . minor . "'")
                            
                                return major >= 6 || (major == 5 && minor >= 5)
                            endfunction
                            
                            " s:CheckFTCtags() {{{2
    1              0.000009 function! s:CheckFTCtags(bin, ftype) abort
                                if executable(a:bin)
                                    return a:bin
                                endif
                            
                                if exists('g:tagbar_type_' . a:ftype)
                                    let userdef = g:tagbar_type_{a:ftype}
                                    if has_key(userdef, 'ctagsbin')
                                        return userdef.ctagsbin
                                    else
                                        return ''
                                    endif
                                endif
                            
                                return ''
                            endfunction
                            
                            " s:GetSupportedFiletypes() {{{2
    1              0.000008 function! s:GetSupportedFiletypes() abort
                                call tagbar#debug#log('Getting filetypes supported by Exuberant Ctags')
                            
                                let ctags_cmd = s:EscapeCtagsCmd(g:tagbar_ctags_bin, '--list-languages')
                                if ctags_cmd ==# ''
                                    return
                                endif
                            
                                let ctags_output = s:ExecuteCtags(ctags_cmd)
                            
                                if v:shell_error
                                    " this shouldn't happen as potential problems would have already been
                                    " caught by the previous ctags checking
                                    return
                                endif
                            
                                let types = split(ctags_output, '\n\+')
                            
                                let supported_types = {}
                                for type in types
                                    if match(type, '\[disabled\]') == -1
                                        let supported_types[tolower(type)] = 1
                                    endif
                                endfor
                            
                                return supported_types
                            endfunction
                            
                            " Known files {{{1
    1              0.000030 let s:known_files = {
                                \ '_files'   : {}
                            \ }
                            
                            " s:known_files.get() {{{2
    1              0.000009 function! s:known_files.get(fname) abort dict
                                return get(self._files, a:fname, {})
                            endfunction
                            
                            " s:known_files.put() {{{2
                            " Optional second argument is the filename
    1              0.000008 function! s:known_files.put(fileinfo, ...) abort dict
                                if a:0 == 1
                                    let self._files[a:1] = a:fileinfo
                                else
                                    let fname = a:fileinfo.fpath
                                    let self._files[fname] = a:fileinfo
                                endif
                            endfunction
                            
                            " s:known_files.has() {{{2
    1              0.000006 function! s:known_files.has(fname) abort dict
                                return has_key(self._files, a:fname)
                            endfunction
                            
                            " s:known_files.rm() {{{2
    1              0.000014 function! s:known_files.rm(fname) abort dict
                                if s:known_files.has(a:fname)
                                    call tagbar#debug#log('Removing fileinfo for [' . a:fname . ']')
                                    call remove(self._files, a:fname)
                                endif
                            endfunction
                            
                            " Window management {{{1
                            " s:ToggleWindow() {{{2
    1              0.000008 function! s:ToggleWindow(flags) abort
                                call tagbar#debug#log('ToggleWindow called')
                            
                                let tagbarwinnr = bufwinnr(s:TagbarBufName())
                                if tagbarwinnr != -1
                                    call s:CloseWindow()
                                    return
                                endif
                            
                                call s:OpenWindow(a:flags)
                            
                                call tagbar#debug#log('ToggleWindow finished')
                            endfunction
                            
                            " s:OpenWindow() {{{2
    1              0.000008 function! s:OpenWindow(flags) abort
                                call tagbar#debug#log("OpenWindow called with flags: '" . a:flags . "'")
                            
                                let autofocus = a:flags =~# 'f'
                                let jump      = a:flags =~# 'j'
                                let autoclose = a:flags =~# 'c'
                            
                                let curfile = fnamemodify(bufname('%'), ':p')
                                let curline = line('.')
                            
                                " If the tagbar window is already open check jump flag
                                " Also set the autoclose flag if requested
                                let tagbarwinnr = bufwinnr(s:TagbarBufName())
                                if tagbarwinnr != -1
                                    if winnr() != tagbarwinnr && jump
                                        call s:goto_win(tagbarwinnr)
                                        call s:HighlightTag(g:tagbar_autoshowtag != 2, 1, curline)
                                    endif
                                    call tagbar#debug#log('OpenWindow finished, Tagbar already open')
                                    return
                                endif
                            
                                " Use the window ID if the functionality exists, this is more reliable
                                " since the window number can change due to the Tagbar window opening
                                if exists('*win_getid')
                                    let prevwinid = win_getid()
                                    if winnr('$') > 1
                                        call s:goto_win('p', 1)
                                        let pprevwinid = win_getid()
                                        call s:goto_win('p', 1)
                                    endif
                                else
                                    let prevwinnr = winnr()
                                    if winnr('$') > 1
                                        call s:goto_win('p', 1)
                                        let pprevwinnr = winnr()
                                        call s:goto_win('p', 1)
                                    endif
                                endif
                            
                                " This is only needed for the CorrectFocusOnStartup() function
                                let s:last_autofocus = autofocus
                            
                                if !s:Init(0)
                                    return 0
                                endif
                            
                                " Expand the Vim window to accommodate for the Tagbar window if requested
                                " and save the window positions to be able to restore them later.
                                if g:tagbar_expand >= 1 && !s:window_expanded &&
                                 \ (has('gui_running') || g:tagbar_expand == 2)
                                    let s:window_pos.pre.x = getwinposx()
                                    let s:window_pos.pre.y = getwinposy()
                                    let &columns += g:tagbar_width + 1
                                    let s:window_pos.post.x = getwinposx()
                                    let s:window_pos.post.y = getwinposy()
                                    let s:window_expanded = 1
                                endif
                            
                                let s:window_opening = 1
                                if g:tagbar_position =~# 'vertical'
                                    let size = g:tagbar_width
                                    let mode = 'vertical '
                                else
                                    let size = g:tagbar_height
                                    let mode = ''
                                endif
                                exe 'silent keepalt ' . g:tagbar_position . size . 'split ' . s:TagbarBufName()
                                exe 'silent ' . mode . 'resize ' . size
                                unlet s:window_opening
                            
                                call s:InitWindow(autoclose)
                            
                                " If the current file exists, but is empty, it means that it had a
                                " processing error before opening the window, most likely due to a call to
                                " currenttag() in the statusline. Remove the entry so an error message
                                " will be shown if the processing still fails.
                                if empty(s:known_files.get(curfile))
                                    call s:known_files.rm(curfile)
                                endif
                            
                                call s:AutoUpdate(curfile, 0)
                                call s:HighlightTag(g:tagbar_autoshowtag != 2, 1, curline)
                            
                                if !(g:tagbar_autoclose || autofocus || g:tagbar_autofocus)
                                    if exists('*win_getid')
                                        if exists('pprevwinid')
                                            noautocmd call win_gotoid(pprevwinid)
                                        endif
                                        call win_gotoid(prevwinid)
                                    else
                                        " If the Tagbar winnr is identical to one of the saved values
                                        " then that means that the window numbers have changed.
                                        " Just jump back to the previous window since we won't be able to
                                        " restore the window history.
                                        if winnr() == prevwinnr
                                         \ || (exists('pprevwinnr') && winnr() == pprevwinnr)
                                            call s:goto_win('p')
                                        else
                                            if exists('pprevwinnr')
                                                call s:goto_win(pprevwinnr, 1)
                                            endif
                                            call s:goto_win(prevwinnr)
                                        endif
                                    endif
                                endif
                            
                                call tagbar#debug#log('OpenWindow finished')
                            endfunction
                            
                            " s:InitWindow() {{{2
    1              0.000010 function! s:InitWindow(autoclose) abort
                                call tagbar#debug#log('InitWindow called with autoclose: ' . a:autoclose)
                            
                                " Buffer-local options
                            
                                setlocal filetype=tagbar
                            
                                setlocal noreadonly " in case the "view" mode is used
                                setlocal buftype=nofile
                                setlocal bufhidden=hide
                                setlocal noswapfile
                                setlocal nobuflisted
                                setlocal nomodifiable
                                setlocal textwidth=0
                                setlocal colorcolumn=""
                            
                                if g:tagbar_scrolloff > 0
                                    execute 'setlocal scrolloff=' . g:tagbar_scrolloff
                                endif
                            
                                if g:tagbar_show_balloon == 1 && has('balloon_eval')
                                    setlocal balloonexpr=TagbarBalloonExpr()
                                endif
                            
                            
                                " Window-local options
                            
                                setlocal nolist
                                setlocal winfixwidth
                                setlocal nospell
                            
                                if g:tagbar_wrap == 0
                                    setlocal nowrap
                                else
                                    setlocal wrap
                                    if exists('+linebreak')
                                        setlocal breakindent
                                        setlocal breakindentopt=shift:4
                                        if g:tagbar_wrap == 1
                                            setlocal linebreak
                                        elseif g:tagbar_wrap == 2
                                            setlocal nolinebreak
                                        endif
                                    endif
                                endif
                            
                                if g:tagbar_show_linenumbers == 0
                                    setlocal nonumber
                                    if exists('+relativenumber')
                                        setlocal norelativenumber
                                    endif
                                elseif g:tagbar_show_linenumbers == 1
                                    setlocal number
                                elseif g:tagbar_show_linenumbers == 2
                                    setlocal relativenumber
                                else
                                    set number<
                                    if exists('+relativenumber')
                                        set relativenumber<
                                    endif
                                endif
                            
                                setlocal nofoldenable
                                setlocal foldcolumn=0
                                " Reset fold settings in case a plugin set them globally to something
                                " expensive. Apparently 'foldexpr' gets executed even if 'foldenable' is
                                " off, and then for every appended line (like with :put).
                                setlocal foldmethod&
                                setlocal foldexpr&
                            
                                silent! setlocal signcolumn=no
                            
                                let w:autoclose = a:autoclose
                            
                                call s:SetStatusLine()
                            
                                let s:new_window = 1
                            
                                let cpoptions_save = &cpoptions
                                set cpoptions&vim
                            
                                if !exists('b:tagbar_mapped_keys')
                                    call s:MapKeys()
                                endif
                            
                                let &cpoptions = cpoptions_save
                            
                                if g:tagbar_expand
                                    let s:expand_bufnr = bufnr('%')
                                endif
                            
                                call tagbar#debug#log('InitWindow finished')
                            endfunction
                            
                            " s:CloseWindow() {{{2
    1              0.000008 function! s:CloseWindow() abort
                                call tagbar#debug#log('CloseWindow called')
                            
                                let tagbarwinnr = bufwinnr(s:TagbarBufName())
                                if tagbarwinnr == -1
                                    return
                                endif
                            
                                " Close the preview window if it was opened by us
                                if s:pwin_by_tagbar
                                    pclose
                                    let tagbarwinnr = bufwinnr(s:TagbarBufName())
                                endif
                            
                                if winnr() == tagbarwinnr
                                    if winbufnr(2) != -1
                                        " Other windows are open, only close the tagbar one
                            
                                        let curfile = tagbar#state#get_current_file(0)
                                        let s:is_maximized = 0
                            
                                        close
                            
                                        " Try to jump to the correct window after closing
                                        call s:goto_win('p')
                            
                                        if !empty(curfile)
                                            let filebufnr = bufnr(curfile.fpath)
                            
                                            if bufnr('%') != filebufnr
                                                let filewinnr = bufwinnr(filebufnr)
                                                if filewinnr != -1
                                                    call s:goto_win(filewinnr)
                                                endif
                                            endif
                                        endif
                                    endif
                                else
                                    " Go to the tagbar window, close it and then come back to the original
                                    " window. Save a win-local variable in the original window so we can
                                    " jump back to it even if the window number changed.
                                    call s:mark_window()
                                    call s:goto_win(tagbarwinnr)
                                    close
                            
                                    call s:goto_markedwin()
                                endif
                            
                                call s:ShrinkIfExpanded()
                            
                                if s:autocommands_done && !s:statusline_in_use
                                    call tagbar#StopAutoUpdate()
                                endif
                            
                                call tagbar#debug#log('CloseWindow finished')
                            endfunction
                            
                            " s:ShrinkIfExpanded() {{{2
                            " If the Vim window has been expanded, and Tagbar is not open in any other
                            " tabpages, shrink the window again
    1              0.000007 function! s:ShrinkIfExpanded() abort
                                if !s:window_expanded || &filetype ==# 'tagbar' || s:expand_bufnr == -1
                                    return
                                endif
                            
                                let tablist = []
                                for i in range(tabpagenr('$'))
                                    call extend(tablist, tabpagebuflist(i + 1))
                                endfor
                            
                                if index(tablist, s:expand_bufnr) == -1
                                    let &columns -= g:tagbar_width + 1
                                    let s:window_expanded = 0
                                    let s:expand_bufnr = -1
                                    " Only restore window position if it is available and if the
                                    " window hasn't been moved manually after the expanding
                                    if getwinposx() != -1 &&
                                     \ getwinposx() == s:window_pos.post.x &&
                                     \ getwinposy() == s:window_pos.post.y
                                       execute 'winpos ' . s:window_pos.pre.x .
                                                   \ ' ' . s:window_pos.pre.y
                                    endif
                                endif
                            
                                " The window sizes may have changed due to the shrinking happening after
                                " the window closing, so equalize them again.
                                if &equalalways
                                    wincmd =
                                endif
                            endfunction
                            
                            " s:ZoomWindow() {{{2
    1              0.000006 function! s:ZoomWindow() abort
                                if s:is_maximized
                                    execute 'vertical resize ' . g:tagbar_width
                                    execute s:winrestcmd
                                    let s:is_maximized = 0
                                else
                                    let s:winrestcmd = winrestcmd()
                                    if g:tagbar_zoomwidth == 1
                                        vertical resize
                                    elseif g:tagbar_zoomwidth == 0
                                        let func = exists('*strdisplaywidth') ? 'strdisplaywidth' : 'strlen'
                                        let maxline = max(map(getline(line('w0'), line('w$')),
                                                            \ func . '(v:val)'))
                                        execute 'vertical resize ' . maxline
                                    elseif g:tagbar_zoomwidth > 1
                                        execute 'vertical resize ' . g:tagbar_zoomwidth
                                    endif
                                    let s:is_maximized = 1
                                endif
                            endfunction
                            
                            " s:CorrectFocusOnStartup() {{{2
                            " For whatever reason the focus will be on the Tagbar window if
                            " tagbar#autoopen is used with a FileType autocommand on startup and
                            " g:tagbar_left is set. This should work around it by jumping to the window of
                            " the current file after startup.
    1              0.000008 function! s:CorrectFocusOnStartup() abort
                                if bufwinnr(s:TagbarBufName()) != -1 && !g:tagbar_autofocus && !s:last_autofocus
                                    let curfile = tagbar#state#get_current_file(1)
                                    if !empty(curfile) && curfile.fpath != fnamemodify(bufname('%'), ':p')
                                        let winnr = bufwinnr(curfile.fpath)
                                        if winnr != -1
                                            call s:goto_win(winnr)
                                        endif
                                    endif
                                endif
                            endfunction
                            
                            " Tag processing {{{1
                            " s:ProcessFile() {{{2
                            " Execute ctags and put the information into a 'FileInfo' object
    1              0.000017 function! s:ProcessFile(fname, ftype) abort
                                call tagbar#debug#log('ProcessFile called [' . a:fname . ']')
                            
                                if !s:IsValidFile(a:fname, a:ftype)
                                    call tagbar#debug#log('Not a valid file, returning')
                                    return
                                endif
                            
                                let l:bufnum = bufnr(a:fname)
                            
                                if !bufloaded(l:bufnum)
                                    call tagbar#debug#log('[ProcessFile] Buffer is not loaded exiting...')
                                    return
                                endif
                                if !bufexists(l:bufnum)
                                    call tagbar#debug#log('[ProcessFile] Buffer does not exist exiting...')
                                    return
                                endif
                            
                                let typeinfo = s:known_types[a:ftype]
                            
                                " If the file has only been updated preserve the fold states, otherwise
                                " create a new entry
                                if s:known_files.has(a:fname) && !empty(s:known_files.get(a:fname)) &&
                                 \ s:known_files.get(a:fname).ftype == a:ftype
                                    let fileinfo = s:known_files.get(a:fname)
                                    let typeinfo = fileinfo.typeinfo
                                    call fileinfo.reset()
                                else
                                    if exists('#TagbarProjects#User')
                                        execute 'doautocmd <nomodeline> TagbarProjects User ' . a:fname
                                        if exists('b:tagbar_type')
                                            let typeinfo = extend(copy(typeinfo),
                                                                \ s:TransformUserTypeDef(b:tagbar_type))
                                            call typeinfo.createKinddict()
                                        endif
                                    endif
                                    let fileinfo = tagbar#prototypes#fileinfo#new(a:fname, a:ftype, typeinfo)
                                endif
                            
                                call tagbar#debug#log('typeinfo for file to process: ' . string(typeinfo))
                            
                                if g:tagbar_file_size_limit > 0
                                            \ && fileinfo.fsize > g:tagbar_file_size_limit
                                            \ && !exists('b:tagbar_force_update')
                                    call tagbar#debug#log('File size exceeds defined limit')
                                    let fileinfo.fsize_exceeded = 1
                                    call s:known_files.put(fileinfo)
                                    return
                                elseif g:tagbar_use_cache
                                    " Use a temporary files for ctags processing instead of the original one.
                                    " This allows using Tagbar for files accessed with netrw, and also doesn't
                                    " slow down Tagbar for files that sit on slow network drives.
                                    let tempfile = tempname()
                                    let ext = fnamemodify(fileinfo.fpath, ':e')
                                    if ext !=# ''
                                        let tempfile .= '.' . ext
                                    endif
                            
                                    call tagbar#debug#log('Caching file into: ' . tempfile)
                                    let templines = getbufline(fileinfo.bufnr, 1, '$')
                                    let res = writefile(templines, tempfile)
                            
                                    if res != 0
                                        call tagbar#debug#log('Could not create copy '.tempfile)
                                        return
                                    endif
                                    let fileinfo.mtime = getftime(tempfile)
                                    let fileinfo.fsize_exceeded = 0
                            
                                    let ctags_output = s:ExecuteCtagsOnFile(tempfile, a:fname, typeinfo)
                            
                                    if !tagbar#debug#enabled()
                                        call delete(tempfile)
                                    endif
                                else
                                    call tagbar#debug#log('File caching disabled')
                                    let fileinfo.fsize_exceeded = 0
                                    let ctags_output = s:ExecuteCtagsOnFile(a:fname, a:fname, typeinfo)
                                endif
                            
                                if ctags_output == -1
                                    call tagbar#debug#log('Ctags error when processing file')
                                    " Put an empty entry into known_files so the error message is only
                                    " shown once
                                    call s:known_files.put({}, a:fname)
                                    return
                                elseif ctags_output ==# ''
                                    call tagbar#debug#log('Ctags output empty')
                                    " No need to go through the tag processing if there are no tags, and
                                    " preserving the old fold state isn't necessary either
                                    call s:known_files.put(tagbar#prototypes#fileinfo#new(a:fname, a:ftype,
                                                                        \ s:known_types[a:ftype]), a:fname)
                                    return
                                endif
                            
                                call tagbar#debug#log('Filetype tag kinds: ' . string(keys(typeinfo.kinddict)))
                            
                                " Parse the ctags output lines
                                call tagbar#debug#log('Parsing ctags output')
                                let rawtaglist = split(ctags_output, '\n\+')
                                let seen = {}
                                for line in rawtaglist
                                    " skip comments and duplicates (can happen when --sort=no)
                                    if line =~# '^!_TAG_' || has_key(seen, line)
                                        continue
                                    endif
                                    if g:tagbar_ignore_anonymous && line =~# '__anon'
                                        call tagbar#debug#log('anonymous tag found - ignoring per tagbar configuration')
                                        continue
                                    endif
                            
                                    let seen[line] = 1
                            
                                    let parts = split(line, ';"')
                                    if len(parts) == 2 " Is a valid tag line
                                        call s:ParseTagline(parts[0], parts[1], typeinfo, fileinfo)
                                    endif
                                endfor
                            
                                " Create a placeholder tag for the 'kind' header for folding purposes, but
                                " only for non-scoped tags
                                for kind in typeinfo.kinds
                                    if has_key(get(typeinfo, 'kind2scope', {}), kind.short)
                                        continue
                                    endif
                            
                                    let curtags = filter(copy(fileinfo.getTags()),
                                                       \ 'v:val.fields.kind ==# kind.short && ' .
                                                       \ '!has_key(v:val, "scope")')
                                    call tagbar#debug#log('Processing kind: ' . kind.short .
                                               \ ', number of tags: ' . len(curtags))
                            
                                    if empty(curtags)
                                        continue
                                    endif
                            
                                    let kindtag          = tagbar#prototypes#kindheadertag#new(kind.long)
                                    let kindtag.short    = kind.short
                                    let kindtag.numtags  = len(curtags)
                                    let kindtag.fileinfo = fileinfo
                            
                                    for tag in curtags
                                        let tag.parent = kindtag
                                    endfor
                                endfor
                            
                                " Clear old folding information from previous file version to prevent leaks
                                call fileinfo.clearOldFolds()
                            
                                " Sort the tags
                                call fileinfo.sortTags(typeinfo)
                            
                                call s:known_files.put(fileinfo)
                            endfunction
                            
                            " s:ExecuteCtagsOnFile() {{{2
    1              0.000013 function! s:ExecuteCtagsOnFile(fname, realfname, typeinfo) abort
                                call tagbar#debug#log('ExecuteCtagsOnFile called [' . a:fname . ']')
                            
                                if has_key(a:typeinfo, 'ctagsargs') && type(a:typeinfo.ctagsargs) == type('')
                                    " if ctagsargs is a string, prepend and append space separators
                                    let ctags_args = ' ' . a:typeinfo.ctagsargs . ' '
                                elseif has_key(a:typeinfo, 'ctagsargs') && type(a:typeinfo.ctagsargs) == type([])
                                    let ctags_args = a:typeinfo.ctagsargs
                                " otherwise ctagsargs is not defined or not defined as a valid type
                                else
                                    "Prefer constructing ctags_args as a list rather than a string
                                    "See s:EscapeCtagsCmd() - It's a best practice to shellescape()
                                    "each arg separately because in special cases where space is
                                    "intended to be in an argument, spaces in a single ctag_args
                                    "string would be ambiguous. Is the space an argument separator
                                    "or to be included in the argument
                                    let ctags_args = []
                                    if exists('g:tagbar_ctags_options')
                                        for value in g:tagbar_ctags_options
                                            call add(ctags_args, '--options='.value)
                                        endfor
                                    endif
                            
                                    " universal-ctags deprecated this argument name
                                    if s:ctags_is_uctags
                                        let ctags_args += [ '--extras=+F' ]
                                    else
                                        let ctags_args += [ '--extra=', '--file-scope=yes' ]
                                    endif
                            
                                    let ctags_args  = ctags_args + [
                                                      \ '-f',
                                                      \ '-',
                                                      \ '--format=2',
                                                      \ '--excmd=pattern',
                                                      \ '--fields=nksSafet',
                                                      \ '--sort=no',
                                                      \ '--append=no'
                                                      \ ]
                            
                                    " verbose if debug enabled
                                    if tagbar#debug#enabled()
                                        let ctags_args += [ '-V' ]
                                    endif
                            
                                    " Third-party programs may not necessarily make use of this
                                    if has_key(a:typeinfo, 'ctagstype')
                                        let ctags_type = a:typeinfo.ctagstype
                            
                                        let ctags_kinds = ''
                                        for kind in a:typeinfo.kinds
                                            if kind.short !=# '?'
                                                let ctags_kinds .= kind.short
                                            endif
                                        endfor
                            
                                        let ctags_args += ['--language-force=' . ctags_type]
                                        let ctags_args += ['--' . ctags_type . '-kinds=' . ctags_kinds]
                                    endif
                            
                                    " Include extra type definitions - include last to allow for any
                                    " overrides
                                    if has_key(a:typeinfo, 'deffile') && filereadable(expand(a:typeinfo.deffile))
                                        let ctags_args += ['--options=' . expand(a:typeinfo.deffile)]
                                    endif
                                endif
                            
                                if has_key(a:typeinfo, 'ctagsbin')
                                    " reset 'wildignore' temporarily in case *.exe is included in it
                                    let wildignore_save = &wildignore
                                    set wildignore&
                                    let ctags_bin = expand(a:typeinfo.ctagsbin)
                                    let &wildignore = wildignore_save
                                else
                                    let ctags_bin = g:tagbar_ctags_bin
                                endif
                            
                                let ctags_cmd = s:EscapeCtagsCmd(ctags_bin, ctags_args, a:fname)
                                if ctags_cmd ==# ''
                                    return ''
                                endif
                            
                                let ctags_output = s:ExecuteCtags(ctags_cmd)
                            
                                if v:shell_error || ctags_output =~? 'Warning: cannot open \(source\|input\) file'
                                    call tagbar#debug#log('Command output:')
                                    call tagbar#debug#log(ctags_output)
                                    call tagbar#debug#log('Exit code: ' . v:shell_error)
                                    " Only display an error message if the Tagbar window is open and we
                                    " haven't seen the error before.
                                    if bufwinnr(s:TagbarBufName()) != -1 &&
                                     \ (!s:known_files.has(a:realfname) ||
                                     \ !empty(s:known_files.get(a:realfname)))
                                        call s:warning('Tagbar: Could not execute ctags for ' . a:realfname . '!')
                                        echomsg 'Executed command: "' . ctags_cmd . '"'
                                        if !empty(ctags_output)
                                            echomsg 'Command output:'
                                            for line in split(ctags_output, '\n')
                                                echomsg line
                                            endfor
                                        endif
                                        echomsg 'Exit code: ' . v:shell_error
                                    endif
                                    return -1
                                endif
                            
                                call tagbar#debug#log('Ctags executed successfully')
                                call tagbar#debug#log_ctags_output(ctags_output)
                            
                                return ctags_output
                            endfunction
                            
                            " s:ParseTagline() {{{2
                            " Structure of a tag line:
                            " tagname<TAB>filename<TAB>expattern;"fields
                            " fields: <TAB>name:value
                            " fields that are always present: kind, line
    1              0.000014 function! s:ParseTagline(part1, part2, typeinfo, fileinfo) abort
                                let basic_info  = split(a:part1, '\t')
                                let tagname  = basic_info[0]
                                let filename = basic_info[1]
                            
                                " the pattern can contain tabs and thus may have been split up, so join
                                " the rest of the items together again
                                let pattern = join(basic_info[2:], "\t")
                                if pattern[0] ==# '/'
                                    let start   = 2 " skip the slash and the ^
                                    let end     = strlen(pattern) - 1
                                    if pattern[end - 1] ==# '$'
                                        let end -= 1
                                        let dollar = '\$'
                                    else
                                        let dollar = ''
                                    endif
                                    let pattern = '\V\^\C' . strpart(pattern, start, end - start) . dollar
                                else
                                    let pattern = ''
                                endif
                            
                                " When splitting fields make sure not to create empty keys or values in
                                " case a value illegally contains tabs
                                let fields = split(a:part2, '^\t\|\t\ze\w\+:')
                                let fielddict = {}
                                if fields[0] !~# ':'
                                    let fielddict.kind = remove(fields, 0)
                                endif
                                for field in fields
                                    " can't use split() since the value can contain ':'
                                    let delimit = stridx(field, ':')
                                    let key = strpart(field, 0, delimit)
                                    " Remove all tabs that may illegally be in the value
                                    let val = substitute(strpart(field, delimit + 1), '\t', '', 'g')
                                    " File-restricted scoping
                                    if key ==# 'file'
                                        let fielddict[key] = 'yes'
                                    endif
                                    if len(val) > 0
                                        if key ==# 'line' || key ==# 'column' || key ==# 'end'
                                            let fielddict[key] = str2nr(val)
                                        else
                                            let fielddict[key] = val
                                        endif
                                    endif
                                endfor
                            
                                " If the tag covers multiple scopes, split it up and create individual tags
                                " for each scope so that the hierarchy can be displayed correctly.
                                " This can happen with PHP's 'namespace' tags in uctags, for example.
                                if has_key(a:typeinfo, 'kind2scope') && has_key(a:typeinfo.kind2scope, fielddict.kind)
                                        \ && tagname =~# '\V' . escape(a:typeinfo.sro, '\')
                                    let tagparts = split(tagname, '\V' . escape(a:typeinfo.sro, '\'))
                            
                                    let scope = a:typeinfo.kind2scope[fielddict.kind]
                                    if has_key(fielddict, scope)
                                        let parent = fielddict[scope]
                                    else
                                        let parent = ''
                                    endif
                                    let curfielddict = fielddict
                            
                                    for i in range(len(tagparts))
                                        let part = tagparts[i]
                                        call s:ProcessTag(part, filename, pattern, curfielddict,
                                                        \ i != len(tagparts) - 1, a:typeinfo, a:fileinfo)
                                        if parent !=# ''
                                            let parent = parent . a:typeinfo.sro . part
                                        else
                                            let parent = part
                                        endif
                                        let curfielddict = copy(fielddict)
                                        let curfielddict[scope] = parent
                                    endfor
                                else
                                    call s:ProcessTag(tagname, filename, pattern, fielddict, 0,
                                                    \ a:typeinfo, a:fileinfo)
                                endif
                            endfunction
                            
                            " s:ProcessTag() {{{2
    1              0.000017 function! s:ProcessTag(name, filename, pattern, fields, is_split, typeinfo, fileinfo) abort
                                if a:is_split
                                    let taginfo = tagbar#prototypes#splittag#new(a:name)
                                else
                                    let taginfo = tagbar#prototypes#normaltag#new(a:name)
                                endif
                            
                                let taginfo.file    = a:filename
                                let taginfo.pattern = a:pattern
                                call extend(taginfo.fields, a:fields)
                            
                                " Needed for jsctags
                                if has_key(taginfo.fields, 'lineno')
                                    let taginfo.fields.line = str2nr(taginfo.fields.lineno)
                                endif
                                " Do some sanity checking in case ctags reports invalid line numbers
                                if taginfo.fields.line < 0
                                    let taginfo.fields.line = 0
                                endif
                            
                                " Make sure our 'end' is valid
                                if taginfo.fields.end < taginfo.fields.line
                                    if a:typeinfo.getKind(taginfo.fields.kind).stl
                                        " the config indicates this is a scoped kind due to 'stl', but we
                                        " don't have scope vars, assume scope goes to end of file. This
                                        " can also be the case for exhuberant ctags which doesn't support
                                        " the --fields=e option.
                                        " When we call the GetNearbyTag(), it will look up for the nearest
                                        " tag, so if we have multiples that have scope to the end of the
                                        " file it will still only grab the first one above the current line
                                        let taginfo.fields.end = line('$')
                                    else
                                        let taginfo.fields.end = taginfo.fields.line
                                    endif
                                endif
                            
                                if !has_key(taginfo.fields, 'kind')
                                    call tagbar#debug#log(
                                        \ "Warning: No 'kind' field found for tag " . a:name[0] . '!')
                                    if index(s:warnings.type, a:typeinfo.ftype) == -1
                                        call s:warning("No 'kind' field found for tag " . a:name[0] . '!' .
                                                     \ " Please read the last section of ':help tagbar-extend'.")
                                        call add(s:warnings.type, a:typeinfo.ftype)
                                    endif
                                    return
                                endif
                            
                                let taginfo.fileinfo = a:fileinfo
                                let taginfo.typeinfo = a:typeinfo
                            
                                let a:fileinfo.fline[taginfo.fields.line] = taginfo
                            
                                if has_key(taginfo.fields, 'typeref')
                                    let typeref = taginfo.fields.typeref
                                    let delimit = stridx(typeref, ':')
                                    let key = strpart(typeref, 0, delimit)
                                    if key ==# 'typename'
                                        let taginfo.data_type = substitute(strpart(typeref, delimit + 1), '\t', '', 'g')
                                    else
                                        let taginfo.data_type = key
                                    endif
                                endif
                            
                                " If this filetype doesn't have any scope information then we can stop
                                " here after adding the tag to the list
                                if !has_key(a:typeinfo, 'scope2kind')
                                    call a:fileinfo.addTag(taginfo)
                                    return
                                endif
                            
                            
                                " Make some information easier accessible
                                for scope in keys(a:typeinfo.scope2kind)
                                    if has_key(taginfo.fields, scope)
                                        let taginfo.scope = scope
                                        let taginfo.path  = taginfo.fields[scope]
                            
                                        let taginfo.fullpath = taginfo.path . a:typeinfo.sro .
                                                             \ taginfo.name
                                        break
                                    endif
                                endfor
                                let pathlist = split(taginfo.path, '\V' . escape(a:typeinfo.sro, '\'))
                                let taginfo.depth = len(pathlist)
                            
                                " Needed for folding
                                try
                                    call taginfo.initFoldState(s:known_files)
                                catch /^Vim(\a\+):E716:/ " 'Key not present in Dictionary'
                                    " The tag has a 'kind' that doesn't exist in the type definition
                                    call tagbar#debug#log('Warning: Unknown tag kind: ' . taginfo.fields.kind)
                                    if index(s:warnings.type, a:typeinfo.ftype) == -1
                                        call s:warning('Unknown tag kind encountered: ' .
                                            \ '"' . taginfo.fields.kind . '".' .
                                            \ ' Your ctags and Tagbar configurations are out of sync!' .
                                            \ ' Please read '':help tagbar-extend''.')
                                        call add(s:warnings.type, a:typeinfo.ftype)
                                    endif
                                    return
                                endtry
                            
                                call s:add_tag_recursive({}, taginfo, pathlist)
                            endfunction
                            
                            " s:add_tag_recursive() {{{2
                            " Add a tag recursively as a child of its parent, or if there is no parent, to
                            " the root tag list in the fileinfo object.
    1              0.000012 function! s:add_tag_recursive(parent, taginfo, pathlist) abort
                                " If the pathlist is empty we are at the correct scope for the current tag
                                if empty(a:pathlist)
                                    " If a child tag got processed before a parent tag then there will
                                    " be a pseudotag here as a placeholder. Copy the children over and
                                    " then replace the pseudotag with the real one.
                                    let pseudotags = []
                                    if empty(a:parent)
                                        let name_siblings = a:taginfo.fileinfo.getTagsByName(a:taginfo.name)
                                    else
                                        let name_siblings = a:parent.getChildrenByName(a:taginfo.name)
                                    endif
                            
                                    " Consider a tag as replaceable if the current tag is considered to
                                    " have more appropriate information
                                    for tag in name_siblings
                                        if (tag.fields.kind ==# '?'
                                          \ || tag.fields.kind ==# a:taginfo.fields.kind)
                                         \ && (tag.isPseudoTag()
                                          \ || (!a:taginfo.isSplitTag() && tag.isSplitTag()))
                                            call add(pseudotags, tag)
                                        endif
                                    endfor
                            
                                    if len(pseudotags) == 1
                                        let pseudotag = pseudotags[0]
                                        for child in pseudotag.getChildren()
                                            call a:taginfo.addChild(child)
                                            let child.parent = a:taginfo
                                        endfor
                                        if empty(a:parent)
                                            call a:taginfo.fileinfo.removeTag(pseudotag)
                                        else
                                            call a:parent.removeChild(pseudotag)
                                        endif
                                    elseif len(pseudotags) > 1
                                        echoerr 'Tagbar: Found duplicate pseudotag; this should never happen!'
                                              \ 'Please contact the script maintainer with an example.'
                                              \ 'Pseudotag name:' pseudotag.name
                                    endif
                            
                                    " If this is a tag that got created due to splitting up a tag name,
                                    " don't replace existing tags of the same kind.
                                    if a:taginfo.isSplitTag()
                                        for tag in name_siblings
                                            if tag.fields.kind ==# a:taginfo.fields.kind
                                                return
                                            endif
                                        endfor
                                    endif
                            
                                    if empty(a:parent)
                                        call a:taginfo.fileinfo.addTag(a:taginfo)
                                    else
                                        call a:parent.addChild(a:taginfo)
                                        let a:taginfo.parent = a:parent
                                    endif
                                    return
                                endif
                            
                            
                                " There is still at least one more scope between the current one and the
                                " one of the current tag, so we have to either find or create the
                                " intermediate tags
                            
                                let grandparent = a:parent
                                let parentname = remove(a:pathlist, 0)
                            
                                if empty(grandparent)
                                    let name_siblings = a:taginfo.fileinfo.getTagsByName(parentname)
                                else
                                    let name_siblings = grandparent.getChildrenByName(parentname)
                                endif
                                if empty(a:pathlist)
                                    " If the current tag is a direct child of the parent we're looking for
                                    " then we can also filter the parents based on the scope information
                                    let parents = []
                                    for tag in name_siblings
                                        if tag.fields.kind ==# '?'
                                         \ || get(a:taginfo.typeinfo.kind2scope, tag.fields.kind, '') ==# a:taginfo.scope
                                            call add(parents, tag)
                                        endif
                                    endfor
                                else
                                    let parents = name_siblings
                                endif
                            
                                if empty(parents)
                                    " No parents found, so either the parent is a pseudotag or it hasn't
                                    " been processed yet. Create a pseudotag as a placeholder; if the
                                    " actual parent gets processed later it will get replaced.
                                    if empty(a:pathlist)
                                        let pseudokind = a:taginfo.typeinfo.scope2kind[a:taginfo.scope]
                                    else
                                        let pseudokind = '?'
                                    endif
                                    let parent = s:create_pseudotag(parentname, grandparent,
                                                \ pseudokind, a:taginfo.typeinfo, a:taginfo.fileinfo)
                                    if empty(grandparent)
                                        call a:taginfo.fileinfo.addTag(parent)
                                    else
                                        call grandparent.addChild(parent)
                                    endif
                                elseif len(parents) == 1
                                    let parent = parents[0]
                                else
                                    " If there are multiple possible parents (c.f. issue #139, or tags
                                    " with the same name but a different kind) then we will pick the one
                                    " that is closest above the current tag as a heuristic.
                            
                                    " Start at line 0 so that pseudotags get included
                                    let minline = 0
                                    for candidate in parents
                                        " If the line number of the current tag is 0 then we have no way
                                        " of determining the best candidate by comparing line numbers.
                                        " Just use the first one we have.
                                        if a:taginfo.fields.line == 0
                                            let parent = candidate
                                            break
                                        endif
                            
                                        if candidate.fields.line <= a:taginfo.fields.line &&
                                         \ candidate.fields.line >= minline
                                            let parent = candidate
                                            let minline = candidate.fields.line
                                        endif
                                    endfor
                            
                                    if !exists('parent')
                                        " If we still haven't found a parent it must be below the current
                                        " tag, so find the closest parent below the tag. This can happen
                                        " for example in Go.
                                        let maxline = line('$')
                                        for candidate in parents
                                            if candidate.fields.line >= a:taginfo.fields.line &&
                                             \ candidate.fields.line <= maxline
                                                let parent = candidate
                                                let maxline = candidate.fields.line
                                            endif
                                        endfor
                                    endif
                                endif
                            
                                " If the parent is a pseudotag it may have gotten created as an in-between
                                " tag without proper information about its kind because all if its
                                " children are also pseudotags, so it may be incorrect. If the current tag
                                " is a direct child of a pseudotag then we can derive the correct kind, so
                                " replace it if necessary.
                                if parent.isPseudoTag() && empty(a:pathlist)
                                    let parentkind = a:taginfo.typeinfo.scope2kind[a:taginfo.scope]
                                    if parent.fields.kind ==# '?' || parentkind !=# parent.fields.kind
                                        let parent.fields.kind = parentkind
                                        call parent.initFoldState(s:known_files)
                                    endif
                                endif
                            
                                call s:add_tag_recursive(parent, a:taginfo, a:pathlist)
                            endfunction
                            
                            " s:create_pseudotag() {{{2
    1              0.000017 function! s:create_pseudotag(name, parent, kind, typeinfo, fileinfo) abort
                                if !empty(a:parent)
                                    let curpath = a:parent.fullpath
                                    " If the kind is not present in the kind2scope dictionary, return an
                                    " empty scope. This can happen due to incorrect ctags output as in #397.
                                    let pscope  = get(a:typeinfo.kind2scope, a:parent.fields.kind, '')
                                else
                                    let curpath = ''
                                    let pscope  = ''
                                endif
                            
                                let pseudotag             = tagbar#prototypes#pseudotag#new(a:name)
                                let pseudotag.fields.kind = a:kind
                            
                                let parentscope = substitute(curpath, '\V' . a:name . '$', '', '')
                                let parentscope = substitute(parentscope,
                                                    \ '\V\^' . escape(a:typeinfo.sro, '\') . '\$', '', '')
                            
                                if pscope !=# ''
                                    let pseudotag.fields[pscope] = parentscope
                                    let pseudotag.scope    = pscope
                                    let pseudotag.path     = parentscope
                                    let pseudotag.fullpath =
                                                \ pseudotag.path . a:typeinfo.sro . pseudotag.name
                                endif
                                let pseudotag.depth = len(split(pseudotag.path, '\V' . escape(a:typeinfo.sro, '\')))
                                let pseudotag.parent = a:parent
                                let pseudotag.fileinfo = a:fileinfo
                                let pseudotag.typeinfo = a:typeinfo
                            
                                call pseudotag.initFoldState(s:known_files)
                            
                                return pseudotag
                            endfunction
                            
                            " s:ToggleSort() {{{2
    1              0.000007 function! s:ToggleSort() abort
                                let fileinfo = tagbar#state#get_current_file(0)
                                if empty(fileinfo)
                                    return
                                endif
                            
                                " Save the tag the cursor is currently on
                                let curline = line('.')
                                let taginfo = s:GetTagInfo(curline, 0)
                            
                                match none
                            
                                let compare_typeinfo = s:known_types[fileinfo.ftype]
                            
                                if has_key(compare_typeinfo, 'sort')
                                    let compare_typeinfo.sort = !compare_typeinfo.sort
                                else
                                    let g:tagbar_sort = !g:tagbar_sort
                                endif
                            
                                call fileinfo.sortTags(compare_typeinfo)
                            
                                call s:RenderContent()
                                call s:SetStatusLine()
                            
                                " If we were on a tag before sorting then jump to it, otherwise restore
                                " the cursor to the current line
                                if !empty(taginfo)
                                    execute taginfo.tline
                                else
                                    execute curline
                                endif
                            endfunction
                            
                            " Display {{{1
                            " s:RenderContent() {{{2
    1              0.000012 function! s:RenderContent(...) abort
                                call tagbar#debug#log('RenderContent called')
                                let s:new_window = 0
                            
                                if a:0 == 1
                                    let fileinfo = a:1
                                else
                                    let fileinfo = tagbar#state#get_current_file(0)
                                endif
                            
                                if empty(fileinfo)
                                    call tagbar#debug#log('Empty fileinfo, returning')
                                    return
                                endif
                            
                                let tagbarwinnr = bufwinnr(s:TagbarBufName())
                            
                                if &filetype ==# 'tagbar'
                                    let in_tagbar = 1
                                else
                                    let in_tagbar = 0
                                    let prevwinnr = winnr()
                            
                                    " Get the previous window number, so that we can reproduce
                                    " the window entering history later. Do not run autocmd on
                                    " this command, make sure nothing is interfering.
                                    " let pprevwinnr = winnr('#') " Messes up windows for some reason
                                    call s:goto_win('p', 1)
                                    let pprevwinnr = winnr()
                                    call s:goto_win(tagbarwinnr, 1)
                                endif
                            
                                if !empty(tagbar#state#get_current_file(0)) &&
                                 \ fileinfo.fpath ==# tagbar#state#get_current_file(0).fpath
                                    " We're redisplaying the same file, so save the view
                                    call tagbar#debug#log('Redisplaying file [' . fileinfo.fpath . ']')
                                    let saveline = line('.')
                                    let savecol  = col('.')
                                    let topline  = line('w0')
                                endif
                            
                                let lazyredraw_save = &lazyredraw
                                set lazyredraw
                                let eventignore_save = &eventignore
                                set eventignore=all
                            
                                setlocal modifiable
                            
                                silent %delete _
                            
                                call s:PrintHelp()
                            
                                let typeinfo = fileinfo.typeinfo
                            
                                if fileinfo.fsize_exceeded == 1
                                    if g:tagbar_compact
                                        silent 0put ='\" File size [' . fileinfo.fsize . 'B] exceeds limit'
                                    else
                                        silent put ='\" File size exceeds defined limit'
                                        silent put ='\"   File Size [' . fileinfo.fsize . ' bytes]'
                                        silent put ='\"   Limit     [' . g:tagbar_file_size_limit . ' bytes]'
                                        silent put ='\" Use TagbarForceUpdate override'
                                    endif
                                elseif !empty(fileinfo.getTags())
                                    " Print tags
                                    call s:PrintKinds(typeinfo, fileinfo)
                                else
                                    call tagbar#debug#log('No tags found, skipping printing.')
                                    if g:tagbar_compact && s:short_help
                                        silent 0put ='\" No tags found.'
                                    else
                                        silent  put ='\" No tags found.'
                                    endif
                                endif
                            
                                " Delete empty lines at the end of the buffer
                                for linenr in range(line('$'), 1, -1)
                                    if getline(linenr) =~# '^$'
                                        execute 'silent ' . linenr . 'delete _'
                                    else
                                        break
                                    endif
                                endfor
                            
                                setlocal nomodifiable
                            
                                if !empty(tagbar#state#get_current_file(0)) &&
                                 \ fileinfo.fpath ==# tagbar#state#get_current_file(0).fpath
                                    let scrolloff_save = &scrolloff
                                    setlocal scrolloff=0
                            
                                    call cursor(topline, 1)
                                    normal! zt
                                    call cursor(saveline, savecol)
                            
                                    let &l:scrolloff = scrolloff_save
                                else
                                    " Make sure as much of the Tagbar content as possible is shown in the
                                    " window by jumping to the top after drawing
                                    execute 1
                                    call winline()
                            
                                    " Invalidate highlight cache from old file
                                    let s:last_highlight_tline = 0
                                endif
                            
                                let &lazyredraw  = lazyredraw_save
                                let &eventignore = eventignore_save
                            
                                if !in_tagbar
                                    call s:goto_win(pprevwinnr, 1)
                                    call s:goto_win(prevwinnr, 1)
                                endif
                            endfunction
                            
                            " s:PrintKinds() {{{2
    1              0.000016 function! s:PrintKinds(typeinfo, fileinfo) abort
                                call tagbar#debug#log('PrintKinds called')
                            
                                " If the short or long help is being displayed then the line numbers don't
                                " match up with the length of the output list
                                let offset = g:tagbar_compact && s:short_help ? 0 : line('.')
                                let output = []
                            
                                for kind in a:typeinfo.kinds
                                    let curtags = filter(copy(a:fileinfo.getTags()),
                                                       \ 'v:val.fields.kind ==# kind.short')
                                    call tagbar#debug#log('Printing kind: ' . kind.short .
                                               \ ', number of (top-level) tags: ' . len(curtags))
                            
                                    if empty(curtags)
                                        continue
                                    endif
                            
                                    if has_key(get(a:typeinfo, 'kind2scope', {}), kind.short)
                                        " Scoped tags
                                        for tag in curtags
                                            call s:PrintTag(tag, 0, output, a:fileinfo, a:typeinfo)
                            
                                            if g:tagbar_compact != 1
                                                call add(output, '')
                                            endif
                                        endfor
                                    else
                                        " Non-scoped tags
                                        let kindtag = curtags[0].parent
                            
                                        if kindtag.isFolded()
                                            let foldmarker = g:tagbar#icon_closed
                                        else
                                            let foldmarker = g:tagbar#icon_open
                                        endif
                            
                                        let padding = g:tagbar_show_visibility ? ' ' : ''
                                        if g:tagbar_show_tag_count
                                            let tag_count = ' (' . len(curtags) . ')'
                                            call add(output, foldmarker . padding . kind.long . tag_count)
                                        else
                                            call add(output, foldmarker . padding . kind.long)
                                        endif
                            
                                        let curline                   = len(output) + offset
                                        let kindtag.tline             = curline
                                        let a:fileinfo.tline[curline] = kindtag
                            
                                        if !kindtag.isFolded()
                                            for tag in curtags
                                                let str = tag.strfmt()
                                                call add(output, repeat(' ', g:tagbar_indent) . str)
                            
                                                " Save the current tagbar line in the tag for easy
                                                " highlighting access
                                                let curline                   = len(output) + offset
                                                let tag.tline                 = curline
                                                let a:fileinfo.tline[curline] = tag
                                            endfor
                                        endif
                            
                                        if g:tagbar_compact != 1
                                            call add(output, '')
                                        endif
                                    endif
                                endfor
                            
                                let outstr = join(output, "\n")
                                if g:tagbar_compact && !g:tagbar_help_visibility && s:short_help
                                    silent 0put =outstr
                                else
                                    silent  put =outstr
                                endif
                            endfunction
                            
                            " s:PrintTag() {{{2
    1              0.000026 function! s:PrintTag(tag, depth, output, fileinfo, typeinfo) abort
                                if g:tagbar_hide_nonpublic &&
                                 \ get(a:tag.fields, 'access', 'public') !=# 'public'
                                    let a:tag.tline = -1
                                    return
                                endif
                            
                                " Print tag indented according to depth
                                let tagstr = repeat(' ', a:depth * g:tagbar_indent) . a:tag.strfmt()
                                call add(a:output, tagstr)
                            
                                " Save the current tagbar line in the tag for easy highlighting access
                                let offset = g:tagbar_compact && s:short_help ? 0 : line('.')
                                let curline                   = len(a:output) + offset
                                let a:tag.tline               = curline
                                let a:fileinfo.tline[curline] = a:tag
                            
                                " Recursively print children
                                if a:tag.isFoldable() && !a:tag.isFolded()
                                    for ckind in a:typeinfo.kinds
                                        let childfilter = 'v:val.fields.kind ==# ckind.short'
                                        if g:tagbar_hide_nonpublic
                                            let childfilter .=
                                                  \ ' && get(v:val.fields, "access", "public") ==# "public"'
                                        endif
                                        let childtags = filter(copy(a:tag.getChildren()), childfilter)
                                        if len(childtags) > 0
                                            " Print 'kind' header of following children, but only if they
                                            " are not scope-defining tags (since those already have an
                                            " identifier)
                                            if !has_key(a:typeinfo.kind2scope, ckind.short)
                                                let indent  = (a:depth + 1) * g:tagbar_indent
                                                let indent += g:tagbar_show_visibility
                                                let indent += 1 " fold symbol
                                                call add(a:output, repeat(' ', indent) . '[' . ckind.long . ']')
                                                " Add basic tag to allow folding when on the header line
                                                let headertag = tagbar#prototypes#basetag#new(ckind.long)
                                                let headertag.parent = a:tag
                                                let headertag.fileinfo = a:tag.fileinfo
                                                let a:fileinfo.tline[len(a:output) + offset] = headertag
                                            endif
                                            for childtag in childtags
                                                call s:PrintTag(childtag, a:depth + 1, a:output,
                                                              \ a:fileinfo, a:typeinfo)
                                            endfor
                                        endif
                                    endfor
                                endif
                            endfunction
                            
                            " s:PrintHelp() {{{2
    1              0.000010 function! s:PrintHelp() abort
                                if !g:tagbar_compact && !g:tagbar_help_visibility && s:short_help
                                    silent 0put ='\" Press ' . s:get_map_str('help') . ' for help'
                                    silent  put _
                                elseif g:tagbar_help_visibility || !s:short_help
                                    let help_cmds = [
                                                \ ['jump',              'Jump to tag definition'],
                                                \ ['preview',           'As above, but stay in tagbar window'],
                                                \ ['previewwin',        'Show tag in preview window'],
                                                \ ['nexttag',           'Go to next top-level tag'],
                                                \ ['prevtag',           'Go to previous top-level tag'],
                                                \ ['showproto',         'Display tag prototype'],
                                                \ ['hidenonpublic',     'Hide non-public tags'],
                                            \ ]
                                    let fold_cmds = [
                                                \ ['openfold',          'Open fold'],
                                                \ ['closefold',         'Close fold'],
                                                \ ['togglefold',        'Toggle fold'],
                                                \ ['openallfolds',      'Open all folds'],
                                                \ ['closeallfolds',     'Close all folds'],
                                                \ ['incrementfolds',    'Increment fold level by 1'],
                                                \ ['decrementfolds',    'Decrement fold level by 1'],
                                                \ ['nextfold',          'Go to next fold'],
                                                \ ['prevfold',          'Go to previous fold'],
                                            \ ]
                                    let misc_cmds = [
                                                \ ['togglesort',        'Toggle sort'],
                                                \ ['togglecaseinsensitive', 'Toggle case insensitive sort option'],
                                                \ ['toggleautoclose',   'Toggle autoclose option'],
                                                \ ['togglepause',       'Toggle pause'],
                                                \ ['zoomwin',           'Zoom window in/out'],
                                                \ ['close',             'Close window'],
                                                \ ['help',              'Toggle help'],
                                            \ ]
                            
                                    silent 0put ='\" Tagbar keybindings'
                                    silent  put ='\"'
                                    silent  put ='\" --------- General ---------'
                                    for [cmd, desc] in help_cmds
                                        if !empty(s:get_map_str(cmd)) | silent put ='\" ' . s:get_map_str(cmd) . ': ' . desc | endif
                                    endfor
                                    silent  put ='\"'
                                    silent  put ='\" ---------- Folds ----------'
                                    for [cmd, desc] in fold_cmds
                                        if !empty(s:get_map_str(cmd)) | silent put ='\" ' . s:get_map_str(cmd) . ': ' . desc | endif
                                    endfor
                                    silent  put ='\"'
                                    silent  put ='\" ---------- Misc -----------'
                                    for [cmd, desc] in misc_cmds
                                        if !empty(s:get_map_str(cmd)) | silent put ='\" ' . s:get_map_str(cmd) . ': ' . desc | endif
                                    endfor
                                    silent  put _
                                endif
                            endfunction
                            
    1              0.000010 function! s:get_map_str(map) abort
                                let def = get(g:, 'tagbar_map_' . a:map)
                                if type(def) ==# type('')
                                    return def
                                else
                                    return join(def, ', ')
                                endif
                            endfunction
                            
                            " s:RenderKeepView() {{{2
                            " The gist of this function was taken from NERDTree by Martin Grenfell.
    1              0.000007 function! s:RenderKeepView(...) abort
                                if a:0 == 1
                                    let line = a:1
                                else
                                    let line = line('.')
                                endif
                            
                                let curcol  = col('.')
                                let topline = line('w0')
                            
                                call s:RenderContent()
                            
                                let scrolloff_save = &scrolloff
                                setlocal scrolloff=0
                            
                                call cursor(topline, 1)
                                normal! zt
                                call cursor(line, curcol)
                            
                                let &l:scrolloff = scrolloff_save
                            
                                redraw
                            endfunction
                            
                            " User actions {{{1
                            " s:HighlightTag() {{{2
    1              0.000007 function! s:HighlightTag(openfolds, ...) abort
                            
                                if g:tagbar_no_autocmds
                                    " If no autocmds are enabled, then it doesn't make sense to highlight
                                    " anything as the cursor can move around and any highlighting would be
                                    " inaccurate
                                    return
                                endif
                            
                                let tagline = 0
                            
                                let force = a:0 > 0 ? a:1 : 0
                            
                                if a:0 > 1
                                    let tag = s:GetNearbyTag(g:tagbar_highlight_method, 0, a:2)
                                else
                                    let tag = s:GetNearbyTag(g:tagbar_highlight_method, 0)
                                endif
                                if !empty(tag)
                                    let tagline = tag.tline
                                endif
                            
                                " Don't highlight the tag again if it's the same one as last time.
                                " This prevents the Tagbar window from jumping back after scrolling with
                                " the mouse.
                                if !force && tagline ==# s:last_highlight_tline
                                    return
                                else
                                    let s:last_highlight_tline = tagline
                                endif
                            
                                let tagbarwinnr = bufwinnr(s:TagbarBufName())
                                if tagbarwinnr == -1
                                    return
                                endif
                            
                                if tagbarwinnr == winnr()
                                    let in_tagbar = 1
                                else
                                    let in_tagbar = 0
                                    let prevwinnr = winnr()
                                    call s:goto_win('p', 1)
                                    let pprevwinnr = winnr()
                                    call s:goto_win(tagbarwinnr, 1)
                                endif
                            
                                try
                                    match none
                            
                                    " No tag above cursor position so don't do anything
                                    if tagline == 0
                                        return
                                    endif
                            
                                    if g:tagbar_autoshowtag == 1 || a:openfolds
                                        call s:OpenParents(tag)
                                    endif
                            
                                    " Check whether the tag is inside a closed fold and highlight the parent
                                    " instead in that case
                                    let tagline = tag.getClosedParentTline()
                            
                                    " Parent tag line number is invalid, better don't do anything
                                    if tagline <= 0
                                        return
                                    endif
                            
                                    " Go to the line containing the tag
                                    execute tagline
                            
                                    " Make sure the tag is visible in the window
                                    call winline()
                            
                                    let foldpat = '[' . g:tagbar#icon_open . g:tagbar#icon_closed . ' ]'
                            
                                    " If printing the line number of the tag to the left, and the tag is
                                    " visible (I.E. parent isn't folded)
                                    let identifier = '\zs\V' . escape(tag.name, '/\') . '\m\ze'
                                    if g:tagbar_show_tag_linenumbers == 2 && tagline == tag.tline
                                        let pattern = '/^\%' . tagline . 'l\s*' . foldpat . '[-+# ]\[[0-9]\+\] \?' . identifier . '/'
                                    else
                                        let pattern = '/^\%' . tagline . 'l\s*' . foldpat . '[-+# ]\?' . identifier . '/'
                                    endif
                                    call tagbar#debug#log("Highlight pattern: '" . pattern . "'")
                                    if hlexists('TagbarHighlight') " Safeguard in case syntax highlighting is disabled
                                        execute 'match TagbarHighlight ' . pattern
                                    else
                                        execute 'match Search ' . pattern
                                    endif
                                finally
                                    if !in_tagbar
                                        call s:goto_win(pprevwinnr, 1)
                                        call s:goto_win(prevwinnr, 1)
                                    endif
                                    redraw
                                endtry
                            endfunction
                            
                            " Is the given line number already visible in the window without
                            " any scrolling?
    1              0.000009 function! s:IsLineVisible(line) abort
                                let topline = line('w0')
                                let bottomline = line('w$')
                                let alreadyvisible = (a:line >= topline) && (a:line <= bottomline)
                                return alreadyvisible
                            endfunction
                            
                            " s:JumpToTag() {{{2
    1              0.000009 function! s:JumpToTag(stay_in_tagbar, ...) abort
                                let taginfo = a:0 > 0 ? a:1 : s:GetTagInfo(line('.'), 1)
                                let force_lazy_scroll = a:0 > 1 ? a:2 : 0
                            
                                if empty(taginfo) || !taginfo.isNormalTag()
                                    " Cursor line not on a tag. Check if this is the start of a foldable
                                    " line and if so, initiate the CloseFold() / OpenFold(). First trim
                                    " any whitespace from the start of the line so we don't have to worry
                                    " about multiple nested folds that are indented
                                    "
                                    " NOTE: This will only work with folds that are not also tags. For
                                    " example in a class definition that acts as the start of a fold when
                                    " there are member functions in the class, that line is also a valid
                                    " tag, so hitting <CR> on that line will cause it to jump to the tag,
                                    " not fold/unfold that particular fold
                                    let line   = substitute(getline('.'), '^\s*\(.\{-}\)\s*$', '\1', '')
                            
                                    if (match(line, g:tagbar#icon_open . '[-+ ]')) == 0
                                        call s:CloseFold()
                                    elseif (match(line, g:tagbar#icon_closed . '[-+ ]')) == 0
                                        call s:OpenFold()
                                    endif
                                    return
                                endif
                            
                                let tagbarwinnr = winnr()
                                if exists('w:autoclose')
                                    let autoclose = w:autoclose
                                else
                                    let autoclose = 0
                                endif
                            
                                call s:GotoFileWindow(taginfo.fileinfo)
                            
                                " Mark current position so it can be jumped back to
                                mark '
                            
                                " Check if the tag is already visible in the window.  We must do this
                                " before jumping to the line.
                                let noscroll = 0
                                if g:tagbar_jump_lazy_scroll != 0 || force_lazy_scroll
                                    let noscroll = s:IsLineVisible(taginfo.fields.line)
                                endif
                            
                                " Jump to the line where the tag is defined. Don't use the search pattern
                                " since it doesn't take the scope into account and thus can fail if tags
                                " with the same name are defined in different scopes (e.g. classes)
                                call tagbar#debug#log('Jumping to line ' . taginfo.fields.line)
                                execute taginfo.fields.line
                            
                                " If the file has been changed but not saved, the tag may not be on the
                                " saved line anymore, so search for it in the vicinity of the saved line
                                if taginfo.pattern !=# ''
                                    call tagbar#debug#log('Searching for pattern "' . taginfo.pattern . '"')
                                    if match(getline('.'), taginfo.pattern) == -1
                                        let interval = 1
                                        let forward  = 1
                                        while search(taginfo.pattern, 'W' . forward ? '' : 'b') == 0
                                            if !forward
                                                if interval > line('$')
                                                    break
                                                else
                                                    let interval = interval * 2
                                                endif
                                            endif
                                            let forward = !forward
                                        endwhile
                                    endif
                                endif
                            
                                " If the tag is on a different line after unsaved changes update the tag
                                " and file infos/objects
                                let curline = line('.')
                                if taginfo.fields.line != curline
                                    let taginfo.fields.line = curline
                                    let taginfo.fileinfo.fline[curline] = taginfo
                                endif
                            
                                if noscroll
                                    " Do not scroll.
                                else
                                    " Center the tag in the window and jump to the correct column if
                                    " available, otherwise try to find it in the line
                                    normal! z.
                            
                                    " If configured, adjust the jump_offset and center the window on that
                                    " line. Then fall-through adjust the cursor() position below that
                                    if g:tagbar_jump_offset != 0 && g:tagbar_jump_offset < curline
                                        if g:tagbar_jump_offset > winheight(0) / 2
                                            let jump_offset = winheight(0) / 2
                                        elseif g:tagbar_jump_offset < -winheight(0) / 2
                                            let jump_offset = -winheight(0) / 2
                                        else
                                            let jump_offset = g:tagbar_jump_offset
                                        endif
                                        execute curline+jump_offset
                                        normal! z.
                                    endif
                                endif
                            
                                if taginfo.fields.column > 0
                                    call cursor(taginfo.fields.line, taginfo.fields.column)
                                else
                                    call cursor(taginfo.fields.line, 1)
                                    call search('\V' . taginfo.name, 'c', line('.'))
                                endif
                            
                                normal! zv
                            
                                if a:stay_in_tagbar
                                    call s:HighlightTag(0)
                                    call s:goto_win(tagbarwinnr)
                                    redraw
                                elseif g:tagbar_autoclose || autoclose
                                    " Also closes preview window
                                    call s:CloseWindow()
                                else
                                    " Close the preview window if it was opened by us
                                    if s:pwin_by_tagbar
                                        pclose
                                    endif
                                    if s:is_maximized
                                        call s:ZoomWindow()
                                    endif
                                    call s:HighlightTag(0)
                                endif
                            endfunction
                            
                            " s:ShowInPreviewWin() {{{2
    1              0.000010 function! s:ShowInPreviewWin() abort
                                let pos = getpos('.')
                                let taginfo = s:GetTagInfo(pos[1], 1)
                            
                                if empty(taginfo) || !taginfo.isNormalTag()
                                    return
                                endif
                            
                                let pwin_open = 0
                                for win in range(1, winnr('$'))
                                    if getwinvar(win, '&previewwindow')
                                        let pwin_open = 1
                                        break
                                    endif
                                endfor
                            
                                " We want the preview window to be relative to the file window in normal
                                " (horizontal) mode, and relative to the Tagbar window in vertical mode,
                                " to make the best use of space.
                                if g:tagbar_position =~# 'vertical'
                                    call s:GotoFileWindow(taginfo.fileinfo, 1)
                                    call s:mark_window()
                                endif
                            
                                " Open the preview window if it is not already open. This has to be done
                                " explicitly before the :psearch below to better control its positioning.
                                if !pwin_open
                                    silent execute
                                        \ g:tagbar_previewwin_pos . ' pedit ' .
                                        \ fnameescape(taginfo.fileinfo.fpath)
                                    if g:tagbar_position !~# 'vertical'
                                        silent execute 'vertical resize ' . g:tagbar_width
                                    endif
                                    " Remember that the preview window was opened by Tagbar so we can
                                    " safely close it by ourselves
                                    let s:pwin_by_tagbar = 1
                                endif
                            
                                if g:tagbar_position !~# 'vertical'
                                    call s:GotoFileWindow(taginfo.fileinfo, 1)
                                    call s:mark_window()
                                endif
                            
                                " Use psearch instead of pedit since pedit essentially reloads the file
                                " and creates an empty undo entry. psearch has to be called from the file
                                " window, and since we only want matches in the current file we disable
                                " the 'include' option. Also start searching at the correct line number to
                                " find the correct tag in case of tags with the same name and to speed up
                                " the searching. Unfortunately the /\%l pattern doesn't seem to work with
                                " psearch.
                                let pattern = taginfo.pattern
                                if pattern ==# ''
                                    let pattern = '\V\^' . escape(getline(taginfo.fields.line), '\') . '\$'
                                endif
                                let include_save = &include
                                set include=
                                silent! execute taginfo.fields.line . ',$psearch! /' . pattern . '/'
                                let &include = include_save
                            
                                call s:goto_win('P', 1)
                                normal! zv
                                normal! zz
                                call s:goto_markedwin(1)
                                call s:goto_tagbar(1)
                                call cursor(pos[1], pos[2])
                            endfunction
                            
                            " s:ShowPrototype() {{{2
    1              0.000009 function! s:ShowPrototype(short) abort
                                let taginfo = s:GetTagInfo(line('.'), 1)
                            
                                if empty(taginfo)
                                    return ''
                                endif
                            
                                echo taginfo.getPrototype(a:short)
                            endfunction
                            
                            " s:ToggleHelp() {{{2
    1              0.000006 function! s:ToggleHelp() abort
                                let s:short_help = !s:short_help
                            
                                " Prevent highlighting from being off after adding/removing the help text
                                match none
                            
                                call s:RenderContent()
                            
                                execute 1
                                redraw
                            endfunction
                            
                            " s:GotoNextToplevelTag() {{{2
    1              0.000008 function! s:GotoNextToplevelTag(direction) abort
                                let curlinenr = line('.')
                                let newlinenr = line('.')
                            
                                if a:direction == 1
                                    let range = range(line('.') + 1, line('$'))
                                else
                                    let range = range(line('.') - 1, 1, -1)
                                endif
                            
                                for tmplinenr in range
                                    let taginfo = s:GetTagInfo(tmplinenr, 0)
                            
                                    if empty(taginfo)
                                        continue
                                    elseif empty(taginfo.parent)
                                        let newlinenr = tmplinenr
                                        break
                                    endif
                                endfor
                            
                                if curlinenr != newlinenr
                                    execute newlinenr
                                    call winline()
                                endif
                            
                                redraw
                            endfunction
                            
                            " Folding {{{1
                            " s:OpenFold() {{{2
    1              0.000006 function! s:OpenFold() abort
                                let fileinfo = tagbar#state#get_current_file(0)
                                if empty(fileinfo)
                                    return
                                endif
                            
                                let curline = line('.')
                            
                                let tag = s:GetTagInfo(curline, 0)
                                if empty(tag)
                                    return
                                endif
                            
                                call tag.openFold()
                            
                                call s:RenderKeepView()
                            endfunction
                            
                            " s:CloseFold() {{{2
    1              0.000006 function! s:CloseFold() abort
                                let fileinfo = tagbar#state#get_current_file(0)
                                if empty(fileinfo)
                                    return
                                endif
                            
                                match none
                            
                                let curline = line('.')
                            
                                let curtag = s:GetTagInfo(curline, 0)
                                if empty(curtag)
                                    return
                                endif
                            
                                let newline = curtag.closeFold()
                            
                                call s:RenderKeepView(newline)
                            endfunction
                            
                            " s:ToggleFold() {{{2
    1              0.000006 function! s:ToggleFold() abort
                                let fileinfo = tagbar#state#get_current_file(0)
                                if empty(fileinfo)
                                    return
                                endif
                            
                                match none
                            
                                let curtag = s:GetTagInfo(line('.'), 0)
                                if empty(curtag)
                                    return
                                endif
                            
                                let newline = line('.')
                            
                                if curtag.isKindheader()
                                    call curtag.toggleFold(tagbar#state#get_current_file(0))
                                elseif curtag.isFoldable()
                                    if curtag.isFolded()
                                        call curtag.openFold()
                                    else
                                        let newline = curtag.closeFold()
                                    endif
                                else
                                    let newline = curtag.closeFold()
                                endif
                            
                                call s:RenderKeepView(newline)
                            endfunction
                            
                            " s:ChangeFoldLevel() {{{2
    1              0.000009 function! s:ChangeFoldLevel(diff, force) abort
                                let fileinfo = tagbar#state#get_current_file(0)
                                if empty(fileinfo)
                                    return
                                endif
                            
                                if fileinfo.foldlevel == 99
                                    call s:MinimizeMaxFoldLevel(fileinfo, fileinfo.getTags())
                                endif
                            
                                let level = fileinfo.foldlevel
                                let level = level + a:diff
                                call s:SetFoldLevel(level, a:force)
                            endfunction
                            
                            " s:SetFoldLevel() {{{2
    1              0.000010 function! s:SetFoldLevel(level, force) abort
                                if a:level < 0
                                    call s:warning('Foldlevel can''t be negative')
                                    return
                                endif
                            
                                let fileinfo = tagbar#state#get_current_file(0)
                                if empty(fileinfo)
                                    return
                                endif
                            
                                call s:SetFoldLevelRecursive(fileinfo, fileinfo.getTags(), a:level)
                            
                                let typeinfo = fileinfo.typeinfo
                            
                                " Apply foldlevel to 'kind's
                                if a:level == 0
                                    for kind in typeinfo.kinds
                                        call fileinfo.closeKindFold(kind)
                                    endfor
                                else
                                    for kind in typeinfo.kinds
                                        if a:force || !kind.fold
                                            call fileinfo.openKindFold(kind)
                                        endif
                                    endfor
                                endif
                            
                                let fileinfo.foldlevel = a:level
                            
                                call s:RenderContent()
                            endfunction
                            
                            " s:SetFoldLevelRecursive() {{{2
                            " Apply foldlevel to normal tags
    1              0.000010 function! s:SetFoldLevelRecursive(fileinfo, tags, level) abort
                                for tag in a:tags
                                    if tag.depth >= a:level
                                        call tag.setFolded(1)
                                    else
                                        call tag.setFolded(0)
                                    endif
                            
                                    if !empty(tag.getChildren())
                                        call s:SetFoldLevelRecursive(a:fileinfo, tag.getChildren(), a:level)
                                    endif
                                endfor
                            endfunction
                            
                            " s:MinimizeMaxFoldLevel() {{{2
                            " Set the file's fold level to the lowest value that still shows all tags
    1              0.000019 function! s:MinimizeMaxFoldLevel(fileinfo, tags) abort
                                let maxlvl = 0
                                let tags = copy(a:tags)
                            
                                for tag in tags
                                    if maxlvl < tag.depth
                                        let maxlvl = tag.depth
                                    endif
                                    call tag.setFolded(0)
                                    call extend(tags, tag.getChildren())
                                endfor
                            
                                let a:fileinfo.foldlevel = maxlvl
                            endfunction
                            
                            " s:OpenParents() {{{2
    1              0.000006 function! s:OpenParents(...) abort
                                if a:0 == 1
                                    let tag = a:1
                                else
                                    let tag = s:GetNearbyTag('nearest', 0)
                                endif
                            
                                if !empty(tag)
                                    call tag.openParents()
                                    call s:RenderKeepView()
                                endif
                            endfunction
                            
                            " s:GotoNextFold() {{{2
    1              0.000006 function! s:GotoNextFold() abort
                                let curlinenr = line('.')
                                let newlinenr = line('.')
                            
                                let range = range(line('.') + 1, line('$'))
                            
                                for linenr in range
                                    let taginfo = s:GetTagInfo(linenr, 0)
                            
                                    if empty(taginfo)
                                        continue
                                    elseif !empty(taginfo.getChildren()) || taginfo.isKindheader()
                                        let newlinenr = linenr
                                        break
                                    endif
                                endfor
                            
                                if curlinenr != newlinenr
                                    execute linenr
                                    call winline()
                                endif
                            
                                redraw
                            endfunction
                            
                            " s:GotoPrevFold() {{{2
    1              0.000006 function! s:GotoPrevFold() abort
                                let curlinenr = line('.')
                                let newlinenr = line('.')
                                let curtag = s:GetTagInfo(curlinenr, 0)
                                let curparent = get(curtag, 'parent', {})
                            
                                let range = range(line('.') - 1, 1, -1)
                            
                                for linenr in range
                                    let taginfo = s:GetTagInfo(linenr, 0)
                            
                                    if empty(taginfo)
                                        continue
                                    " Check for the first tag that is either:
                                    " - the last tag in an open fold, that is skip all tags that have the
                                    "   same parent as the current one, or
                                    " - a closed parent fold.
                                    elseif (!empty(taginfo.parent) && taginfo.parent != curparent &&
                                          \ empty(taginfo.getChildren())) ||
                                         \ ((!empty(taginfo.getChildren()) || taginfo.isKindheader()) &&
                                          \ taginfo.isFolded())
                                        let newlinenr = linenr
                                        break
                                    endif
                                endfor
                            
                                if curlinenr != newlinenr
                                    execute linenr
                                    call winline()
                                endif
                            
                                redraw
                            endfunction
                            
                            " Helper functions {{{1
                            " s:AutoUpdate() {{{2
    1              0.000008 function! s:AutoUpdate(fname, force, ...) abort
                                call tagbar#debug#log('AutoUpdate called [' . a:fname . ']')
                            
                                " Whether we want to skip actually displaying the tags in Tagbar and only
                                " update the fileinfo
                                let no_display = a:0 > 0 ? a:1 : 0
                            
                                " This file is being loaded due to a quickfix command like vimgrep, so
                                " don't process it
                                if exists('s:tagbar_qf_active')
                                    return
                                elseif exists('s:window_opening')
                                    " This can happen if another plugin causes the active window to change
                                    " with an autocmd during the initial Tagbar window creation. In that
                                    " case InitWindow() hasn't had a chance to run yet and things can
                                    " break. MiniBufExplorer does this, for example. Completely disabling
                                    " autocmds at that point is also not ideal since for example
                                    " statusline plugins won't be able to update.
                                    call tagbar#debug#log('Still opening window, stopping processing')
                                    return
                                endif
                            
                                " Get the filetype of the file we're about to process
                                let bufnr = bufnr(a:fname)
                                let ftype = getbufvar(bufnr, '&filetype')
                            
                                " Don't do anything if we're in the tagbar window
                                if ftype ==# 'tagbar'
                                    call tagbar#debug#log('In Tagbar window, stopping processing')
                                    return
                                endif
                            
                                " Only consider the main filetype in cases like 'python.django'
                                let sftype = get(split(ftype, '\.'), 0, '')
                                call tagbar#debug#log("Vim filetype: '" . ftype . "', " .
                                           \ "sanitized filetype: '" . sftype . "'")
                            
                                " Don't do anything if the file isn't supported
                                if !s:IsValidFile(a:fname, sftype)
                                    call tagbar#debug#log('Not a valid file, stopping processing')
                                    let s:nearby_disabled = 1
                                    return
                                endif
                            
                                let updated = 0
                            
                                " Process the file if it's unknown or the information is outdated.
                                " Testing the mtime of the file is necessary in case it got changed
                                " outside of Vim, for example by checking out a different version from a
                                " VCS.
                                if s:known_files.has(a:fname)
                                    let curfile = s:known_files.get(a:fname)
                                    " if a:force || getbufvar(curfile.bufnr, '&modified') ||
                                    if a:force || empty(curfile) || curfile.ftype != sftype ||
                                     \ (filereadable(a:fname) && getftime(a:fname) > curfile.mtime)
                                        call tagbar#debug#log('File data outdated, updating [' . a:fname . ']')
                                        call s:ProcessFile(a:fname, sftype)
                                        let updated = 1
                                    else
                                        call tagbar#debug#log('File data seems up to date [' . a:fname . ']')
                                    endif
                                elseif !s:known_files.has(a:fname)
                                    call tagbar#debug#log('New file, processing [' . a:fname . ']')
                                    call s:ProcessFile(a:fname, sftype)
                                    let updated = 1
                                endif
                            
                                if no_display
                                    return
                                endif
                            
                                let fileinfo = s:known_files.get(a:fname)
                            
                                " If we don't have an entry for the file by now something must have gone
                                " wrong, so don't change the tagbar content
                                if empty(fileinfo)
                                    call tagbar#debug#log('fileinfo empty after processing [' . a:fname . ']')
                                    return
                                endif
                            
                                " Display the tagbar content if the tags have been updated or a different
                                " file is being displayed
                                if bufwinnr(s:TagbarBufName()) != -1 && !s:paused &&
                                 \ (s:new_window || updated ||
                                  \ (!empty(tagbar#state#get_current_file(0)) &&
                                   \ a:fname != tagbar#state#get_current_file(0).fpath))
                                    call s:RenderContent(fileinfo)
                                endif
                            
                                " Call setCurrent after rendering so RenderContent can check whether the
                                " same file is being redisplayed
                                if !empty(fileinfo)
                                    call tagbar#debug#log('Setting current file [' . a:fname . ']')
                                    call tagbar#state#set_current_file(fileinfo)
                                    let s:nearby_disabled = 0
                                endif
                            
                                call s:HighlightTag(0)
                                call s:SetStatusLine()
                                call tagbar#debug#log('AutoUpdate finished successfully')
                            endfunction
                            
                            " s:CheckMouseClick() {{{2
    1              0.000008 function! s:CheckMouseClick() abort
                                let line   = getline('.')
                                let curcol = col('.')
                            
                                if (match(line, g:tagbar#icon_open . '[-+ ]') + 1) == curcol
                                    call s:CloseFold()
                                elseif (match(line, g:tagbar#icon_closed . '[-+ ]') + 1) == curcol
                                    call s:OpenFold()
                                elseif g:tagbar_singleclick
                                    call s:JumpToTag(0)
                                endif
                            endfunction
                            
                            " s:DetectFiletype() {{{2
    1              0.000010 function! s:DetectFiletype(bufnr) abort
                                " Filetype has already been detected for loaded buffers, but not
                                " necessarily for unloaded ones
                                let ftype = getbufvar(a:bufnr, '&filetype')
                            
                                if bufloaded(a:bufnr)
                                    return ftype
                                endif
                            
                                if ftype !=# ''
                                    return ftype
                                endif
                            
                                " Unloaded buffer with non-detected filetype, need to detect filetype
                                " manually
                                let bufname = bufname(a:bufnr)
                            
                                let eventignore_save = &eventignore
                                set eventignore=FileType
                                let filetype_save = &filetype
                            
                                exe 'doautocmd filetypedetect BufRead ' . bufname
                                let ftype = &filetype
                            
                                let &filetype = filetype_save
                                let &eventignore = eventignore_save
                            
                                return ftype
                            endfunction
                            
                            " s:EscapeCtagsCmd() {{{2
                            " Assemble the ctags command line in a way that all problematic characters are
                            " properly escaped and converted to the system's encoding
                            " Optional third parameter is a file name to run ctags on
                            " Note: The second parameter (a:args) can be a list of args or
                            "       a single string of the args.
                            "       When a:args is a list, each argument in the list will be escaped for the
                            "       current &shell type.
                            "       When a:args is a string, all arguments should be escaped appropriately
                            "       (if required). In most use cases no escaping is required so a string
                            "       is acceptable. But in cases where arguments may need to be escaped
                            "       differently for each &shell type, then pass a list of arguments.
    1              0.000009 function! s:EscapeCtagsCmd(ctags_bin, args, ...) abort
                                call tagbar#debug#log('EscapeCtagsCmd called')
                                call tagbar#debug#log('ctags_bin: ' . a:ctags_bin)
                                if type(a:args)==type('')
                                    call tagbar#debug#log('ctags_args (is a string): ' . a:args)
                                elseif type(a:args)==type([])
                                    call tagbar#debug#log('ctags_args (is a list): ' . string(a:args))
                                endif
                            
                                if exists('+shellslash')
                                    let shellslash_save = &shellslash
                                    set noshellslash
                                endif
                            
                                "Set up 0th argument of ctags_cmd
                                "a:ctags_bin may have special characters that require escaping.
                                if (&shell =~? 'cmd\.exe$' || &shell =~? 'powershell\.exe$' || &shell =~? 'powershell$' || &shell =~? 'pwsh\.exe$' || &shell =~? 'pwsh$') && a:ctags_bin !~# '\s'
                                    "For windows cmd.exe, escaping the 0th argument can cause
                                    "problems if it references a batch file and the batch file uses %~dp0.
                                    "So for windows cmd.exe, only escape the 0th argument iff necessary.
                                    "Only known necessary case is when ctags_bin executable filename has
                                    "whitespace character(s).
                            
                                    "  Example: If 0th argument is wrapped in double quotes AND it is not
                                    "  an absolute path to ctags_bin, but rather an executable in %PATH%,
                                    "  then %~dp0 resolves to the current working directory rather than
                                    "  the batch file's directory. Batch files like this generally exepect
                                    "  and depend on %~dp0 to resolve the batch file's directory.
                                    "  Note: Documentation such as `help cmd.exe` and
                                    "  http://www.microsoft.com/resources/documentation/windows/xp/all/proddocs/en-us/cmd.mspx?mfr=true
                                    "  suggest other special characters that require escaping for command
                                    "  line completion.  But tagbar.vim does not use the command line
                                    "  completion feature of cmd.exe and testing shows that the only special
                                    "  character that needs to be escaped for tagbar.vim is <space> for
                                    "  windows cmd.exe.
                                    let ctags_cmd = a:ctags_bin
                                else
                                    let ctags_cmd = shellescape(a:ctags_bin)
                                endif
                            
                                "Add additional arguments to ctags_cmd
                                if type(a:args)==type('')
                                    "When a:args is a string, append the arguments
                                    "Note: In this case, do not attempt to shell escape a:args string.
                                    "This function expects the string to already be escaped properly for
                                    "the shell type. Why not escape? Because it could be ambiguous about
                                    "whether a space is an argument separator or included in the argument.
                                    "Since escaping rules vary from shell to shell, it is better to pass a
                                    "list of arguments to a:args. With a list, each argument is clearly
                                    "separated, so shellescape() can calculate the appropriate escaping
                                    "for each argument for the current &shell.
                                    let ctags_cmd .= ' ' . a:args
                                elseif type(a:args)==type([])
                                    "When a:args is a list, shellescape() each argument and append ctags_cmd
                                    "Note: It's a better practice to shellescape() each argument separately so that
                                    "spaces used as a separator between arguments can be distinguished with
                                    "spaces used inside a single argument.
                                    for arg in a:args
                                        let ctags_cmd .= ' ' . shellescape(arg)
                                    endfor
                                endif
                            
                                "if a filename was specified, add filename as final argument to ctags_cmd.
                                if a:0 == 1
                                    let ctags_cmd .= ' ' . shellescape(a:1)
                                endif
                            
                                if exists('+shellslash')
                                    let &shellslash = shellslash_save
                                endif
                            
                                " Needed for cases where 'encoding' is different from the system's
                                " encoding
                                if has('multi_byte')
                                    if g:tagbar_systemenc != &encoding
                                        let ctags_cmd = iconv(ctags_cmd, &encoding, g:tagbar_systemenc)
                                    elseif $LANG !=# ''
                                        let ctags_cmd = iconv(ctags_cmd, &encoding, $LANG)
                                    endif
                                endif
                            
                                call tagbar#debug#log('Escaped ctags command: ' . ctags_cmd)
                            
                                if ctags_cmd ==# ''
                                    if !s:warnings.encoding
                                        call s:warning('Tagbar: Ctags command encoding conversion failed!' .
                                            \ ' Please read ":h g:tagbar_systemenc".')
                                        let s:warnings.encoding = 1
                                    endif
                                endif
                            
                                return ctags_cmd
                            endfunction
                            
                            " run shell command in a proper way: prevent temporary window creation
    1              0.000012 function! s:run_system(cmd, version) abort
                                if has('win32') && !has('nvim') && a:version > 0 && (has('python3') || has('python2'))
                                    if a:version == 3 && has('python3')
                                        let pyx = 'py3 '
                                        let python_eval = 'py3eval'
                                    elseif a:version == 2 && has('python2')
                                        let pyx = 'py2 '
                                        let python_eval = 'pyeval'
                                    else
                                        let pyx = 'pyx '
                                        let python_eval = 'pyxeval'
                                    endif
                                    let l:pc = 0
                                    exec pyx . 'import subprocess, vim'
                                    exec pyx . '__argv = {"args":vim.eval("a:cmd"), "shell":True}'
                                    exec pyx . '__argv["stdout"] = subprocess.PIPE'
                                    exec pyx . '__argv["stderr"] = subprocess.STDOUT'
                                    exec pyx . '__argv["errors"] = "ignore"'
                                    exec pyx . '__pp = subprocess.Popen(**__argv, universal_newlines=True, encoding="utf8")'
                                    exec pyx . '__return_text = __pp.stdout.read()'
                                    exec pyx . '__pp.stdout.close()'
                                    exec pyx . '__return_code = __pp.wait()'
                                    exec 'let l:hr = '. python_eval .'("__return_text")'
                                    exec 'let l:pc = '. python_eval .'("__return_code")'
                                    let s:shell_error = l:pc
                                    return l:hr
                                endif
                                let hr = system(a:cmd)
                                let s:shell_error = v:shell_error
                                return hr
                            endfunction
                            
                            
                            " s:ExecuteCtags() {{{2
                            " Execute ctags with necessary shell settings
                            " Partially based on the discussion at
                            " http://vim.1045645.n5.nabble.com/bad-default-shellxquote-in-Widows-td1208284.html
    1              0.000008 function! s:ExecuteCtags(ctags_cmd) abort
                                call tagbar#debug#log('Executing ctags command: ' . a:ctags_cmd)
                            
                                if &shell =~# 'fish$'
                                    " Reset shell since fish isn't really compatible
                                    let shell_save = &shell
                                    set shell=sh
                                endif
                            
                                if &shell =~# 'elvish'
                                    " Reset shell since Elvish isn't really compatible
                                    let shell_save = &shell
                                    set shell=sh
                                endif
                            
                                if exists('+shellslash')
                                    let shellslash_save = &shellslash
                                    set noshellslash
                                endif
                            
                                if &shell =~? 'cmd\.exe'
                                    let shellxquote_save = &shellxquote
                                    set shellxquote=\"
                                    let shellcmdflag_save = &shellcmdflag
                                    set shellcmdflag=/s\ /c
                                endif
                            
                                if tagbar#debug#enabled()
                                    silent 5verbose let ctags_output = system(a:ctags_cmd)
                                    call tagbar#debug#log(v:statusmsg)
                                    call tagbar#debug#log('Exit code: ' . v:shell_error)
                                    redraw!
                                else
                                    let py_version = get(g:, 'tagbar_python', 1)
                                    silent let ctags_output = s:run_system(a:ctags_cmd, py_version)
                                endif
                            
                                if &shell =~? 'cmd\.exe'
                                    let &shellxquote  = shellxquote_save
                                    let &shellcmdflag = shellcmdflag_save
                                endif
                            
                                if exists('+shellslash')
                                    let &shellslash = shellslash_save
                                endif
                            
                                if exists('shell_save')
                                    let &shell = shell_save
                                endif
                            
                                return ctags_output
                            endfunction
                            
                            " s:GetNearbyTag() {{{2
                            " Get the tag info for a file near the cursor in the current file
    1              0.000010 function! s:GetNearbyTag(request, forcecurrent, ...) abort
                                if s:nearby_disabled
                                    return {}
                                endif
                            
                                let fileinfo = tagbar#state#get_current_file(a:forcecurrent)
                                if empty(fileinfo)
                                    return {}
                                endif
                            
                                let curline = a:0 > 0 ? a:1 : line('.')
                                let direction = a:0 > 1 ? a:2 : -1
                                let ignore_curline = a:0 > 2 ? a:3 : 0
                            
                                let typeinfo = fileinfo.typeinfo
                                let tag = {}
                            
                                if direction < 0
                                    let endline = 1
                                    let increment = -1
                                else
                                    let endline = line('$')
                                    let increment = 1
                                endif
                            
                                " If a tag appears in a file more than once (for example namespaces in
                                " C++) only one of them has a 'tline' entry and can thus be highlighted.
                                " The only way to solve this would be to go over the whole tag list again,
                                " making everything slower. Since this should be a rare occurence and
                                " highlighting isn't /that/ important ignore it for now.
                                for line in range(curline, endline, increment)
                                    if has_key(fileinfo.fline, line)
                                        let curtag = fileinfo.fline[line]
                                        if a:request ==# 'nearest-stl' && typeinfo.getKind(curtag.fields.kind).stl
                                            let tag = curtag
                                            break
                                        elseif a:request ==# 'scoped-stl'
                                                    \ && typeinfo.getKind(curtag.fields.kind).stl
                                                    \ && curtag.fields.line <= curline
                                                    \ && curline <= curtag.fields.end
                                            let tag = curtag
                                            break
                                        elseif a:request ==# 'nearest' || (line == curline && ignore_curline == 0)
                                            let tag = curtag
                                            break
                                        endif
                                    endif
                                endfor
                            
                                return tag
                            endfunction
                            
                            " s:JumpToNearbyTag() {{{2
    1              0.000010 function! s:JumpToNearbyTag(direction, request, flags) abort
                                let fileinfo = tagbar#state#get_current_file(0)
                                if empty(fileinfo)
                                    return {}
                                endif
                            
                                let lnum = a:direction > 0 ? line('.') + 1 : line('.') - 1
                                let lazy_scroll = a:flags =~# 's' ? 0 : 1
                            
                                let tag = s:GetNearbyTag(a:request, 1, lnum, a:direction, 1)
                            
                                if empty(tag)
                                    " No next tag found
                                    if a:direction > 0
                                        echo '...no next tag found'
                                    else
                                        echo '...no previous tag found'
                                    endif
                                    return
                                endif
                            
                                call s:JumpToTag(1, tag, lazy_scroll)
                            endfunction
                            
                            " s:GetTagInfo() {{{2
                            " Return the info dictionary of the tag on the specified line. If the line
                            " does not contain a valid tag (for example because it is empty or only
                            " contains a pseudo-tag) return an empty dictionary.
    1              0.000015 function! s:GetTagInfo(linenr, ignorepseudo) abort
                                let fileinfo = tagbar#state#get_current_file(0)
                            
                                if empty(fileinfo)
                                    return {}
                                endif
                            
                                " Don't do anything in empty and comment lines
                                let curline = getbufline(bufnr(s:TagbarBufName()), a:linenr)[0]
                                if curline =~# '^\s*$' || curline[0] ==# '"'
                                    return {}
                                endif
                            
                                " Check if there is a tag on the current line
                                if !has_key(fileinfo.tline, a:linenr)
                                    return {}
                                endif
                            
                                let taginfo = fileinfo.tline[a:linenr]
                            
                                " Check if the current tag is not a pseudo-tag
                                if a:ignorepseudo && taginfo.isPseudoTag()
                                    return {}
                                endif
                            
                                return taginfo
                            endfunction
                            
                            " s:GetFileWinnr() {{{2
                            " Get the number of the window that has Tagbar's current file loaded into it,
                            " or 0 if no window has loaded it. It tries the previous window first, if that
                            " does not have the correct buffer loaded it will look for the first one with
                            " the correct buffer in it.
    1              0.000009 function! s:GetFileWinnr(fileinfo) abort
                                let filewinnr = 0
                                let prevwinnr = winnr('#')
                            
                                if winbufnr(prevwinnr) == a:fileinfo.bufnr &&
                                 \ !getwinvar(prevwinnr, '&previewwindow')
                                    let filewinnr = prevwinnr
                                else
                                    " Search for the first real window that has the correct buffer loaded
                                    " in it. Similar to bufwinnr() but skips the previewwindow.
                                    for i in range(1, winnr('$'))
                                        call s:goto_win(i, 1)
                                        if bufnr('%') == a:fileinfo.bufnr && !&previewwindow
                                            let filewinnr = winnr()
                                            break
                                        endif
                                    endfor
                            
                                    call s:goto_tagbar(1)
                                endif
                            
                                return filewinnr
                            endfunction
                            
                            " s:GotoFileWindow() {{{2
                            " Try to switch to the window that has Tagbar's current file loaded in it, or
                            " open the file in an existing window otherwise.
    1              0.000008 function! s:GotoFileWindow(fileinfo, ...) abort
                                let noauto = a:0 > 0 ? a:1 : 0
                            
                                let filewinnr = s:GetFileWinnr(a:fileinfo)
                            
                                " If there is no window with the correct buffer loaded then load it
                                " into the first window that has a non-special buffer in it.
                                if filewinnr == 0
                                    for i in range(1, winnr('$'))
                                        call s:goto_win(i, 1)
                                        if &buftype ==# '' && !&previewwindow
                                            execute 'buffer ' . a:fileinfo.bufnr
                                            break
                                        endif
                                    endfor
                                else
                                    call s:goto_win(filewinnr, 1)
                                endif
                            
                                " To make ctrl-w_p work we switch between the Tagbar window and the
                                " correct window once
                                call s:goto_tagbar(noauto)
                                call s:goto_win('p', noauto)
                            endfunction
                            
                            " s:ToggleHideNonPublicTags() {{{2
    1              0.000007 function! s:ToggleHideNonPublicTags() abort
                                let fileinfo = tagbar#state#get_current_file(0)
                                if empty(fileinfo)
                                    return
                                endif
                            
                                " Save the tag the cursor is currently on
                                let curline = line('.')
                                let taginfo = s:GetTagInfo(curline, 0)
                            
                                match none
                            
                                let g:tagbar_hide_nonpublic = !g:tagbar_hide_nonpublic
                                call s:RenderKeepView()
                                call s:SetStatusLine()
                            
                                " If we were on a tag before sorting then jump to it, otherwise restore
                                " the cursor to the current line
                                if !empty(taginfo)
                                    execute taginfo.tline
                                else
                                    execute curline
                                endif
                            endfunction
                            
                            " s:ToggleCaseInsensitive() {{{2
    1              0.000007 function! s:ToggleCaseInsensitive() abort
                                let fileinfo = tagbar#state#get_current_file(0)
                                if empty(fileinfo)
                                    return
                                endif
                            
                                " Save the tag the cursor is currently on
                                let curline = line('.')
                                let taginfo = s:GetTagInfo(curline, 0)
                            
                                match none
                            
                                let g:tagbar_case_insensitive = !g:tagbar_case_insensitive
                            
                                call fileinfo.sortTags(fileinfo.typeinfo)
                            
                                call s:RenderKeepView()
                                call s:SetStatusLine()
                            
                                " If we were on a tag before sorting then jump to it, otherwise restore
                                " the cursor to the current line
                                if !empty(taginfo)
                                    execute taginfo.tline
                                else
                                    execute curline
                                endif
                            endfunction
                            
                            " s:ToggleAutoclose() {{{2
    1              0.000007 function! s:ToggleAutoclose() abort
                                let g:tagbar_autoclose = !g:tagbar_autoclose
                                call s:SetStatusLine()
                            endfunction
                            
                            " s:IsValidFile() {{{2
    1              0.000010 function! s:IsValidFile(fname, ftype) abort
                                call tagbar#debug#log('Checking if file is valid [' . a:fname . ']')
                            
                                if a:fname ==# '' || a:ftype ==# ''
                                    call tagbar#debug#log('Empty filename or type')
                                    return 0
                                endif
                            
                                if !filereadable(a:fname) && getbufvar(a:fname, 'netrw_tmpfile') ==# ''
                                    call tagbar#debug#log('File not readable')
                                    return 0
                                endif
                            
                                if getbufvar(a:fname, 'tagbar_ignore') == 1
                                    call tagbar#debug#log('File is marked as ignored')
                                    return 0
                                endif
                            
                                let winnr = bufwinnr(a:fname)
                                if winnr != -1 && getwinvar(winnr, '&diff')
                                    call tagbar#debug#log('Window is in diff mode')
                                    return 0
                                endif
                            
                                if &previewwindow
                                    call tagbar#debug#log('In preview window')
                                    return 0
                                endif
                            
                                if !has_key(s:known_types, a:ftype)
                                    if exists('g:tagbar_type_' . a:ftype)
                                        " Filetype definition must have been specified in an 'ftplugin'
                                        " file, so load it now
                                        call s:LoadUserTypeDefs(a:ftype)
                                    else
                                        call tagbar#debug#log('Unsupported filetype: ' . a:ftype)
                                        return 0
                                    endif
                                endif
                            
                                return 1
                            endfunction
                            
                            " s:SetStatusLine() {{{2
    1              0.000008 function! s:SetStatusLine() abort
                                let tagbarwinnr = bufwinnr(s:TagbarBufName())
                                if tagbarwinnr == -1 || exists('g:tagbar_no_status_line')
                                    return
                                endif
                            
                                " Make sure we're actually in the Tagbar window
                                if tagbarwinnr != winnr()
                                    let in_tagbar = 0
                                    let prevwinnr = winnr()
                                    call s:goto_win('p', 1)
                                    let pprevwinnr = winnr()
                                    call s:goto_win(tagbarwinnr, 1)
                                else
                                    let in_tagbar = 1
                                endif
                            
                                if !empty(tagbar#state#get_current_file(0))
                                    let fileinfo = tagbar#state#get_current_file(0)
                                    let fname = fnamemodify(fileinfo.fpath, ':t')
                                    let sorted = get(fileinfo.typeinfo, 'sort', g:tagbar_sort)
                                else
                                    let fname = ''
                                    let sorted = g:tagbar_sort
                                endif
                                let sortstr = sorted ? 'Name' : 'Order'
                            
                                let flags = []
                                let flags += exists('w:autoclose') && w:autoclose ? ['c'] : []
                                let flags += g:tagbar_autoclose ? ['C'] : []
                                let flags += (sorted && g:tagbar_case_insensitive) ? ['i'] : []
                                let flags += g:tagbar_hide_nonpublic ? ['v'] : []
                            
                                if exists('g:tagbar_status_func')
                                    let args = [in_tagbar, sortstr, fname, flags]
                                    let &l:statusline = call(g:tagbar_status_func, args)
                                else
                                    let colour = in_tagbar ? '%#StatusLine#' : '%#StatusLineNC#'
                                    let flagstr = join(flags, '')
                                    if flagstr !=# ''
                                        let flagstr = '[' . flagstr . '] '
                                    endif
                                    let text = colour . '[' . sortstr . '] ' . flagstr . fname
                                    let &l:statusline = text
                                endif
                            
                                if !in_tagbar
                                    call s:goto_win(pprevwinnr, 1)
                                    call s:goto_win(prevwinnr, 1)
                                endif
                            endfunction
                            
                            " s:HandleOnlyWindow() {{{2
    1              0.000007 function! s:HandleOnlyWindow() abort
                                let tagbarwinnr = bufwinnr(s:TagbarBufName())
                                if tagbarwinnr == -1
                                    return
                                endif
                            
                                let vim_quitting = s:vim_quitting
                                let s:vim_quitting = 0
                            
                                if vim_quitting && !s:HasOpenFileWindows()
                                    call tagbar#debug#log('Closing Tagbar window due to QuitPre event')
                                    if winnr('$') >= 1
                                        call s:goto_win(tagbarwinnr, 1)
                                    endif
                            
                                    " Before quitting Vim, delete the tagbar buffer so that the '0 mark is
                                    " correctly set to the previous buffer.
                                    if tabpagenr('$') == 1
                                        noautocmd keepalt bdelete
                                    endif
                            
                                    try
                                        try
                                            quit
                                        catch /.*/ " This can be E173 and maybe others
                                            call s:OpenWindow('')
                                            echoerr v:exception
                                        endtry
                                    catch /.*/
                                        echohl ErrorMsg
                                        echo v:exception
                                        echohl None
                                    endtry
                                endif
                            endfunction
                            
                            " s:HandleBufDelete() {{{2
    1              0.000013 function! s:HandleBufDelete(bufname, bufnr) abort
                                " Ignore autocmd events generated for "set nobuflisted",
                                let nr = str2nr(a:bufnr)
                                if bufexists(nr) && !buflisted(nr)
                                    return
                                endif
                            
                                call s:known_files.rm(fnamemodify(a:bufname, ':p'))
                            
                                let tagbarwinnr = bufwinnr(s:TagbarBufName())
                                if tagbarwinnr == -1 || a:bufname =~# '__Tagbar__.*'
                                    return
                                endif
                            
                                if !s:HasOpenFileWindows()
                                    if tabpagenr('$') == 1 && exists('t:tagbar_buf_name')
                                        " The last normal window closed due to a :bdelete/:bwipeout.
                                        " In order to get a normal file window back switch to the last
                                        " alternative buffer (or a new one if there is no alternative
                                        " buffer), reset the Tagbar-set window options, and then re-open
                                        " the Tagbar window.
                            
                                        " Ignore the buffer to be deleted, just in case
                                        call setbufvar(a:bufname, 'tagbar_ignore', 1)
                            
                                        if s:last_alt_bufnr == -1 || s:last_alt_bufnr == expand('<abuf>')
                                            if argc() > 1 && argidx() < argc() - 1
                                                " We don't have an alternative buffer, but there are still
                                                " files left in the argument list
                                                next
                                            else
                                                enew
                                            endif
                                        else
                                            " Save a local copy as the global value will change
                                            " during buffer switching
                                            let last_alt_bufnr = s:last_alt_bufnr
                            
                                            " Ignore the buffer we're switching to for now, it will get
                                            " processed due to the OpenWindow() call anyway
                                            call setbufvar(last_alt_bufnr, 'tagbar_ignore', 1)
                                            execute 'keepalt buffer' last_alt_bufnr
                                            call setbufvar(last_alt_bufnr, 'tagbar_ignore', 0)
                                        endif
                            
                                        " Reset Tagbar window-local options
                                        set winfixwidth<
                            
                                        call s:OpenWindow('')
                                    elseif exists('t:tagbar_buf_name')
                                        close
                                    endif
                                endif
                            endfunction
                            
                            " s:HandleBufWrite() {{{2
    1              0.000010 function! s:HandleBufWrite(fname) abort
                                if index(s:delayed_update_files, a:fname) == -1
                                    call add(s:delayed_update_files, a:fname)
                                endif
                            endfunction
                            
                            " s:do_delayed_update() {{{2
    1              0.000008 function! s:do_delayed_update() abort
                                let curfile = tagbar#state#get_current_file(0)
                                if empty(curfile)
                                    let curfname = ''
                                else
                                    let curfname = curfile.fpath
                                endif
                            
                                while !empty(s:delayed_update_files)
                                    let fname = remove(s:delayed_update_files, 0)
                                    let no_display = curfname !=# fname
                                    call s:AutoUpdate(fname, 1, no_display)
                                endwhile
                            endfunction
                            
                            " s:ReopenWindow() {{{2
    1              0.000007 function! s:ReopenWindow(delbufname) abort
                                if expand('<amatch>') == a:delbufname
                                    return
                                endif
                            
                                autocmd! TagbarAutoCmds BufWinEnter
                                call s:OpenWindow('')
                            endfunction
                            
                            " s:HasOpenFileWindows() {{{2
    1              0.000007 function! s:HasOpenFileWindows() abort
                                for i in range(1, winnr('$'))
                                    let buf = winbufnr(i)
                            
                                    " skip unlisted buffers, except for netrw
                                    if !buflisted(buf) && getbufvar(buf, '&filetype') !=# 'netrw'
                                        continue
                                    endif
                            
                                    " skip temporary buffers with buftype set
                                    if getbufvar(buf, '&buftype') !=# ''
                                        continue
                                    endif
                            
                                    " skip the preview window
                                    if getwinvar(i, '&previewwindow')
                                        continue
                                    endif
                            
                                    return 1
                                endfor
                            
                                return 0
                            endfunction
                            
                            " s:TagbarBufName() {{{2
    1              0.000006 function! s:TagbarBufName() abort
                                if !exists('t:tagbar_buf_name')
                                    let s:buffer_seqno += 1
                                    let t:tagbar_buf_name = '__Tagbar__.' . s:buffer_seqno
                                endif
                            
                                return t:tagbar_buf_name
                            endfunction
                            
                            " s:goto_win() {{{2
    1              0.000009 function! s:goto_win(winnr, ...) abort
                                "Do not go to a popup window to avoid errors.
                                "Hence, check first if a:winnr is an integer,
                                "if this integer is equal to 0,
                                "the window is a popup window
                                if has('popupwin')
                                    if type(a:winnr) == type(0) && a:winnr == 0
                                        return
                                    endif
                                    if a:winnr ==# 'p' && winnr('#') == 0
                                        return
                                    endif
                                endif
                                let cmd = type(a:winnr) == type(0) ? a:winnr . 'wincmd w'
                                                                 \ : 'wincmd ' . a:winnr
                                let noauto = a:0 > 0 ? a:1 : 0
                            
                                call tagbar#debug#log('goto_win(): ' . cmd . ', ' . noauto)
                            
                                if noauto
                                    noautocmd execute cmd
                                else
                                    execute cmd
                                endif
                            endfunction
                            
                            " s:goto_tagbar() {{{2
    1              0.000026 function! s:goto_tagbar(...) abort
                                let noauto = a:0 > 0 ? a:1 : 0
                                call s:goto_win(bufwinnr(s:TagbarBufName()), noauto)
                            endfunction
                            
                            " s:mark_window() {{{2
                            " Mark window with a window-local variable so we can jump back to it even if
                            " the window numbers have changed.
    1              0.000006 function! s:mark_window() abort
                                let w:tagbar_mark = 1
                            endfunction
                            
                            " s:goto_markedwin() {{{2
                            " Go to a previously marked window and delete the mark.
    1              0.000006 function! s:goto_markedwin(...) abort
                                let noauto = a:0 > 0 ? a:1 : 0
                                for window in range(1, winnr('$'))
                                    call s:goto_win(window, noauto)
                                    if exists('w:tagbar_mark')
                                        unlet w:tagbar_mark
                                        break
                                    endif
                                endfor
                            endfunction
                            
                            " s:warning() {{{2
    1              0.000006 function! s:warning(msg) abort
                                echohl WarningMsg
                                echomsg a:msg
                                echohl None
                            endfunction
                            
                            " s:TogglePause() {{{2
    1              0.000006 function! s:TogglePause() abort
                                let s:paused = !s:paused
                            
                                if s:paused
                                    call tagbar#state#set_paused()
                                else
                                    let fileinfo = tagbar#state#get_current_file(0)
                                    let taginfo = fileinfo.getTags()[0]
                            
                                    call s:GotoFileWindow(taginfo.fileinfo)
                                    call s:AutoUpdate(taginfo.fileinfo.fpath, 1)
                                endif
                            endfunction
                            
                            " TagbarBalloonExpr() {{{2
    1              0.000008 function! TagbarBalloonExpr() abort
                                let taginfo = s:GetTagInfo(v:beval_lnum, 1)
                            
                                if empty(taginfo)
                                    return ''
                                endif
                            
                                let prototype = taginfo.getPrototype(0)
                                if has('multi_byte')
                                    if g:tagbar_systemenc != &encoding
                                        let prototype = iconv(prototype, &encoding, g:tagbar_systemenc)
                                    elseif $LANG !=# ''
                                        let prototype = iconv(prototype, &encoding, $LANG)
                                    endif
                                endif
                                return prototype
                            endfunction
                            
                            " Autoload functions {{{1
                            
                            " Wrappers {{{2
                            
    1              0.000007 function! tagbar#ToggleWindow(...) abort
                                let flags = a:0 > 0 ? a:1 : ''
                                call s:ToggleWindow(flags)
                            endfunction
                            
    1              0.000006 function! tagbar#OpenWindow(...) abort
                                let flags = a:0 > 0 ? a:1 : ''
                                call s:OpenWindow(flags)
                            endfunction
                            
    1              0.000005 function! tagbar#CloseWindow() abort
                                call s:CloseWindow()
                            endfunction
                            
    1              0.000008 function! tagbar#SetFoldLevel(level, force) abort
                                call s:SetFoldLevel(a:level, a:force)
                            endfunction
                            
    1              0.000008 function! tagbar#highlighttag(openfolds, force) abort
                                let tagbarwinnr = bufwinnr(s:TagbarBufName())
                                if tagbarwinnr == -1
                                    echohl WarningMsg
                                    echomsg "Warning: Can't highlight tag, Tagbar window not open"
                                    echohl None
                                    return
                                endif
                                call s:HighlightTag(a:openfolds, a:force)
                            endfunction
                            
    1              0.000006 function! tagbar#RestoreSession() abort
                                call s:RestoreSession()
                            endfunction
                            
    1              0.000006 function! tagbar#StopAutoUpdate() abort
                                autocmd! TagbarAutoCmds
                                let s:autocommands_done = 0
                            endfunction
                            
                            " }}}2
                            
                            " tagbar#Update() {{{2
                            " Trigger an AutoUpdate() of the currently opened file
    1              0.000006 function! tagbar#Update() abort
                                call s:AutoUpdate(fnamemodify(expand('%'), ':p'), 0)
                            endfunction
                            
                            " tagbar#ForceUpdate() {{{2
    1              0.000005 function! tagbar#ForceUpdate() abort
                                if !exists('b:tagbar_force_update')
                                    let b:tagbar_force_update = 1
                                    call s:AutoUpdate(fnamemodify(expand('%'), ':p'), 1)
                                    unlet b:tagbar_force_update
                                endif
                            endfunction
                            
                            " tagbar#toggle_pause() {{{2
    1              0.000006 function! tagbar#toggle_pause() abort
                                let s:paused = !s:paused
                            
                                if s:paused
                                    call tagbar#state#set_paused()
                                else
                                    call s:AutoUpdate(fnamemodify(expand('%'), ':p'), 1)
                                endif
                            endfunction
                            
    1              0.000005 function! tagbar#is_paused() abort
                                return s:paused
                            endfunction
                            
                            " tagbar#getusertypes() {{{2
    1              0.000006 function! tagbar#getusertypes() abort
                                let userdefs = filter(copy(g:), 'v:key =~? "^tagbar_type_"')
                            
                                let typedict = {}
                                for [key, val] in items(userdefs)
                                    let type = substitute(key, '^tagbar_type_', '', '')
                                    let typedict[type] = val
                                endfor
                            
                                return typedict
                            endfunction
                            
                            " tagbar#autoopen() {{{2
                            " Automatically open Tagbar if one of the open buffers contains a supported
                            " file
    1              0.000026 function! tagbar#autoopen(...) abort
                                call tagbar#debug#log('tagbar#autoopen called [' . bufname('%') . ']')
                                let always = a:0 > 0 ? a:1 : 1
                            
                                call s:Init(0)
                            
                                for bufnr in range(1, bufnr('$'))
                                    if buflisted(bufnr) && (always || bufwinnr(bufnr) != -1)
                                        let ftype = s:DetectFiletype(bufnr)
                                        if s:IsValidFile(bufname(bufnr), ftype)
                                            call s:OpenWindow('')
                                            call tagbar#debug#log('tagbar#autoopen finished after finding valid ' .
                                                       \ 'file [' . bufname(bufnr) . ']')
                                            return
                                        endif
                                    endif
                                endfor
                            
                                call tagbar#debug#log('tagbar#autoopen finished without finding valid file')
                            endfunction
                            
                            " tagbar#GetTagNearLine() {{{2
    1              0.000008 function! tagbar#GetTagNearLine(lnum, ...) abort
                                if a:0 >= 2
                                    let fmt = a:1
                                    let longsig   = a:2 =~# 's'
                                    let fullpath  = a:2 =~# 'f'
                                    let prototype = a:2 =~# 'p'
                                    if a:0 >= 3
                                        let search_method = a:3
                                    else
                                        let search_method = 'nearest-stl'
                                    endif
                                else
                                    let fmt = '%s'
                                    let longsig   = 0
                                    let fullpath  = 0
                                    let prototype = 0
                                    let search_method = 'nearest-stl'
                                endif
                            
                                let taginfo = s:GetNearbyTag(search_method, 1, a:lnum)
                            
                                if empty(taginfo)
                                    return ''
                                endif
                            
                                if prototype
                                    return taginfo.getPrototype(1)
                                else
                                    return printf(fmt, taginfo.str(longsig, fullpath))
                                endif
                            endfunction
                            
                            " tagbar#currenttag() {{{2
    1              0.000009 function! tagbar#currenttag(fmt, default, ...) abort
                                " Indicate that the statusline functionality is being used. This prevents
                                " the CloseWindow() function from removing the autocommands.
                                let s:statusline_in_use = 1
                            
                                if a:0 >= 1
                                    " also test for non-zero value for backwards compatibility
                                    let longsig   = a:1 =~# 's' || (type(a:1) == type(0) && a:1 != 0)
                                    let fullpath  = a:1 =~# 'f'
                                    let prototype = a:1 =~# 'p'
                                    if a:0 >= 2
                                        let search_method = a:2
                                    else
                                        let search_method = g:tagbar_highlight_method
                                    endif
                                else
                                    let longsig   = 0
                                    let fullpath  = 0
                                    let prototype = 0
                                    let search_method = g:tagbar_highlight_method
                                endif
                            
                                if !s:Init(1)
                                    return a:default
                                endif
                            
                                let tag = s:GetNearbyTag(search_method, 1)
                            
                                if !empty(tag)
                                    if prototype
                                        return tag.getPrototype(1)
                                    else
                                        return printf(a:fmt, tag.str(longsig, fullpath))
                                    endif
                                else
                                    return a:default
                                endif
                            endfunction
                            
                            " tagbar#currentfile() {{{2
    1              0.000005 function! tagbar#currentfile() abort
                                let filename = ''
                            
                                if !empty(tagbar#state#get_current_file(1))
                                    let filename = fnamemodify(tagbar#state#get_current_file(1).fpath, ':t')
                                endif
                            
                                return filename
                            endfunction
                            
                            " tagbar#gettypeconfig() {{{2
    1              0.000007 function! tagbar#gettypeconfig(type) abort
                                if !s:Init(1)
                                    return ''
                                endif
                            
                                let typeinfo = get(s:known_types, a:type, {})
                            
                                if empty(typeinfo)
                                    call s:warning('Unknown type ' . a:type . '!')
                                    return
                                endif
                            
                                let output = 'let g:tagbar_type_' . a:type . " = {\n"
                            
                                let output .= "    \\ 'kinds' : [\n"
                                for kind in typeinfo.kinds
                                    let output .= "        \\ '" . kind.short . ':' . kind.long
                                    if kind.fold || !kind.stl
                                        if kind.fold
                                            let output .= ':1'
                                        else
                                            let output .= ':0'
                                        endif
                                    endif
                                    if !kind.stl
                                        let output .= ':0'
                                    endif
                                    let output .= "',\n"
                                endfor
                                let output .= "    \\ ],\n"
                            
                                let output .= "\\ }"
                            
                                silent put =output
                            endfunction
                            
                            " tagbar#inspect() {{{2
    1              0.000007 function! tagbar#inspect(var) abort
                                return get(s:, a:var)
                            endfunction
                            
                            " tagbar#currenttagtype() {{{2
    1              0.000009 function! tagbar#currenttagtype(fmt, default) abort
                                " Indicate that the statusline functionality is being used. This prevents
                                " the CloseWindow() function from removing the autocommands.
                                let s:statusline_in_use = 1
                                let kind = ''
                                let tag = s:GetNearbyTag('scoped-stl', 1)
                            
                                if empty(tag)
                                    return a:default
                                endif
                            
                                let kind = tag.fields.kind
                                if kind ==# ''
                                    return a:default
                                endif
                            
                                let typeinfo = tag.fileinfo.typeinfo
                                let plural = typeinfo.kinds[typeinfo.kinddict[kind]].long
                                if has_key(s:singular_types, plural)
                                    let singular = s:singular_types[plural]
                                else
                                    let singular = plural
                                endif
                                return printf(a:fmt, singular)
                            endfunction
                            
                            " tagbar#printfileinfo() {{{2
    1              0.000007 function! tagbar#printfileinfo() abort
                                if !tagbar#debug#enabled()
                                    echo 'Tagbar debug is disabled - unable to print fileinfo to tagbar log'
                                    return
                                endif
                            
                                let fileinfo = tagbar#state#get_current_file(0)
                                if empty(fileinfo)
                                    call tagbar#debug#log('File contains no tag entries')
                                    return
                                endif
                                let typeinfo = fileinfo.typeinfo
                            
                                call tagbar#debug#log('Printing fileinfo [' . fileinfo.fpath . ' lines:' . fileinfo.lnum)
                                for line in range(1, fileinfo.lnum)
                                    if has_key(fileinfo.fline, line)
                                        let tag = fileinfo.fline[line]
                                        call tagbar#debug#log(' '
                                                    \   . ' line:' . line
                                                    \   . ' kind:' . tag.fields.kind
                                                    \   . ' depth:' . tag.depth
                                                    \   . ' [' . tag.strfmt() . ']'
                                                    \ )
                                    endif
                                endfor
                                call tagbar#debug#log('All tags printed')
                            
                                echo 'Tagbar fileinfo printed to debug logfile'
                            endfunction
                            
                            " tagbar#IsOpen() {{{2
    1              0.000006 function! tagbar#IsOpen() abort
                                let tagbarwinnr = bufwinnr('__Tagbar__')
                                if tagbarwinnr != -1
                                    " Window open
                                    return 1
                                else
                                    " Window not open
                                    return 0
                                endif
                            endfunction
                            
                            " tagbar#jump() {{{2
    1              0.000005 function! tagbar#jump() abort
                                if &filetype !=# 'tagbar'
                                    " Not in tagbar window - ignore this function call
                                    return
                                endif
                                call s:JumpToTag(1)
                            endfun
                            
                            " tagbar#jumpToNearbyTag() {{{2
                            " params:
                            "   direction = -1:backwards search   1:forward search
                            "   [search_method] = Search method to use for GetTagNearLine()
                            "   [flags] = list of flags (as a string) to control behavior
                            "       's' - use the g:tagbar_scroll_offset setting when jumping
    1              0.000008 function! tagbar#jumpToNearbyTag(direction, ...) abort
                                let search_method = a:0 >= 1 ? a:1 : 'nearest-stl'
                                let flags = a:0 >= 2 ? a:2 : ''
                            
                                call s:JumpToNearbyTag(a:direction, search_method, flags)
                            endfunction
                            
                            " Modeline {{{1
                            " vim: ts=8 sw=4 sts=4 et foldenable foldmethod=marker foldcolumn=1

SCRIPT  C:\Users\Lenovo\AppData\Local\nvim-data\plugged\tagbar\autoload\tagbar\debug.vim
Sourced 1 time
Total time:   0.000555
 Self time:   0.000555

count  total (s)   self (s)
    1              0.000038 function! tagbar#debug#start_debug(...) abort
                                let filename = a:0 > 0 ? a:1 : ''
                            
                                if empty(filename)
                                    let s:debug_file = 'tagbardebug.log'
                                else
                                    let s:debug_file = filename
                                endif
                            
                                " Clear log file and start it with version info
                                exe 'redir! > ' . s:debug_file
                                silent version
                                redir END
                            
                                " Check whether the log file could be created
                                if !filewritable(s:debug_file)
                                    echomsg 'Tagbar: Unable to create log file ' . s:debug_file
                                    let s:debug_file = ''
                                    return
                                endif
                            
                                let s:debug_enabled = 1
                            endfunction
                            
    1              0.000009 function! tagbar#debug#stop_debug() abort
                                let s:debug_enabled = 0
                                let s:debug_file = ''
                            endfunction
                            
    1              0.000008 function! tagbar#debug#log(msg) abort
                                if s:debug_enabled
                                    execute 'redir >> ' . s:debug_file
                                    silent echon s:gettime() . ': ' . a:msg . "\n"
                                    redir END
                                endif
                            endfunction
                            
    1              0.000011 function! tagbar#debug#log_ctags_output(output) abort
                                if s:debug_enabled
                                    exe 'redir! > ' . s:debug_file . '.ctags_out'
                                    silent echon a:output
                                    redir END
                                endif
                            endfunction
                            
    1              0.000006 function! tagbar#debug#enabled() abort
                                return s:debug_enabled
                            endfunction
                            
    1              0.000052 if has('reltime')
    1              0.000013     function! s:gettime() abort
                                    let time = split(reltimestr(reltime()), '\.')
                                    return strftime('%Y-%m-%d %H:%M:%S.', time[0]) . time[1]
                                endfunction
                            else
                                function! s:gettime() abort
                                    return strftime('%Y-%m-%d %H:%M:%S')
                                endfunction
    1              0.000003 endif
                            
    1              0.000015 let s:debug_enabled = 0
    1              0.000054 let s:debug_file = ''

SCRIPT  C:\Users\Lenovo\AppData\Local\nvim-data\plugged\tagbar\autoload\tagbar\types\ctags.vim
Sourced 1 time
Total time:   0.002632
 Self time:   0.002632

count  total (s)   self (s)
                            " Type definitions for standard Exuberant Ctags
                            
    1              0.000058 function! tagbar#types#ctags#init(supported_types) abort
                                let types = {}
                            
                                " Ant {{{1
                                let type_ant = tagbar#prototypes#typeinfo#new()
                                let type_ant.ctagstype = 'ant'
                                let type_ant.kinds     = [
                                    \ {'short' : 'p', 'long' : 'projects', 'fold' : 0, 'stl' : 1},
                                    \ {'short' : 't', 'long' : 'targets',  'fold' : 0, 'stl' : 1}
                                \ ]
                                let types.ant = type_ant
                                " Asm {{{1
                                let type_asm = tagbar#prototypes#typeinfo#new()
                                let type_asm.ctagstype = 'asm'
                                let type_asm.kinds     = [
                                    \ {'short' : 'm', 'long' : 'macros',  'fold' : 0, 'stl' : 1},
                                    \ {'short' : 't', 'long' : 'types',   'fold' : 0, 'stl' : 1},
                                    \ {'short' : 'd', 'long' : 'defines', 'fold' : 0, 'stl' : 1},
                                    \ {'short' : 'l', 'long' : 'labels',  'fold' : 0, 'stl' : 1}
                                \ ]
                                let types.asm = type_asm
                                " ASP {{{1
                                let type_aspvbs = tagbar#prototypes#typeinfo#new()
                                let type_aspvbs.ctagstype = 'asp'
                                let type_aspvbs.kinds     = [
                                    \ {'short' : 'd', 'long' : 'constants',   'fold' : 0, 'stl' : 1},
                                    \ {'short' : 'c', 'long' : 'classes',     'fold' : 0, 'stl' : 1},
                                    \ {'short' : 'f', 'long' : 'functions',   'fold' : 0, 'stl' : 1},
                                    \ {'short' : 's', 'long' : 'subroutines', 'fold' : 0, 'stl' : 1},
                                    \ {'short' : 'v', 'long' : 'variables',   'fold' : 0, 'stl' : 1}
                                \ ]
                                let types.aspvbs = type_aspvbs
                                " Asymptote {{{1
                                " Asymptote gets parsed well using filetype = c
                                let type_asy = tagbar#prototypes#typeinfo#new()
                                let type_asy.ctagstype = 'c'
                                let type_asy.kinds     = [
                                    \ {'short' : 'd', 'long' : 'macros',      'fold' : 1, 'stl' : 0},
                                    \ {'short' : 'p', 'long' : 'prototypes',  'fold' : 1, 'stl' : 0},
                                    \ {'short' : 'g', 'long' : 'enums',       'fold' : 0, 'stl' : 1},
                                    \ {'short' : 'e', 'long' : 'enumerators', 'fold' : 0, 'stl' : 0},
                                    \ {'short' : 't', 'long' : 'typedefs',    'fold' : 0, 'stl' : 0},
                                    \ {'short' : 's', 'long' : 'structs',     'fold' : 0, 'stl' : 1},
                                    \ {'short' : 'u', 'long' : 'unions',      'fold' : 0, 'stl' : 1},
                                    \ {'short' : 'm', 'long' : 'members',     'fold' : 0, 'stl' : 0},
                                    \ {'short' : 'v', 'long' : 'variables',   'fold' : 0, 'stl' : 0},
                                    \ {'short' : 'f', 'long' : 'functions',   'fold' : 0, 'stl' : 1}
                                \ ]
                                let type_asy.sro        = '::'
                                let type_asy.kind2scope = {
                                    \ 'g' : 'enum',
                                    \ 's' : 'struct',
                                    \ 'u' : 'union'
                                \ }
                                let type_asy.scope2kind = {
                                    \ 'enum'   : 'g',
                                    \ 'struct' : 's',
                                    \ 'union'  : 'u'
                                \ }
                                let types.asy = type_asy
                                " Awk {{{1
                                let type_awk = tagbar#prototypes#typeinfo#new()
                                let type_awk.ctagstype = 'awk'
                                let type_awk.kinds     = [
                                    \ {'short' : 'f', 'long' : 'functions', 'fold' : 0, 'stl' : 1}
                                \ ]
                                let types.awk = type_awk
                                " Basic {{{1
                                let type_basic = tagbar#prototypes#typeinfo#new()
                                let type_basic.ctagstype = 'basic'
                                let type_basic.kinds     = [
                                    \ {'short' : 'c', 'long' : 'constants',    'fold' : 0, 'stl' : 1},
                                    \ {'short' : 'g', 'long' : 'enumerations', 'fold' : 0, 'stl' : 1},
                                    \ {'short' : 'f', 'long' : 'functions',    'fold' : 0, 'stl' : 1},
                                    \ {'short' : 'l', 'long' : 'labels',       'fold' : 0, 'stl' : 1},
                                    \ {'short' : 't', 'long' : 'types',        'fold' : 0, 'stl' : 1},
                                    \ {'short' : 'v', 'long' : 'variables',    'fold' : 0, 'stl' : 1}
                                \ ]
                                let types.basic = type_basic
                                " BETA {{{1
                                let type_beta = tagbar#prototypes#typeinfo#new()
                                let type_beta.ctagstype = 'beta'
                                let type_beta.kinds     = [
                                    \ {'short' : 'f', 'long' : 'fragments', 'fold' : 0, 'stl' : 1},
                                    \ {'short' : 's', 'long' : 'slots',     'fold' : 0, 'stl' : 1},
                                    \ {'short' : 'v', 'long' : 'patterns',  'fold' : 0, 'stl' : 1}
                                \ ]
                                let types.beta = type_beta
                                " C {{{1
                                let type_c = tagbar#prototypes#typeinfo#new()
                                let type_c.ctagstype = 'c'
                                let type_c.kinds     = [
                                    \ {'short' : 'd', 'long' : 'macros',      'fold' : 1, 'stl' : 0},
                                    \ {'short' : 'p', 'long' : 'prototypes',  'fold' : 1, 'stl' : 0},
                                    \ {'short' : 'g', 'long' : 'enums',       'fold' : 0, 'stl' : 1},
                                    \ {'short' : 'e', 'long' : 'enumerators', 'fold' : 0, 'stl' : 0},
                                    \ {'short' : 't', 'long' : 'typedefs',    'fold' : 0, 'stl' : 0},
                                    \ {'short' : 's', 'long' : 'structs',     'fold' : 0, 'stl' : 1},
                                    \ {'short' : 'u', 'long' : 'unions',      'fold' : 0, 'stl' : 1},
                                    \ {'short' : 'm', 'long' : 'members',     'fold' : 0, 'stl' : 0},
                                    \ {'short' : 'v', 'long' : 'variables',   'fold' : 0, 'stl' : 0},
                                    \ {'short' : 'f', 'long' : 'functions',   'fold' : 0, 'stl' : 1}
                                \ ]
                                let type_c.sro        = '::'
                                let type_c.kind2scope = {
                                    \ 'g' : 'enum',
                                    \ 's' : 'struct',
                                    \ 'u' : 'union'
                                \ }
                                let type_c.scope2kind = {
                                    \ 'enum'   : 'g',
                                    \ 'struct' : 's',
                                    \ 'union'  : 'u'
                                \ }
                                let types.c = type_c
                                let types.lpc = type_c
                                " C++ {{{1
                                let type_cpp = tagbar#prototypes#typeinfo#new()
                                let type_cpp.ctagstype = 'c++'
                                let type_cpp.kinds     = [
                                    \ {'short' : 'd', 'long' : 'macros',      'fold' : 1, 'stl' : 0},
                                    \ {'short' : 'p', 'long' : 'prototypes',  'fold' : 1, 'stl' : 0},
                                    \ {'short' : 'g', 'long' : 'enums',       'fold' : 0, 'stl' : 1},
                                    \ {'short' : 'e', 'long' : 'enumerators', 'fold' : 0, 'stl' : 0},
                                    \ {'short' : 't', 'long' : 'typedefs',    'fold' : 0, 'stl' : 0},
                                    \ {'short' : 'n', 'long' : 'namespaces',  'fold' : 0, 'stl' : 1},
                                    \ {'short' : 'c', 'long' : 'classes',     'fold' : 0, 'stl' : 1},
                                    \ {'short' : 's', 'long' : 'structs',     'fold' : 0, 'stl' : 1},
                                    \ {'short' : 'u', 'long' : 'unions',      'fold' : 0, 'stl' : 1},
                                    \ {'short' : 'f', 'long' : 'functions',   'fold' : 0, 'stl' : 1},
                                    \ {'short' : 'm', 'long' : 'members',     'fold' : 0, 'stl' : 0},
                                    \ {'short' : 'v', 'long' : 'variables',   'fold' : 0, 'stl' : 0}
                                \ ]
                                let type_cpp.sro        = '::'
                                let type_cpp.kind2scope = {
                                    \ 'g' : 'enum',
                                    \ 'n' : 'namespace',
                                    \ 'c' : 'class',
                                    \ 's' : 'struct',
                                    \ 'u' : 'union'
                                \ }
                                let type_cpp.scope2kind = {
                                    \ 'enum'      : 'g',
                                    \ 'namespace' : 'n',
                                    \ 'class'     : 'c',
                                    \ 'struct'    : 's',
                                    \ 'union'     : 'u'
                                \ }
                                let types.cpp = type_cpp
                                let types.cuda = type_cpp
                                " C# {{{1
                                let type_cs = tagbar#prototypes#typeinfo#new()
                                let type_cs.ctagstype = 'c#'
                                let type_cs.kinds     = [
                                    \ {'short' : 'd', 'long' : 'macros',      'fold' : 1, 'stl' : 0},
                                    \ {'short' : 'f', 'long' : 'fields',      'fold' : 0, 'stl' : 1},
                                    \ {'short' : 'g', 'long' : 'enums',       'fold' : 0, 'stl' : 1},
                                    \ {'short' : 'e', 'long' : 'enumerators', 'fold' : 0, 'stl' : 0},
                                    \ {'short' : 't', 'long' : 'typedefs',    'fold' : 0, 'stl' : 1},
                                    \ {'short' : 'n', 'long' : 'namespaces',  'fold' : 0, 'stl' : 1},
                                    \ {'short' : 'i', 'long' : 'interfaces',  'fold' : 0, 'stl' : 1},
                                    \ {'short' : 'c', 'long' : 'classes',     'fold' : 0, 'stl' : 1},
                                    \ {'short' : 's', 'long' : 'structs',     'fold' : 0, 'stl' : 1},
                                    \ {'short' : 'E', 'long' : 'events',      'fold' : 0, 'stl' : 1},
                                    \ {'short' : 'm', 'long' : 'methods',     'fold' : 0, 'stl' : 1},
                                    \ {'short' : 'p', 'long' : 'properties',  'fold' : 0, 'stl' : 1}
                                \ ]
                                let type_cs.sro        = '.'
                                let type_cs.kind2scope = {
                                    \ 'n' : 'namespace',
                                    \ 'i' : 'interface',
                                    \ 'c' : 'class',
                                    \ 's' : 'struct',
                                    \ 'g' : 'enum'
                                \ }
                                let type_cs.scope2kind = {
                                    \ 'namespace' : 'n',
                                    \ 'interface' : 'i',
                                    \ 'class'     : 'c',
                                    \ 'struct'    : 's',
                                    \ 'enum'      : 'g'
                                \ }
                                let types.cs = type_cs
                                " COBOL {{{1
                                let type_cobol = tagbar#prototypes#typeinfo#new()
                                let type_cobol.ctagstype = 'cobol'
                                let type_cobol.kinds     = [
                                    \ {'short' : 'd', 'long' : 'data items',        'fold' : 0, 'stl' : 1},
                                    \ {'short' : 'f', 'long' : 'file descriptions', 'fold' : 0, 'stl' : 1},
                                    \ {'short' : 'g', 'long' : 'group items',       'fold' : 0, 'stl' : 1},
                                    \ {'short' : 'p', 'long' : 'paragraphs',        'fold' : 0, 'stl' : 1},
                                    \ {'short' : 'P', 'long' : 'program ids',       'fold' : 0, 'stl' : 1},
                                    \ {'short' : 's', 'long' : 'sections',          'fold' : 0, 'stl' : 1}
                                \ ]
                                let types.cobol = type_cobol
                                " Crystal {{{1
                                let type_crystal = tagbar#prototypes#typeinfo#new()
                                let type_crystal.ctagstype = 'crystal'
                                let type_crystal.kinds     = [
                                    \ {'short' : 'm', 'long' : 'modules',           'fold' : 0, 'stl' : 1},
                                    \ {'short' : 'c', 'long' : 'classes',           'fold' : 0, 'stl' : 1},
                                    \ {'short' : 'd', 'long' : 'defs',              'fold' : 0, 'stl' : 1},
                                    \ {'short' : 'f', 'long' : 'functions',         'fold' : 0, 'stl' : 1},
                                    \ {'short' : 'M', 'long' : 'macros',            'fold' : 0, 'stl' : 1},
                                    \ {'short' : 'l', 'long' : 'libs',              'fold' : 0, 'stl' : 1},
                                    \ {'short' : 's', 'long' : 'structs',           'fold' : 0, 'stl' : 1},
                                    \ {'short' : 'a', 'long' : 'aliases',           'fold' : 0, 'stl' : 1}
                                \ ]
                                let type_crystal.sro        = '::'
                                let types.crystal = type_crystal
                                " DOS Batch {{{1
                                let type_dosbatch = tagbar#prototypes#typeinfo#new()
                                let type_dosbatch.ctagstype = 'dosbatch'
                                let type_dosbatch.kinds     = [
                                    \ {'short' : 'l', 'long' : 'labels',    'fold' : 0, 'stl' : 1},
                                    \ {'short' : 'v', 'long' : 'variables', 'fold' : 0, 'stl' : 1}
                                \ ]
                                let types.dosbatch = type_dosbatch
                                " Eiffel {{{1
                                let type_eiffel = tagbar#prototypes#typeinfo#new()
                                let type_eiffel.ctagstype = 'eiffel'
                                let type_eiffel.kinds     = [
                                    \ {'short' : 'c', 'long' : 'classes',  'fold' : 0, 'stl' : 1},
                                    \ {'short' : 'f', 'long' : 'features', 'fold' : 0, 'stl' : 1}
                                \ ]
                                let type_eiffel.sro        = '.' " Not sure, is nesting even possible?
                                let type_eiffel.kind2scope = {
                                    \ 'c' : 'class',
                                    \ 'f' : 'feature'
                                \ }
                                let type_eiffel.scope2kind = {
                                    \ 'class'   : 'c',
                                    \ 'feature' : 'f'
                                \ }
                                let types.eiffel = type_eiffel
                                " Erlang {{{1
                                let type_erlang = tagbar#prototypes#typeinfo#new()
                                let type_erlang.ctagstype = 'erlang'
                                let type_erlang.kinds     = [
                                    \ {'short' : 'm', 'long' : 'modules',            'fold' : 0, 'stl' : 1},
                                    \ {'short' : 'd', 'long' : 'macro definitions',  'fold' : 0, 'stl' : 1},
                                    \ {'short' : 'f', 'long' : 'functions',          'fold' : 0, 'stl' : 1},
                                    \ {'short' : 'r', 'long' : 'record definitions', 'fold' : 0, 'stl' : 1}
                                \ ]
                                let type_erlang.sro        = '.' " Not sure, is nesting even possible?
                                let type_erlang.kind2scope = {
                                    \ 'm' : 'module'
                                \ }
                                let type_erlang.scope2kind = {
                                    \ 'module' : 'm'
                                \ }
                                let types.erlang = type_erlang
                                " Flex {{{1
                                " Vim doesn't support Flex out of the box, this is based on rough
                                " guesses and probably requires
                                " http://www.vim.org/scripts/script.php?script_id=2909
                                " Improvements welcome!
                                let type_as = tagbar#prototypes#typeinfo#new()
                                let type_as.ctagstype = 'flex'
                                let type_as.kinds     = [
                                    \ {'short' : 'v', 'long' : 'global variables', 'fold' : 0, 'stl' : 0},
                                    \ {'short' : 'c', 'long' : 'classes',          'fold' : 0, 'stl' : 1},
                                    \ {'short' : 'm', 'long' : 'methods',          'fold' : 0, 'stl' : 1},
                                    \ {'short' : 'p', 'long' : 'properties',       'fold' : 0, 'stl' : 1},
                                    \ {'short' : 'f', 'long' : 'functions',        'fold' : 0, 'stl' : 1},
                                    \ {'short' : 'x', 'long' : 'mxtags',           'fold' : 0, 'stl' : 0}
                                \ ]
                                let type_as.sro        = '.'
                                let type_as.kind2scope = {
                                    \ 'c' : 'class'
                                \ }
                                let type_as.scope2kind = {
                                    \ 'class' : 'c'
                                \ }
                                let types.mxml = type_as
                                let types.actionscript = type_as
                                " Fortran {{{1
                                let type_fortran = tagbar#prototypes#typeinfo#new()
                                let type_fortran.ctagstype = 'fortran'
                                let type_fortran.kinds     = [
                                    \ {'short' : 'm', 'long' : 'modules',    'fold' : 0, 'stl' : 1},
                                    \ {'short' : 'p', 'long' : 'programs',   'fold' : 0, 'stl' : 1},
                                    \ {'short' : 'k', 'long' : 'components', 'fold' : 0, 'stl' : 1},
                                    \ {'short' : 't', 'long' : 'derived types and structures', 'fold' : 0,
                                     \ 'stl' : 1},
                                    \ {'short' : 'c', 'long' : 'common blocks', 'fold' : 0, 'stl' : 1},
                                    \ {'short' : 'b', 'long' : 'block data',    'fold' : 0, 'stl' : 0},
                                    \ {'short' : 'e', 'long' : 'entry points',  'fold' : 0, 'stl' : 1},
                                    \ {'short' : 'f', 'long' : 'functions',     'fold' : 0, 'stl' : 1},
                                    \ {'short' : 's', 'long' : 'subroutines',   'fold' : 0, 'stl' : 1},
                                    \ {'short' : 'l', 'long' : 'labels',        'fold' : 0, 'stl' : 1},
                                    \ {'short' : 'n', 'long' : 'namelists',     'fold' : 0, 'stl' : 1},
                                    \ {'short' : 'v', 'long' : 'variables',     'fold' : 0, 'stl' : 0}
                                \ ]
                                let type_fortran.sro        = '.' " Not sure, is nesting even possible?
                                let type_fortran.kind2scope = {
                                    \ 'm' : 'module',
                                    \ 'p' : 'program',
                                    \ 'f' : 'function',
                                    \ 's' : 'subroutine'
                                \ }
                                let type_fortran.scope2kind = {
                                    \ 'module'     : 'm',
                                    \ 'program'    : 'p',
                                    \ 'function'   : 'f',
                                    \ 'subroutine' : 's'
                                \ }
                                let types.fortran = type_fortran
                                " Go {{{1
                                let type_go = tagbar#prototypes#typeinfo#new()
                                let type_go.ctagstype = 'go'
                                let type_go.kinds = [
                                    \ {'short' : 'p', 'long' : 'packages',       'fold' : 0, 'stl' : 0},
                                    \ {'short' : 'i', 'long' : 'interfaces',     'fold' : 0, 'stl' : 0},
                                    \ {'short' : 'c', 'long' : 'constants',      'fold' : 0, 'stl' : 0},
                                    \ {'short' : 's', 'long' : 'structs',        'fold' : 0, 'stl' : 1},
                                    \ {'short' : 'm', 'long' : 'struct members', 'fold' : 0, 'stl' : 0},
                                    \ {'short' : 't', 'long' : 'types',          'fold' : 0, 'stl' : 1},
                                    \ {'short' : 'f', 'long' : 'functions',      'fold' : 0, 'stl' : 1},
                                    \ {'short' : 'v', 'long' : 'variables',      'fold' : 0, 'stl' : 0}
                                \ ]
                                let type_go.sro = '.'
                                let type_go.kind2scope = {
                                    \ 's' : 'struct'
                                \ }
                                let type_go.scope2kind = {
                                    \ 'struct' : 's'
                                \ }
                                let types.go = type_go
                                " HTML {{{1
                                let type_html = tagbar#prototypes#typeinfo#new()
                                let type_html.ctagstype = 'html'
                                let type_html.kinds = [
                                    \ {'short' : 'f', 'long' : 'JavaScript functions', 'fold' : 0, 'stl' : 1},
                                    \ {'short' : 'a', 'long' : 'named anchors',        'fold' : 0, 'stl' : 1}
                                \ ]
                                let types.html = type_html
                                " Java {{{1
                                let type_java = tagbar#prototypes#typeinfo#new()
                                let type_java.ctagstype = 'java'
                                let type_java.kinds     = [
                                    \ {'short' : 'p', 'long' : 'packages',       'fold' : 1, 'stl' : 0},
                                    \ {'short' : 'f', 'long' : 'fields',         'fold' : 0, 'stl' : 0},
                                    \ {'short' : 'g', 'long' : 'enum types',     'fold' : 0, 'stl' : 1},
                                    \ {'short' : 'e', 'long' : 'enum constants', 'fold' : 0, 'stl' : 0},
                                    \ {'short' : 'i', 'long' : 'interfaces',     'fold' : 0, 'stl' : 1},
                                    \ {'short' : 'c', 'long' : 'classes',        'fold' : 0, 'stl' : 1},
                                    \ {'short' : 'm', 'long' : 'methods',        'fold' : 0, 'stl' : 1}
                                \ ]
                                let type_java.sro        = '.'
                                let type_java.kind2scope = {
                                    \ 'g' : 'enum',
                                    \ 'i' : 'interface',
                                    \ 'c' : 'class'
                                \ }
                                let type_java.scope2kind = {
                                    \ 'enum'      : 'g',
                                    \ 'interface' : 'i',
                                    \ 'class'     : 'c'
                                \ }
                                let types.java = type_java
                                " JavaScript {{{1
                                let type_javascript = tagbar#prototypes#typeinfo#new()
                                let type_javascript.ctagstype = 'javascript'
                                let type_javascript.kinds = [
                                    \ {'short': 'v', 'long': 'global variables', 'fold': 0, 'stl': 0},
                                    \ {'short': 'c', 'long': 'classes',          'fold': 0, 'stl': 1},
                                    \ {'short': 'p', 'long': 'properties',       'fold': 0, 'stl': 0},
                                    \ {'short': 'm', 'long': 'methods',          'fold': 0, 'stl': 1},
                                    \ {'short': 'f', 'long': 'functions',        'fold': 0, 'stl': 1},
                                \ ]
                                let type_javascript.sro        = '.'
                                let type_javascript.kind2scope = {
                                    \ 'c' : 'class',
                                    \ 'f' : 'function',
                                    \ 'm' : 'method',
                                    \ 'p' : 'property',
                                \ }
                                let type_javascript.scope2kind = {
                                    \ 'class'    : 'c',
                                    \ 'function' : 'f',
                                \ }
                                let types.javascript = type_javascript
                                " Lisp {{{1
                                let type_lisp = tagbar#prototypes#typeinfo#new()
                                let type_lisp.ctagstype = 'lisp'
                                let type_lisp.kinds     = [
                                    \ {'short' : 'f', 'long' : 'functions', 'fold' : 0, 'stl' : 1}
                                \ ]
                                let types.lisp = type_lisp
                                let types.clojure = type_lisp
                                " Lua {{{1
                                let type_lua = tagbar#prototypes#typeinfo#new()
                                let type_lua.ctagstype = 'lua'
                                let type_lua.kinds     = [
                                    \ {'short' : 'f', 'long' : 'functions', 'fold' : 0, 'stl' : 1}
                                \ ]
                                let types.lua = type_lua
                                " Make {{{1
                                let type_make = tagbar#prototypes#typeinfo#new()
                                let type_make.ctagstype = 'make'
                                let type_make.kinds     = [
                                    \ {'short' : 'm', 'long' : 'macros', 'fold' : 0, 'stl' : 1}
                                \ ]
                                let types.make = type_make
                                " Matlab {{{1
                                let type_matlab = tagbar#prototypes#typeinfo#new()
                                let type_matlab.ctagstype = 'matlab'
                                let type_matlab.kinds     = [
                                    \ {'short' : 'f', 'long' : 'functions', 'fold' : 0, 'stl' : 1}
                                \ ]
                                let types.matlab = type_matlab
                                " ObjectiveC {{{1
                                let type_objc = tagbar#prototypes#typeinfo#new()
                                let type_objc.ctagstype = 'objectivec'
                                let type_objc.kinds = [
                                    \ {'short' : 'M', 'long' : 'preprocessor macros',   'fold' : 1, 'stl' : 0},
                                    \ {'short' : 'v', 'long' : 'global variables',      'fold' : 0, 'stl' : 0},
                                    \ {'short' : 'i', 'long' : 'class interfaces',      'fold' : 0, 'stl' : 1},
                                    \ {'short' : 'I', 'long' : 'class implementations', 'fold' : 0, 'stl' : 1},
                                    \ {'short' : 'c', 'long' : 'class methods',         'fold' : 0, 'stl' : 1},
                                    \ {'short' : 'F', 'long' : 'object fields',         'fold' : 0, 'stl' : 0},
                                    \ {'short' : 'm', 'long' : 'object methods',        'fold' : 0, 'stl' : 1},
                                    \ {'short' : 's', 'long' : 'type structures',       'fold' : 0, 'stl' : 1},
                                    \ {'short' : 't', 'long' : 'type aliases',          'fold' : 0, 'stl' : 1},
                                    \ {'short' : 'e', 'long' : 'enumerations',          'fold' : 0, 'stl' : 1},
                                    \ {'short' : 'f', 'long' : 'functions',             'fold' : 0, 'stl' : 1},
                                    \ {'short' : 'p', 'long' : 'properties',            'fold' : 0, 'stl' : 0},
                                \ ]
                                let type_objc.sro        = ':'
                                let type_objc.kind2scope = {
                                    \ 'i' : 'interface',
                                    \ 'I' : 'implementation',
                                    \ 's' : 'struct',
                                \ }
                                let type_objc.scope2kind = {
                                    \ 'interface' : 'i',
                                    \ 'implementation' : 'I',
                                    \ 'struct' : 's',
                                \ }
                                let types.objc = type_objc
                                let types.objcpp = type_objc
                                " Ocaml {{{1
                                let type_ocaml = tagbar#prototypes#typeinfo#new()
                                let type_ocaml.ctagstype = 'ocaml'
                                let type_ocaml.kinds     = [
                                    \ {'short' : 'M', 'long' : 'modules or functors', 'fold' : 0, 'stl' : 1},
                                    \ {'short' : 'v', 'long' : 'global variables',    'fold' : 0, 'stl' : 0},
                                    \ {'short' : 'c', 'long' : 'classes',             'fold' : 0, 'stl' : 1},
                                    \ {'short' : 'C', 'long' : 'constructors',        'fold' : 0, 'stl' : 1},
                                    \ {'short' : 'm', 'long' : 'methods',             'fold' : 0, 'stl' : 1},
                                    \ {'short' : 'e', 'long' : 'exceptions',          'fold' : 0, 'stl' : 1},
                                    \ {'short' : 't', 'long' : 'type names',          'fold' : 0, 'stl' : 1},
                                    \ {'short' : 'f', 'long' : 'functions',           'fold' : 0, 'stl' : 1},
                                    \ {'short' : 'r', 'long' : 'structure fields',    'fold' : 0, 'stl' : 0}
                                \ ]
                                let type_ocaml.sro        = '.' " Not sure, is nesting even possible?
                                let type_ocaml.kind2scope = {
                                    \ 'M' : 'Module',
                                    \ 'c' : 'class',
                                    \ 't' : 'type'
                                \ }
                                let type_ocaml.scope2kind = {
                                    \ 'Module' : 'M',
                                    \ 'class'  : 'c',
                                    \ 'type'   : 't'
                                \ }
                                let types.ocaml = type_ocaml
                                " Pascal {{{1
                                let type_pascal = tagbar#prototypes#typeinfo#new()
                                let type_pascal.ctagstype = 'pascal'
                                let type_pascal.kinds     = [
                                    \ {'short' : 'f', 'long' : 'functions',  'fold' : 0, 'stl' : 1},
                                    \ {'short' : 'p', 'long' : 'procedures', 'fold' : 0, 'stl' : 1}
                                \ ]
                                let types.pascal = type_pascal
                                " Perl {{{1
                                let type_perl = tagbar#prototypes#typeinfo#new()
                                let type_perl.ctagstype = 'perl'
                                let type_perl.kinds     = [
                                    \ {'short' : 'p', 'long' : 'packages',    'fold' : 1, 'stl' : 0},
                                    \ {'short' : 'c', 'long' : 'constants',   'fold' : 0, 'stl' : 0},
                                    \ {'short' : 'f', 'long' : 'formats',     'fold' : 0, 'stl' : 0},
                                    \ {'short' : 'l', 'long' : 'labels',      'fold' : 0, 'stl' : 1},
                                    \ {'short' : 's', 'long' : 'subroutines', 'fold' : 0, 'stl' : 1}
                                \ ]
                                let types.perl = type_perl
                                " PHP {{{1
                                let type_php = tagbar#prototypes#typeinfo#new()
                                let type_php.ctagstype = 'php'
                                let type_php.kinds     = [
                                    \ {'short' : 'i', 'long' : 'interfaces',           'fold' : 0, 'stl' : 1},
                                    \ {'short' : 'c', 'long' : 'classes',              'fold' : 0, 'stl' : 1},
                                    \ {'short' : 'd', 'long' : 'constant definitions', 'fold' : 0, 'stl' : 0},
                                    \ {'short' : 'f', 'long' : 'functions',            'fold' : 0, 'stl' : 1},
                                    \ {'short' : 'v', 'long' : 'variables',            'fold' : 0, 'stl' : 0},
                                    \ {'short' : 'j', 'long' : 'javascript functions', 'fold' : 0, 'stl' : 1}
                                \ ]
                                let types.php = type_php
                                " Python {{{1
                                let type_python = tagbar#prototypes#typeinfo#new()
                                let type_python.ctagstype = 'python'
                                let type_python.kinds     = [
                                    \ {'short' : 'i', 'long' : 'imports',   'fold' : 1, 'stl' : 0},
                                    \ {'short' : 'c', 'long' : 'classes',   'fold' : 0, 'stl' : 1},
                                    \ {'short' : 'f', 'long' : 'functions', 'fold' : 0, 'stl' : 1},
                                    \ {'short' : 'm', 'long' : 'members',   'fold' : 0, 'stl' : 1},
                                    \ {'short' : 'v', 'long' : 'variables', 'fold' : 0, 'stl' : 0}
                                \ ]
                                let type_python.sro        = '.'
                                let type_python.kind2scope = {
                                    \ 'c' : 'class',
                                    \ 'f' : 'function',
                                    \ 'm' : 'function'
                                \ }
                                let type_python.scope2kind = {
                                    \ 'class'    : 'c',
                                    \ 'function' : 'f'
                                \ }
                                let types.python = type_python
                                let types.pyrex  = type_python
                                let types.cython = type_python
                                " REXX {{{1
                                let type_rexx = tagbar#prototypes#typeinfo#new()
                                let type_rexx.ctagstype = 'rexx'
                                let type_rexx.kinds     = [
                                    \ {'short' : 's', 'long' : 'subroutines', 'fold' : 0, 'stl' : 1}
                                \ ]
                                let types.rexx = type_rexx
                                " Ruby {{{1
                                let type_ruby = tagbar#prototypes#typeinfo#new()
                                let type_ruby.ctagstype = 'ruby'
                                let type_ruby.kinds     = [
                                    \ {'short' : 'm', 'long' : 'modules',           'fold' : 0, 'stl' : 1},
                                    \ {'short' : 'c', 'long' : 'classes',           'fold' : 0, 'stl' : 1},
                                    \ {'short' : 'f', 'long' : 'methods',           'fold' : 0, 'stl' : 1},
                                    \ {'short' : 'F', 'long' : 'singleton methods', 'fold' : 0, 'stl' : 1}
                                \ ]
                                let type_ruby.sro        = '.'
                                let type_ruby.kind2scope = {
                                    \ 'c' : 'class',
                                    \ 'm' : 'class',
                                    \ 'f' : 'class'
                                \ }
                                let type_ruby.scope2kind = {
                                    \ 'class' : 'c'
                                \ }
                                let types.ruby = type_ruby
                                " Scheme {{{1
                                let type_scheme = tagbar#prototypes#typeinfo#new()
                                let type_scheme.ctagstype = 'scheme'
                                let type_scheme.kinds     = [
                                    \ {'short' : 'f', 'long' : 'functions', 'fold' : 0, 'stl' : 1},
                                    \ {'short' : 's', 'long' : 'sets',      'fold' : 0, 'stl' : 1}
                                \ ]
                                let types.scheme = type_scheme
                                let types.racket = type_scheme
                                " Shell script {{{1
                                let type_sh = tagbar#prototypes#typeinfo#new()
                                let type_sh.ctagstype = 'sh'
                                let type_sh.kinds     = [
                                    \ {'short' : 'f', 'long' : 'functions', 'fold' : 0, 'stl' : 1}
                                \ ]
                                let types.sh = type_sh
                                let types.csh = type_sh
                                let types.zsh = type_sh
                                " SLang {{{1
                                let type_slang = tagbar#prototypes#typeinfo#new()
                                let type_slang.ctagstype = 'slang'
                                let type_slang.kinds     = [
                                    \ {'short' : 'n', 'long' : 'namespaces', 'fold' : 0, 'stl' : 1},
                                    \ {'short' : 'f', 'long' : 'functions',  'fold' : 0, 'stl' : 1}
                                \ ]
                                let types.slang = type_slang
                                " SML {{{1
                                let type_sml = tagbar#prototypes#typeinfo#new()
                                let type_sml.ctagstype = 'sml'
                                let type_sml.kinds     = [
                                    \ {'short' : 'e', 'long' : 'exception declarations', 'fold' : 0, 'stl' : 0},
                                    \ {'short' : 'f', 'long' : 'function definitions',   'fold' : 0, 'stl' : 1},
                                    \ {'short' : 'c', 'long' : 'functor definitions',    'fold' : 0, 'stl' : 1},
                                    \ {'short' : 's', 'long' : 'signature declarations', 'fold' : 0, 'stl' : 0},
                                    \ {'short' : 'r', 'long' : 'structure declarations', 'fold' : 0, 'stl' : 0},
                                    \ {'short' : 't', 'long' : 'type definitions',       'fold' : 0, 'stl' : 1},
                                    \ {'short' : 'v', 'long' : 'value bindings',         'fold' : 0, 'stl' : 0}
                                \ ]
                                let types.sml = type_sml
                                " SQL {{{1
                                " The SQL ctags parser seems to be buggy for me, so this just uses the
                                " normal kinds even though scopes should be available. Improvements
                                " welcome!
                                let type_sql = tagbar#prototypes#typeinfo#new()
                                let type_sql.ctagstype = 'sql'
                                let type_sql.kinds     = [
                                    \ {'short' : 'P', 'long' : 'packages',               'fold' : 1, 'stl' : 1},
                                    \ {'short' : 'd', 'long' : 'prototypes',             'fold' : 0, 'stl' : 1},
                                    \ {'short' : 'c', 'long' : 'cursors',                'fold' : 0, 'stl' : 1},
                                    \ {'short' : 'f', 'long' : 'functions',              'fold' : 0, 'stl' : 1},
                                    \ {'short' : 'F', 'long' : 'record fields',          'fold' : 0, 'stl' : 1},
                                    \ {'short' : 'L', 'long' : 'block label',            'fold' : 0, 'stl' : 1},
                                    \ {'short' : 'p', 'long' : 'procedures',             'fold' : 0, 'stl' : 1},
                                    \ {'short' : 's', 'long' : 'subtypes',               'fold' : 0, 'stl' : 1},
                                    \ {'short' : 't', 'long' : 'tables',                 'fold' : 0, 'stl' : 1},
                                    \ {'short' : 'T', 'long' : 'triggers',               'fold' : 0, 'stl' : 1},
                                    \ {'short' : 'v', 'long' : 'variables',              'fold' : 0, 'stl' : 1},
                                    \ {'short' : 'i', 'long' : 'indexes',                'fold' : 0, 'stl' : 1},
                                    \ {'short' : 'e', 'long' : 'events',                 'fold' : 0, 'stl' : 1},
                                    \ {'short' : 'U', 'long' : 'publications',           'fold' : 0, 'stl' : 1},
                                    \ {'short' : 'R', 'long' : 'services',               'fold' : 0, 'stl' : 1},
                                    \ {'short' : 'D', 'long' : 'domains',                'fold' : 0, 'stl' : 1},
                                    \ {'short' : 'V', 'long' : 'views',                  'fold' : 0, 'stl' : 1},
                                    \ {'short' : 'n', 'long' : 'synonyms',               'fold' : 0, 'stl' : 1},
                                    \ {'short' : 'x', 'long' : 'MobiLink Table Scripts', 'fold' : 0, 'stl' : 1},
                                    \ {'short' : 'y', 'long' : 'MobiLink Conn Scripts',  'fold' : 0, 'stl' : 1},
                                    \ {'short' : 'z', 'long' : 'MobiLink Properties',    'fold' : 0, 'stl' : 1}
                                \ ]
                                let types.sql = type_sql
                                " Tcl {{{1
                                let type_tcl = tagbar#prototypes#typeinfo#new()
                                let type_tcl.ctagstype = 'tcl'
                                let type_tcl.kinds     = [
                                    \ {'short' : 'c', 'long' : 'classes',    'fold' : 0, 'stl' : 1},
                                    \ {'short' : 'm', 'long' : 'methods',    'fold' : 0, 'stl' : 1},
                                    \ {'short' : 'p', 'long' : 'procedures', 'fold' : 0, 'stl' : 1}
                                \ ]
                                let types.tcl = type_tcl
                                " LaTeX {{{1
                                let type_tex = tagbar#prototypes#typeinfo#new()
                                let type_tex.ctagstype = 'tex'
                                let type_tex.kinds     = [
                                    \ {'short' : 'i', 'long' : 'includes',       'fold' : 1, 'stl' : 0},
                                    \ {'short' : 'p', 'long' : 'parts',          'fold' : 0, 'stl' : 1},
                                    \ {'short' : 'c', 'long' : 'chapters',       'fold' : 0, 'stl' : 1},
                                    \ {'short' : 's', 'long' : 'sections',       'fold' : 0, 'stl' : 1},
                                    \ {'short' : 'u', 'long' : 'subsections',    'fold' : 0, 'stl' : 1},
                                    \ {'short' : 'b', 'long' : 'subsubsections', 'fold' : 0, 'stl' : 1},
                                    \ {'short' : 'P', 'long' : 'paragraphs',     'fold' : 0, 'stl' : 0},
                                    \ {'short' : 'G', 'long' : 'subparagraphs',  'fold' : 0, 'stl' : 0},
                                    \ {'short' : 'l', 'long' : 'labels',         'fold' : 0, 'stl' : 0}
                                \ ]
                                let type_tex.sro        = '""'
                                let type_tex.kind2scope = {
                                    \ 'p' : 'part',
                                    \ 'c' : 'chapter',
                                    \ 's' : 'section',
                                    \ 'u' : 'subsection',
                                    \ 'b' : 'subsubsection'
                                \ }
                                let type_tex.scope2kind = {
                                    \ 'part'          : 'p',
                                    \ 'chapter'       : 'c',
                                    \ 'section'       : 's',
                                    \ 'subsection'    : 'u',
                                    \ 'subsubsection' : 'b'
                                \ }
                                let type_tex.sort = 0
                                let types.tex = type_tex
                                " Vala {{{1
                                " Vala is supported by the ctags fork provided by Anjuta, so only add the
                                " type if the fork is used to prevent error messages otherwise
                                if has_key(a:supported_types, 'vala') || executable('anjuta-tags')
                                    let type_vala = tagbar#prototypes#typeinfo#new()
                                    let type_vala.ctagstype = 'vala'
                                    let type_vala.kinds     = [
                                        \ {'short' : 'e', 'long' : 'Enumerations',       'fold' : 0, 'stl' : 1},
                                        \ {'short' : 'v', 'long' : 'Enumeration values', 'fold' : 0, 'stl' : 0},
                                        \ {'short' : 's', 'long' : 'Structures',         'fold' : 0, 'stl' : 1},
                                        \ {'short' : 'i', 'long' : 'Interfaces',         'fold' : 0, 'stl' : 1},
                                        \ {'short' : 'd', 'long' : 'Delegates',          'fold' : 0, 'stl' : 1},
                                        \ {'short' : 'c', 'long' : 'Classes',            'fold' : 0, 'stl' : 1},
                                        \ {'short' : 'p', 'long' : 'Properties',         'fold' : 0, 'stl' : 0},
                                        \ {'short' : 'f', 'long' : 'Fields',             'fold' : 0, 'stl' : 0},
                                        \ {'short' : 'm', 'long' : 'Methods',            'fold' : 0, 'stl' : 1},
                                        \ {'short' : 'E', 'long' : 'Error domains',      'fold' : 0, 'stl' : 1},
                                        \ {'short' : 'r', 'long' : 'Error codes',        'fold' : 0, 'stl' : 1},
                                        \ {'short' : 'S', 'long' : 'Signals',            'fold' : 0, 'stl' : 1}
                                    \ ]
                                    let type_vala.sro = '.'
                                    " 'enum' doesn't seem to be used as a scope, but it can't hurt to have
                                    " it here
                                    let type_vala.kind2scope = {
                                        \ 's' : 'struct',
                                        \ 'i' : 'interface',
                                        \ 'c' : 'class',
                                        \ 'e' : 'enum'
                                    \ }
                                    let type_vala.scope2kind = {
                                        \ 'struct'    : 's',
                                        \ 'interface' : 'i',
                                        \ 'class'     : 'c',
                                        \ 'enum'      : 'e'
                                    \ }
                                    let types.vala = type_vala
                                endif
                                if !has_key(a:supported_types, 'vala') && executable('anjuta-tags')
                                    let types.vala.ctagsbin = 'anjuta-tags'
                                endif
                                " Vera {{{1
                                " Why are variables 'virtual'?
                                let type_vera = tagbar#prototypes#typeinfo#new()
                                let type_vera.ctagstype = 'vera'
                                let type_vera.kinds     = [
                                    \ {'short' : 'd', 'long' : 'macros',      'fold' : 1, 'stl' : 0},
                                    \ {'short' : 'g', 'long' : 'enums',       'fold' : 0, 'stl' : 1},
                                    \ {'short' : 'T', 'long' : 'typedefs',    'fold' : 0, 'stl' : 0},
                                    \ {'short' : 'c', 'long' : 'classes',     'fold' : 0, 'stl' : 1},
                                    \ {'short' : 'e', 'long' : 'enumerators', 'fold' : 0, 'stl' : 0},
                                    \ {'short' : 'm', 'long' : 'members',     'fold' : 0, 'stl' : 1},
                                    \ {'short' : 'f', 'long' : 'functions',   'fold' : 0, 'stl' : 1},
                                    \ {'short' : 't', 'long' : 'tasks',       'fold' : 0, 'stl' : 1},
                                    \ {'short' : 'v', 'long' : 'variables',   'fold' : 0, 'stl' : 0},
                                    \ {'short' : 'p', 'long' : 'programs',    'fold' : 0, 'stl' : 1}
                                \ ]
                                let type_vera.sro        = '.' " Nesting doesn't seem to be possible
                                let type_vera.kind2scope = {
                                    \ 'g' : 'enum',
                                    \ 'c' : 'class',
                                    \ 'v' : 'virtual'
                                \ }
                                let type_vera.scope2kind = {
                                    \ 'enum'      : 'g',
                                    \ 'class'     : 'c',
                                    \ 'virtual'   : 'v'
                                \ }
                                let types.vera = type_vera
                                " Verilog {{{1
                                let type_verilog = tagbar#prototypes#typeinfo#new()
                                let type_verilog.ctagstype = 'verilog'
                                let type_verilog.kinds     = [
                                    \ {'short' : 'c', 'long' : 'constants',           'fold' : 0, 'stl' : 0},
                                    \ {'short' : 'e', 'long' : 'events',              'fold' : 0, 'stl' : 1},
                                    \ {'short' : 'f', 'long' : 'functions',           'fold' : 0, 'stl' : 1},
                                    \ {'short' : 'm', 'long' : 'modules',             'fold' : 0, 'stl' : 1},
                                    \ {'short' : 'n', 'long' : 'net data types',      'fold' : 0, 'stl' : 1},
                                    \ {'short' : 'p', 'long' : 'ports',               'fold' : 0, 'stl' : 1},
                                    \ {'short' : 'r', 'long' : 'register data types', 'fold' : 0, 'stl' : 1},
                                    \ {'short' : 't', 'long' : 'tasks',               'fold' : 0, 'stl' : 1}
                                \ ]
                                let types.verilog = type_verilog
                                " VHDL {{{1
                                " The VHDL ctags parser unfortunately doesn't generate proper scopes
                                let type_vhdl = tagbar#prototypes#typeinfo#new()
                                let type_vhdl.ctagstype = 'vhdl'
                                let type_vhdl.kinds     = [
                                    \ {'short' : 'P', 'long' : 'packages',   'fold' : 1, 'stl' : 0},
                                    \ {'short' : 'c', 'long' : 'constants',  'fold' : 0, 'stl' : 0},
                                    \ {'short' : 't', 'long' : 'types',      'fold' : 0, 'stl' : 1},
                                    \ {'short' : 'T', 'long' : 'subtypes',   'fold' : 0, 'stl' : 1},
                                    \ {'short' : 'r', 'long' : 'records',    'fold' : 0, 'stl' : 1},
                                    \ {'short' : 'e', 'long' : 'entities',   'fold' : 0, 'stl' : 1},
                                    \ {'short' : 'f', 'long' : 'functions',  'fold' : 0, 'stl' : 1},
                                    \ {'short' : 'p', 'long' : 'procedures', 'fold' : 0, 'stl' : 1}
                                \ ]
                                let types.vhdl = type_vhdl
                                " Vim {{{1
                                let type_vim = tagbar#prototypes#typeinfo#new()
                                let type_vim.ctagstype = 'vim'
                                let type_vim.kinds     = [
                                    \ {'short' : 'n', 'long' : 'vimball filenames',  'fold' : 0, 'stl' : 1},
                                    \ {'short' : 'v', 'long' : 'variables',          'fold' : 1, 'stl' : 0},
                                    \ {'short' : 'f', 'long' : 'functions',          'fold' : 0, 'stl' : 1},
                                    \ {'short' : 'a', 'long' : 'autocommand groups', 'fold' : 1, 'stl' : 1},
                                    \ {'short' : 'c', 'long' : 'commands',           'fold' : 0, 'stl' : 0},
                                    \ {'short' : 'm', 'long' : 'maps',               'fold' : 1, 'stl' : 0}
                                \ ]
                                let types.vim = type_vim
                                " YACC {{{1
                                let type_yacc = tagbar#prototypes#typeinfo#new()
                                let type_yacc.ctagstype = 'yacc'
                                let type_yacc.kinds     = [
                                    \ {'short' : 'l', 'long' : 'labels', 'fold' : 0, 'stl' : 1}
                                \ ]
                                let types.yacc = type_yacc
                                " }}}1
                            
                                for [type, typeinfo] in items(types)
                                    let typeinfo.ftype = type
                                endfor
                            
                                for typeinfo in values(types)
                                    call typeinfo.createKinddict()
                                endfor
                            
                                return types
                            endfunction
                            
                            " vim: ts=8 sw=4 sts=4 et foldenable foldmethod=marker foldcolumn=1

SCRIPT  C:\Users\Lenovo\AppData\Local\nvim-data\plugged\tagbar\autoload\tagbar\prototypes\typeinfo.vim
Sourced 1 time
Total time:   0.000413
 Self time:   0.000413

count  total (s)   self (s)
    1              0.000039 function! tagbar#prototypes#typeinfo#new(...) abort
                                let newobj = {}
                            
                                let newobj.kinddict = {}
                            
                                if a:0 > 0
                                    call extend(newobj, a:1)
                                endif
                            
                                let newobj.getKind = function(s:add_snr('s:getKind'))
                                let newobj.createKinddict = function(s:add_snr('s:createKinddict'))
                            
                                return newobj
                            endfunction
                            
                            " s:getKind() {{{1
    1              0.000018 function! s:getKind(kind) abort dict
                                "let idx = self.kinddict[a:kind]
                                let idx = has_key(self.kinddict, a:kind) ? self.kinddict[a:kind] : -1
                                return self.kinds[idx]
                            endfunction
                            
                            " s:createKinddict() {{{1
                            " Create a dictionary of the kind order for fast access in sorting functions
    1              0.000008 function! s:createKinddict() abort dict
                                let i = 0
                                for kind in self.kinds
                                    let self.kinddict[kind.short] = i
                                    let i += 1
                                endfor
                                let self.kinddict['?'] = i
                            endfunction
                            
                            " s:add_snr() {{{1
    1              0.000008 function! s:add_snr(funcname) abort
                                if !exists('s:snr')
                                    let s:snr = matchstr(expand('<sfile>'), '<SNR>\d\+_\zeget_snr$')
                                endif
                                return s:snr . a:funcname
                            endfunction
                            
                            " Modeline {{{1
                            " vim: ts=8 sw=4 sts=4 et foldenable foldmethod=marker foldcolumn=1

SCRIPT  C:\Users\Lenovo\AppData\Local\nvim-data\plugged\tagbar\autoload\tagbar\prototypes\fileinfo.vim
Sourced 1 time
Total time:   0.000781
 Self time:   0.000781

count  total (s)   self (s)
    1              0.000046 function! tagbar#prototypes#fileinfo#new(fname, ftype, typeinfo) abort
                                let newobj = {}
                            
                                " The complete file path
                                let newobj.fpath = a:fname
                            
                                let newobj.bufnr = bufnr(a:fname)
                            
                                " File modification time
                                let newobj.mtime = getftime(a:fname)
                            
                                " Get file size
                                let newobj.fsize = getfsize(a:fname)
                            
                                " Get the number of lines in the file
                                let newobj.lnum = line('$')
                            
                                " The vim file type
                                let newobj.ftype = a:ftype
                            
                                " List of the tags that are present in the file, sorted according to the
                                " value of 'g:tagbar_sort'
                                let newobj._taglist = []
                                let newobj._tagdict = {}
                            
                                " Dictionary of the tags, indexed by line number in the file
                                let newobj.fline = {}
                            
                                " Dictionary of the tags, indexed by line number in the tagbar
                                let newobj.tline = {}
                            
                                " Dictionary of the folding state of 'kind's, indexed by short name
                                let newobj.kindfolds = {}
                                let newobj.typeinfo = a:typeinfo
                                " copy the default fold state from the type info
                                for kind in a:typeinfo.kinds
                                    let newobj.kindfolds[kind.short] =
                                                \ g:tagbar_foldlevel == 0 ? 1 : kind.fold
                                endfor
                            
                                " Dictionary of dictionaries of the folding state of individual tags,
                                " indexed by kind and full path
                                let newobj.tagfolds = {}
                                for kind in a:typeinfo.kinds
                                    let newobj.tagfolds[kind.short] = {}
                                endfor
                            
                                " The current foldlevel of the file
                                let newobj.foldlevel = g:tagbar_foldlevel
                            
                                let newobj.addTag = function(s:add_snr('s:addTag'))
                                let newobj.getTags = function(s:add_snr('s:getTags'))
                                let newobj.getTagsByName = function(s:add_snr('s:getTagsByName'))
                                let newobj.removeTag = function(s:add_snr('s:removeTag'))
                                let newobj.reset = function(s:add_snr('s:reset'))
                                let newobj.clearOldFolds = function(s:add_snr('s:clearOldFolds'))
                                let newobj.sortTags = function(s:add_snr('s:sortTags'))
                                let newobj.openKindFold = function(s:add_snr('s:openKindFold'))
                                let newobj.closeKindFold = function(s:add_snr('s:closeKindFold'))
                            
                                " This is used during file processing. If the limit is exceeded at that
                                " point, then mark this flag for displaying to the tagbar window
                                let newobj.fsize_exceeded = 0
                            
                                return newobj
                            endfunction
                            
                            " s:addTag() {{{1
    1              0.000017 function! s:addTag(tag) abort dict
                                call add(self._taglist, a:tag)
                            
                                if has_key(self._tagdict, a:tag.name)
                                    call add(self._tagdict[a:tag.name], a:tag)
                                else
                                    let self._tagdict[a:tag.name] = [a:tag]
                                endif
                            endfunction
                            
                            " s:getTags() {{{1
    1              0.000008 function! s:getTags() dict abort
                                return self._taglist
                            endfunction
                            
                            " s:getTagsByName() {{{1
    1              0.000009 function! s:getTagsByName(tagname) dict abort
                                return get(self._tagdict, a:tagname, [])
                            endfunction
                            
                            " s:removeTag() {{{1
    1              0.000008 function! s:removeTag(tag) dict abort
                                let idx = index(self._taglist, a:tag)
                                if idx >= 0
                                    call remove(self._taglist, idx)
                                endif
                            
                                let namelist = get(self._tagdict, a:tag.name, [])
                                let idx = index(namelist, a:tag)
                                if idx >= 0
                                    call remove(namelist, idx)
                                endif
                            endfunction
                            
                            " s:reset() {{{1
                            " Reset stuff that gets regenerated while processing a file and save the old
                            " tag folds
    1              0.000007 function! s:reset() abort dict
                                let self.mtime = getftime(self.fpath)
                                let self._taglist = []
                                let self._tagdict = {}
                                let self.fline = {}
                                let self.tline = {}
                            
                                let self._tagfolds_old = self.tagfolds
                                let self.tagfolds = {}
                            
                                for kind in self.typeinfo.kinds
                                    let self.tagfolds[kind.short] = {}
                                endfor
                            endfunction
                            
                            " s:clearOldFolds() {{{1
    1              0.000007 function! s:clearOldFolds() abort dict
                                if exists('self._tagfolds_old')
                                    unlet self._tagfolds_old
                                endif
                            endfunction
                            
                            " s:sortTags() {{{1
    1              0.000008 function! s:sortTags(compare_typeinfo) abort dict
                                if get(a:compare_typeinfo, 'sort', g:tagbar_sort)
                                    call tagbar#sorting#sort(self._taglist, 'kind', a:compare_typeinfo)
                                else
                                    call tagbar#sorting#sort(self._taglist, 'line', a:compare_typeinfo)
                                endif
                            endfunction
                            
                            " s:openKindFold() {{{1
    1              0.000009 function! s:openKindFold(kind) abort dict
                                let self.kindfolds[a:kind.short] = 0
                            endfunction
                            
                            " s:closeKindFold() {{{1
    1              0.000007 function! s:closeKindFold(kind) abort dict
                                let self.kindfolds[a:kind.short] = 1
                            endfunction
                            
                            " s:add_snr() {{{1
    1              0.000007 function! s:add_snr(funcname) abort
                                if !exists('s:snr')
                                    let s:snr = matchstr(expand('<sfile>'), '<SNR>\d\+_\zeget_snr$')
                                endif
                                return s:snr . a:funcname
                            endfunction
                            
                            " Modeline {{{1
                            " vim: ts=8 sw=4 sts=4 et foldenable foldmethod=marker foldcolumn=1

SCRIPT  C:\Users\Lenovo\AppData\Local\nvim-data\plugged\tagbar\autoload\tagbar\prototypes\normaltag.vim
Sourced 1 time
Total time:   0.001396
 Self time:   0.001396

count  total (s)   self (s)
    1              0.000063 function! s:maybe_map_scope(scopestr) abort
                                if !empty(g:tagbar_scopestrs)
                                    if has_key(g:tagbar_scopestrs, a:scopestr)
                                        return g:tagbar_scopestrs[a:scopestr]
                                    endif
                                endif
                                return a:scopestr
                            endfunction
                            
    1              0.000020 function! tagbar#prototypes#normaltag#new(name) abort
                                let newobj = tagbar#prototypes#basetag#new(a:name)
                            
                                let newobj.isNormalTag = function(s:add_snr('s:isNormalTag'))
                                let newobj.strfmt = function(s:add_snr('s:strfmt'))
                                let newobj.str = function(s:add_snr('s:str'))
                                let newobj.getPrototype = function(s:add_snr('s:getPrototype'))
                                let newobj.getDataType = function(s:add_snr('s:getDataType'))
                            
                                return newobj
                            endfunction
                            
                            " s:isNormalTag() {{{1
    1              0.000018 function! s:isNormalTag() abort dict
                                return 1
                            endfunction
                            
                            " s:strfmt() {{{1
    1              0.000011 function! s:strfmt() abort dict
                                let typeinfo = self.typeinfo
                            
                                let suffix = get(self.fields, 'signature', '')
                                if has_key(self.fields, 'type')
                                    let suffix .= ' : ' . self.fields.type
                                elseif has_key(get(typeinfo, 'kind2scope', {}), self.fields.kind)
                                    let scope = s:maybe_map_scope(typeinfo.kind2scope[self.fields.kind])
                                    if !g:tagbar_show_data_type
                                        let suffix .= ' : ' . scope
                                    endif
                                endif
                                let prefix = self._getPrefix()
                            
                                if g:tagbar_show_data_type && self.getDataType() !=# ''
                                    let suffix .= ' : ' . self.getDataType()
                                endif
                            
                                if g:tagbar_show_tag_linenumbers == 1
                                    let suffix .= ' [' . self.fields.line . ']'
                                elseif g:tagbar_show_tag_linenumbers == 2
                                    let prefix .= '[' . self.fields.line . '] '
                                endif
                            
                                return prefix . self.name . suffix
                            endfunction
                            
                            " s:str() {{{1
    1              0.000022 function! s:str(longsig, full) abort dict
                                if a:full && self.path !=# ''
                                    let str = self.path . self.typeinfo.sro . self.name
                                else
                                    let str = self.name
                                endif
                            
                                if has_key(self.fields, 'signature')
                                    if a:longsig
                                        let str .= self.fields.signature
                                    else
                                        let str .= '()'
                                    endif
                                endif
                            
                                return str
                            endfunction
                            
                            " s:getPrototype() {{{1
    1              0.000015 function! s:getPrototype(short) abort dict
                                if self.prototype !=# ''
                                    let prototype = self.prototype
                                else
                                    let bufnr = self.fileinfo.bufnr
                            
                                    if self.fields.line == 0 || !bufloaded(bufnr)
                                        " No linenumber available or buffer not loaded (probably due to
                                        " 'nohidden'), try the pattern instead
                                        return substitute(self.pattern, '^\\M\\^\\C\s*\(.*\)\\$$', '\1', '')
                                    endif
                            
                                    let line = getbufline(bufnr, self.fields.line)[0]
                                    " If prototype includes declaration, remove the '=' and anything after
                                    " FIXME: Need to remove this code. This breaks python prototypes that
                                    " can include a '=' in the function paramter list.
                                    "   ex: function(arg1, optional_arg2=False)
                                    " let line = substitute(line, '\s*=.*', '', '')
                                    let list = split(line, '\zs')
                            
                                    let start = index(list, '(')
                                    if start == -1
                                        return substitute(line, '^\s\+', '', '')
                                    endif
                            
                                    let opening = count(list, '(', 0, start)
                                    let closing = count(list, ')', 0, start)
                                    if closing >= opening
                                        return substitute(line, '^\s\+', '', '')
                                    endif
                            
                                    let balance = opening - closing
                            
                                    let prototype = line
                                    let curlinenr = self.fields.line + 1
                                    while balance > 0 && curlinenr < line('$')
                                        let curline = getbufline(bufnr, curlinenr)[0]
                                        let curlist = split(curline, '\zs')
                                        let balance += count(curlist, '(')
                                        let balance -= count(curlist, ')')
                                        let prototype .= "\n" . curline
                                        let curlinenr += 1
                                    endwhile
                            
                                    let self.prototype = prototype
                                endif
                            
                                if a:short
                                    " join all lines and remove superfluous spaces
                                    let prototype = substitute(prototype, '^\s\+', '', '')
                                    let prototype = substitute(prototype, '\_s\+', ' ', 'g')
                                    let prototype = substitute(prototype, '(\s\+', '(', 'g')
                                    let prototype = substitute(prototype, '\s\+)', ')', 'g')
                                    " Avoid hit-enter prompts
                                    let maxlen = &columns - 12
                                    if len(prototype) > maxlen
                                        let prototype = prototype[:maxlen - 1 - 3]
                                        let prototype .= '...'
                                    endif
                                endif
                            
                                return prototype
                            endfunction
                            
                            " s:getDataType() {{{1
    1              0.000014 function! s:getDataType() abort dict
                                if self.data_type !=# ''
                                    let data_type = self.data_type
                                else
                                    " This is a fallthrough attempt to derive the data_type from the line
                                    " in the event ctags doesn't return the typeref field
                                    let bufnr = self.fileinfo.bufnr
                            
                                    if self.fields.line == 0 || !bufloaded(bufnr)
                                        " No linenumber available or buffer not loaded (probably due to
                                        " 'nohidden'), try the pattern instead
                                        return substitute(self.pattern, '^\\M\\^\\C\s*\(.*\)\\$$', '\1', '')
                                    endif
                            
                                    let line = getbufline(bufnr, self.fields.line)[0]
                                    let data_type = substitute(line, '\s*' . escape(self.name, '~') . '.*', '', '')
                            
                                    " Strip off the path if we have one along with any spaces prior to the
                                    " path
                                    if self.path !=# ''
                                        let data_type = substitute(data_type, '\s*' . self.path . self.typeinfo.sro, '', '')
                                    endif
                            
                                    " Strip off leading spaces
                                    let data_type = substitute(data_type, '^\s\+', '', '')
                            
                                    let self.data_type = data_type
                                endif
                            
                                return data_type
                            endfunction
                            
                            " s:add_snr() {{{1
    1              0.000020 function! s:add_snr(funcname) abort
                                if !exists('s:snr')
                                    let s:snr = matchstr(expand('<sfile>'), '<SNR>\d\+_\zeget_snr$')
                                endif
                                return s:snr . a:funcname
                            endfunction
                            
                            " Modeline {{{1
                            " vim: ts=8 sw=4 sts=4 et foldenable foldmethod=marker foldcolumn=1

SCRIPT  C:\Users\Lenovo\AppData\Local\nvim-data\plugged\tagbar\autoload\tagbar\prototypes\basetag.vim
Sourced 1 time
Total time:   0.001451
 Self time:   0.001451

count  total (s)   self (s)
    1              0.000101 let s:visibility_symbols = {
                                \ 'public'    : '+',
                                \ 'protected' : '#',
                                \ 'private'   : '-'
                            \ }
    1              0.000045 if exists('g:tagbar_visibility_symbols') && !empty(g:tagbar_visibility_symbols)
                                let s:visibility_symbols = g:tagbar_visibility_symbols
    1              0.000020 endif
                            
    1              0.000022 function! tagbar#prototypes#basetag#new(name) abort
                                let newobj = {}
                            
                                let newobj.name          = a:name
                                let newobj.fields        = {}
                                let newobj.fields.line   = 0
                                let newobj.fields.column = 0
                                let newobj.fields.end    = 0
                                let newobj.prototype     = ''
                                let newobj.data_type     = ''
                                let newobj.path          = ''
                                let newobj.fullpath      = a:name
                                let newobj.depth         = 0
                                let newobj.parent        = {}
                                let newobj.tline         = -1
                                let newobj.fileinfo      = {}
                                let newobj.typeinfo      = {}
                                let newobj._childlist    = []
                                let newobj._childdict    = {}
                            
                                let newobj.isNormalTag = function(s:add_snr('s:isNormalTag'))
                                let newobj.isPseudoTag = function(s:add_snr('s:isPseudoTag'))
                                let newobj.isSplitTag = function(s:add_snr('s:isSplitTag'))
                                let newobj.isKindheader = function(s:add_snr('s:isKindheader'))
                                let newobj.getPrototype = function(s:add_snr('s:getPrototype'))
                                let newobj.getDataType = function(s:add_snr('s:getDataType'))
                                let newobj._getPrefix = function(s:add_snr('s:_getPrefix'))
                                let newobj.initFoldState = function(s:add_snr('s:initFoldState'))
                                let newobj.getClosedParentTline = function(s:add_snr('s:getClosedParentTline'))
                                let newobj.isFoldable = function(s:add_snr('s:isFoldable'))
                                let newobj.isFolded = function(s:add_snr('s:isFolded'))
                                let newobj.openFold = function(s:add_snr('s:openFold'))
                                let newobj.closeFold = function(s:add_snr('s:closeFold'))
                                let newobj.setFolded = function(s:add_snr('s:setFolded'))
                                let newobj.openParents = function(s:add_snr('s:openParents'))
                                let newobj.addChild = function(s:add_snr('s:addChild'))
                                let newobj.getChildren = function(s:add_snr('s:getChildren'))
                                let newobj.getChildrenByName = function(s:add_snr('s:getChildrenByName'))
                                let newobj.removeChild = function(s:add_snr('s:removeChild'))
                            
                                return newobj
                            endfunction
                            
                            " s:isNormalTag() {{{1
    1              0.000017 function! s:isNormalTag() abort dict
                                return 0
                            endfunction
                            
                            " s:isPseudoTag() {{{1
    1              0.000007 function! s:isPseudoTag() abort dict
                                return 0
                            endfunction
                            
                            " s:isSplitTag {{{1
    1              0.000006 function! s:isSplitTag() abort dict
                                return 0
                            endfunction
                            
                            " s:isKindheader() {{{1
    1              0.000020 function! s:isKindheader() abort dict
                                return 0
                            endfunction
                            
                            " s:getPrototype() {{{1
    1              0.000012 function! s:getPrototype(short) abort dict
                                return self.prototype
                            endfunction
                            
                            " s:getDataType() {{{1
    1              0.000006 function! s:getDataType() abort dict
                                return self.data_type
                            endfunction
                            
                            " s:_getPrefix() {{{1
    1              0.000006 function! s:_getPrefix() abort dict
                                let fileinfo = self.fileinfo
                            
                                if !empty(self._childlist)
                                    if fileinfo.tagfolds[self.fields.kind][self.fullpath]
                                        let prefix = g:tagbar#icon_closed
                                    else
                                        let prefix = g:tagbar#icon_open
                                    endif
                                else
                                    let prefix = ' '
                                endif
                                " Visibility is called 'access' in the ctags output
                                if g:tagbar_show_visibility
                                    if has_key(self.fields, 'access')
                                        let prefix .= get(s:visibility_symbols, self.fields.access, ' ')
                                    elseif has_key(self.fields, 'file')
                                        let prefix .= s:visibility_symbols.private
                                    else
                                        let prefix .= ' '
                                    endif
                                endif
                            
                                return prefix
                            endfunction
                            
                            " s:initFoldState() {{{1
    1              0.000014 function! s:initFoldState(known_files) abort dict
                                let fileinfo = self.fileinfo
                            
                                if a:known_files.has(fileinfo.fpath) &&
                                 \ has_key(fileinfo, '_tagfolds_old') &&
                                 \ has_key(fileinfo._tagfolds_old[self.fields.kind], self.fullpath)
                                    " The file has been updated and the tag was there before, so copy its
                                    " old fold state
                                    let fileinfo.tagfolds[self.fields.kind][self.fullpath] =
                                                \ fileinfo._tagfolds_old[self.fields.kind][self.fullpath]
                                elseif self.depth >= fileinfo.foldlevel
                                    let fileinfo.tagfolds[self.fields.kind][self.fullpath] = 1
                                else
                                    let fileinfo.tagfolds[self.fields.kind][self.fullpath] =
                                                \ fileinfo.kindfolds[self.fields.kind]
                                endif
                            endfunction
                            
                            " s:getClosedParentTline() {{{1
    1              0.000017 function! s:getClosedParentTline() abort dict
                                let tagline  = self.tline
                            
                                " Find the first closed parent, starting from the top of the hierarchy.
                                let parents   = []
                                let curparent = self.parent
                                while !empty(curparent)
                                    call add(parents, curparent)
                                    let curparent = curparent.parent
                                endwhile
                                for parent in reverse(parents)
                                    if parent.isFolded()
                                        let tagline = parent.tline
                                        break
                                    endif
                                endfor
                            
                                return tagline
                            endfunction
                            
                            " s:isFoldable() {{{1
    1              0.000009 function! s:isFoldable() abort dict
                                return !empty(self._childlist)
                            endfunction
                            
                            " s:isFolded() {{{1
    1              0.000007 function! s:isFolded() abort dict
                                return self.fileinfo.tagfolds[self.fields.kind][self.fullpath]
                            endfunction
                            
                            " s:openFold() {{{1
    1              0.000006 function! s:openFold() abort dict
                                if self.isFoldable()
                                    let self.fileinfo.tagfolds[self.fields.kind][self.fullpath] = 0
                                endif
                            endfunction
                            
                            " s:closeFold() {{{1
    1              0.000006 function! s:closeFold() abort dict
                                let newline = line('.')
                            
                                if !empty(self.parent) && self.parent.isKindheader()
                                    " Tag is child of generic 'kind'
                                    call self.parent.closeFold()
                                    let newline = self.parent.tline
                                elseif self.isFoldable() && !self.isFolded()
                                    " Tag is parent of a scope and is not folded
                                    let self.fileinfo.tagfolds[self.fields.kind][self.fullpath] = 1
                                    let newline = self.tline
                                elseif !empty(self.parent)
                                    " Tag is normal child, so close parent
                                    let parent = self.parent
                                    let self.fileinfo.tagfolds[parent.fields.kind][parent.fullpath] = 1
                                    let newline = parent.tline
                                endif
                            
                                return newline
                            endfunction
                            
                            " s:setFolded() {{{1
    1              0.000009 function! s:setFolded(folded) abort dict
                                let self.fileinfo.tagfolds[self.fields.kind][self.fullpath] = a:folded
                            endfunction
                            
                            " s:openParents() {{{1
    1              0.000006 function! s:openParents() abort dict
                                let parent = self.parent
                            
                                while !empty(parent)
                                    call parent.openFold()
                                    let parent = parent.parent
                                endwhile
                            endfunction
                            
                            " s:addChild() {{{1
    1              0.000007 function! s:addChild(tag) abort dict
                                call add(self._childlist, a:tag)
                            
                                if has_key(self._childdict, a:tag.name)
                                    call add(self._childdict[a:tag.name], a:tag)
                                else
                                    let self._childdict[a:tag.name] = [a:tag]
                                endif
                            endfunction
                            
                            " s:getChildren() {{{1
    1              0.000006 function! s:getChildren() dict abort
                                return self._childlist
                            endfunction
                            
                            " s:getChildrenByName() {{{1
    1              0.000009 function! s:getChildrenByName(tagname) dict abort
                                return get(self._childdict, a:tagname, [])
                            endfunction
                            
                            " s:removeChild() {{{1
    1              0.000007 function! s:removeChild(tag) dict abort
                                let idx = index(self._childlist, a:tag)
                                if idx >= 0
                                    call remove(self._childlist, idx)
                                endif
                            
                                let namelist = get(self._childdict, a:tag.name, [])
                                let idx = index(namelist, a:tag)
                                if idx >= 0
                                    call remove(namelist, idx)
                                endif
                            endfunction
                            
                            " s:add_snr() {{{1
    1              0.000007 function! s:add_snr(funcname) abort
                                if !exists('s:snr')
                                    let s:snr = matchstr(expand('<sfile>'), '<SNR>\d\+_\zeget_snr$')
                                endif
                                return s:snr . a:funcname
                            endfunction
                            
                            " Modeline {{{1
                            " vim: ts=8 sw=4 sts=4 et foldenable foldmethod=marker foldcolumn=1

SCRIPT  C:\Users\Lenovo\AppData\Local\nvim-data\plugged\tagbar\autoload\tagbar\prototypes\kindheadertag.vim
Sourced 1 time
Total time:   0.000521
 Self time:   0.000521

count  total (s)   self (s)
    1              0.000048 function! tagbar#prototypes#kindheadertag#new(name) abort
                                let newobj = tagbar#prototypes#basetag#new(a:name)
                            
                                let newobj.isKindheader = function(s:add_snr('s:isKindheader'))
                                let newobj.getPrototype = function(s:add_snr('s:getPrototype'))
                                let newobj.isFoldable = function(s:add_snr('s:isFoldable'))
                                let newobj.isFolded = function(s:add_snr('s:isFolded'))
                                let newobj.openFold = function(s:add_snr('s:openFold'))
                                let newobj.closeFold = function(s:add_snr('s:closeFold'))
                                let newobj.toggleFold = function(s:add_snr('s:toggleFold'))
                            
                                return newobj
                            endfunction
                            
                            " s:isKindheader() {{{1
    1              0.000017 function! s:isKindheader() abort dict
                                return 1
                            endfunction
                            
                            " s:getPrototype() {{{1
    1              0.000010 function! s:getPrototype(short) abort dict
                                return self.name . ': ' .
                                     \ self.numtags . ' ' . (self.numtags > 1 ? 'tags' : 'tag')
                            endfunction
                            
                            " s:isFoldable() {{{1
    1              0.000007 function! s:isFoldable() abort dict
                                return 1
                            endfunction
                            
                            " s:isFolded() {{{1
    1              0.000007 function! s:isFolded() abort dict
                                return self.fileinfo.kindfolds[self.short]
                            endfunction
                            
                            " s:openFold() {{{1
    1              0.000006 function! s:openFold() abort dict
                                let self.fileinfo.kindfolds[self.short] = 0
                            endfunction
                            
                            " s:closeFold() {{{1
    1              0.000007 function! s:closeFold() abort dict
                                let self.fileinfo.kindfolds[self.short] = 1
                                return line('.')
                            endfunction
                            
                            " s:toggleFold() {{{1
    1              0.000009 function! s:toggleFold(fileinfo) abort dict
                                let a:fileinfo.kindfolds[self.short] = !a:fileinfo.kindfolds[self.short]
                            endfunction
                            
                            " s:add_snr() {{{1
    1              0.000007 function! s:add_snr(funcname) abort
                                if !exists('s:snr')
                                    let s:snr = matchstr(expand('<sfile>'), '<SNR>\d\+_\zeget_snr$')
                                endif
                                return s:snr . a:funcname
                            endfunction
                            
                            " Modeline {{{1
                            " vim: ts=8 sw=4 sts=4 et foldenable foldmethod=marker foldcolumn=1

SCRIPT  C:\Users\Lenovo\AppData\Local\nvim-data\plugged\tagbar\autoload\tagbar\sorting.vim
Sourced 1 time
Total time:   0.000533
 Self time:   0.000533

count  total (s)   self (s)
                            " Script-local variable needed since compare functions can't
                            " take additional arguments
    1              0.000032 let s:compare_typeinfo = {}
                            
    1              0.000022 function! tagbar#sorting#sort(tags, compareby, compare_typeinfo) abort
                                let s:compare_typeinfo = a:compare_typeinfo
                            
                                let comparemethod =
                                        \ a:compareby ==# 'kind' ? 's:compare_by_kind' : 's:compare_by_line'
                            
                                call sort(a:tags, comparemethod)
                            
                                for tag in a:tags
                                    if !empty(tag.getChildren())
                                        call tagbar#sorting#sort(tag.getChildren(), a:compareby,
                                                               \ a:compare_typeinfo)
                                    endif
                                endfor
                            endfunction
                            
    1              0.000017 function! s:compare_by_kind(tag1, tag2) abort
                                let typeinfo = s:compare_typeinfo
                            
                                if !has_key(typeinfo.kinddict, a:tag1.fields.kind)
                                    return -1
                                endif
                                if !has_key(typeinfo.kinddict, a:tag2.fields.kind)
                                    return 1
                                endif
                                if typeinfo.kinddict[a:tag1.fields.kind] <#
                                 \ typeinfo.kinddict[a:tag2.fields.kind]
                                    return -1
                                elseif typeinfo.kinddict[a:tag1.fields.kind] >#
                                     \ typeinfo.kinddict[a:tag2.fields.kind]
                                    return 1
                                else
                                    " Ignore '~' prefix for C++ destructors to sort them directly under
                                    " the constructors
                                    if a:tag1.name[0] ==# '~'
                                        let name1 = a:tag1.name[1:]
                                    else
                                        let name1 = a:tag1.name
                                    endif
                                    if a:tag2.name[0] ==# '~'
                                        let name2 = a:tag2.name[1:]
                                    else
                                        let name2 = a:tag2.name
                                    endif
                            
                                    let ci = g:tagbar_case_insensitive
                                    if (((!ci) && (name1 <=# name2)) || (ci && (name1 <=? name2)))
                                        return -1
                                    else
                                        return 1
                                    endif
                                endif
                            endfunction
                            
    1              0.000012 function! s:compare_by_line(tag1, tag2) abort
                                return a:tag1.fields.line - a:tag2.fields.line
                            endfunction
                            
                            " vim: ts=8 sw=4 sts=4 et foldenable foldmethod=marker foldcolumn=1

SCRIPT  C:\Users\Lenovo\AppData\Local\nvim-data\plugged\tagbar\autoload\tagbar\state.vim
Sourced 1 time
Total time:   0.000498
 Self time:   0.000498

count  total (s)   self (s)
    1              0.000041 function! tagbar#state#get_current_file(force_current) abort
                                return s:get().getCurrent(a:force_current)
                            endfunction
                            
    1              0.000012 function! tagbar#state#set_current_file(fileinfo) abort
                                call s:get().setCurrentFile(a:fileinfo)
                            endfunction
                            
    1              0.000007 function! tagbar#state#set_paused() abort
                                call s:get().setPaused()
                            endfunction
                            
    1              0.000013 function! s:get() abort
                                if !exists('t:tagbar_state')
                                    let t:tagbar_state = s:State.New()
                                endif
                            
                                return t:tagbar_state
                            endfunction
                            
    1              0.000045 let s:State = {
                                \ '_current' : {},
                                \ '_paused'  : {},
                            \ }
                            
                            " s:state.New() {{{1
    1              0.000009 function! s:State.New() abort dict
                                return deepcopy(self)
                            endfunction
                            
                            " s:state.getCurrent() {{{1
    1              0.000009 function! s:State.getCurrent(force_current) abort dict
                                if !tagbar#is_paused() || a:force_current
                                    return self._current
                                else
                                    return self._paused
                                endif
                            endfunction
                            
                            " s:state.setCurrentFile() {{{1
    1              0.000008 function! s:State.setCurrentFile(fileinfo) abort dict
                                let self._current = a:fileinfo
                            endfunction
                            
                            " s:state.setPaused() {{{1
    1              0.000006 function! s:State.setPaused() abort dict
                                let self._paused = self._current
                            endfunction
                            
                            " Modeline {{{1
                            " vim: ts=8 sw=4 sts=4 et foldenable foldmethod=marker foldcolumn=1

SCRIPT  C:\Users\Lenovo\scoop\apps\neovim\0.6.1\share\nvim\runtime\autoload\dist\ft.vim
Sourced 1 time
Total time:   0.003275
 Self time:   0.003275

count  total (s)   self (s)
                            " Vim functions for file type detection
                            "
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last Change:	2020 Aug 17
                            
                            " These functions are moved here from runtime/filetype.vim to make startup
                            " faster.
                            
                            " Line continuation is used here, remove 'C' from 'cpoptions'
    1              0.000045 let s:cpo_save = &cpo
    1              0.000034 set cpo&vim
                            
    1              0.000013 func dist#ft#Check_inp()
                              if getline(1) =~ '^\*'
                                setf abaqus
                              else
                                let n = 1
                                if line("$") > 500
                                  let nmax = 500
                                else
                                  let nmax = line("$")
                                endif
                                while n <= nmax
                                  if getline(n) =~? "^header surface data"
                            	setf trasys
                            	break
                                  endif
                                  let n = n + 1
                                endwhile
                              endif
                            endfunc
                            
                            " This function checks for the kind of assembly that is wanted by the user, or
                            " can be detected from the first five lines of the file.
    1              0.000008 func dist#ft#FTasm()
                              " make sure b:asmsyntax exists
                              if !exists("b:asmsyntax")
                                let b:asmsyntax = ""
                              endif
                            
                              if b:asmsyntax == ""
                                call dist#ft#FTasmsyntax()
                              endif
                            
                              " if b:asmsyntax still isn't set, default to asmsyntax or GNU
                              if b:asmsyntax == ""
                                if exists("g:asmsyntax")
                                  let b:asmsyntax = g:asmsyntax
                                else
                                  let b:asmsyntax = "asm"
                                endif
                              endif
                            
                              exe "setf " . fnameescape(b:asmsyntax)
                            endfunc
                            
    1              0.000007 func dist#ft#FTasmsyntax()
                              " see if file contains any asmsyntax=foo overrides. If so, change
                              " b:asmsyntax appropriately
                              let head = " ".getline(1)." ".getline(2)." ".getline(3)." ".getline(4).
                            	\" ".getline(5)." "
                              let match = matchstr(head, '\sasmsyntax=\zs[a-zA-Z0-9]\+\ze\s')
                              if match != ''
                                let b:asmsyntax = match
                              elseif ((head =~? '\.title') || (head =~? '\.ident') || (head =~? '\.macro') || (head =~? '\.subtitle') || (head =~? '\.library'))
                                let b:asmsyntax = "vmasm"
                              endif
                            endfunc
                            
                            " Check if one of the first five lines contains "VB_Name".  In that case it is
                            " probably a Visual Basic file.  Otherwise it's assumed to be "alt" filetype.
    1              0.000009 func dist#ft#FTVB(alt)
                              if getline(1).getline(2).getline(3).getline(4).getline(5) =~? 'VB_Name\|Begin VB\.\(Form\|MDIForm\|UserControl\)'
                                setf vb
                              else
                                exe "setf " . a:alt
                              endif
                            endfunc
                            
    1              0.000006 func dist#ft#FTbtm()
                              if exists("g:dosbatch_syntax_for_btm") && g:dosbatch_syntax_for_btm
                                setf dosbatch
                              else
                                setf btm
                              endif
                            endfunc
                            
    1              0.000009 func dist#ft#BindzoneCheck(default)
                              if getline(1).getline(2).getline(3).getline(4) =~ '^; <<>> DiG [0-9.]\+.* <<>>\|$ORIGIN\|$TTL\|IN\s\+SOA'
                                setf bindzone
                              elseif a:default != ''
                                exe 'setf ' . a:default
                              endif
                            endfunc
                            
    1              0.000005 func dist#ft#FTlpc()
                              if exists("g:lpc_syntax_for_c")
                                let lnum = 1
                                while lnum <= 12
                                  if getline(lnum) =~# '^\(//\|inherit\|private\|protected\|nosave\|string\|object\|mapping\|mixed\)'
                            	setf lpc
                            	return
                                  endif
                                  let lnum = lnum + 1
                                endwhile
                              endif
                              setf c
                            endfunc
                            
    1              0.000006 func dist#ft#FTheader()
                              if match(getline(1, min([line("$"), 200])), '^@\(interface\|end\|class\)') > -1
                                if exists("g:c_syntax_for_h")
                                  setf objc
                                else
                                  setf objcpp
                                endif
                              elseif exists("g:c_syntax_for_h")
                                setf c
                              elseif exists("g:ch_syntax_for_h")
                                setf ch
                              else
                                setf cpp
                              endif
                            endfunc
                            
                            " This function checks if one of the first ten lines start with a '@'.  In
                            " that case it is probably a change file.
                            " If the first line starts with # or ! it's probably a ch file.
                            " If a line has "main", "include", "//" or "/*" it's probably ch.
                            " Otherwise CHILL is assumed.
    1              0.000005 func dist#ft#FTchange()
                              let lnum = 1
                              while lnum <= 10
                                if getline(lnum)[0] == '@'
                                  setf change
                                  return
                                endif
                                if lnum == 1 && (getline(1)[0] == '#' || getline(1)[0] == '!')
                                  setf ch
                                  return
                                endif
                                if getline(lnum) =~ "MODULE"
                                  setf chill
                                  return
                                endif
                                if getline(lnum) =~ 'main\s*(\|#\s*include\|//'
                                  setf ch
                                  return
                                endif
                                let lnum = lnum + 1
                              endwhile
                              setf chill
                            endfunc
                            
    1              0.000006 func dist#ft#FTent()
                              " This function checks for valid cl syntax in the first five lines.
                              " Look for either an opening comment, '#', or a block start, '{".
                              " If not found, assume SGML.
                              let lnum = 1
                              while lnum < 6
                                let line = getline(lnum)
                                if line =~ '^\s*[#{]'
                                  setf cl
                                  return
                                elseif line !~ '^\s*$'
                                  " Not a blank line, not a comment, and not a block start,
                                  " so doesn't look like valid cl code.
                                  break
                                endif
                                let lnum = lnum + 1
                              endw
                              setf dtd
                            endfunc
                            
    1              0.000007 func dist#ft#ExCheck()
                              let lines = getline(1, min([line("$"), 100]))
                              if exists('g:filetype_euphoria')
                                exe 'setf ' . g:filetype_euphoria
                              elseif match(lines, '^--\|^ifdef\>\|^include\>') > -1
                                setf euphoria3
                              else
                                setf elixir
                              endif
                            endfunc
                            
    1              0.000006 func dist#ft#EuphoriaCheck()
                              if exists('g:filetype_euphoria')
                                exe 'setf ' . g:filetype_euphoria
                              else
                                setf euphoria3
                              endif
                            endfunc
                            
    1              0.000006 func dist#ft#DtraceCheck()
                              let lines = getline(1, min([line("$"), 100]))
                              if match(lines, '^module\>\|^import\>') > -1
                                " D files often start with a module and/or import statement.
                                setf d
                              elseif match(lines, '^#!\S\+dtrace\|#pragma\s\+D\s\+option\|:\S\{-}:\S\{-}:') > -1
                                setf dtrace
                              else
                                setf d
                              endif
                            endfunc
                            
    1              0.000007 func dist#ft#FTe()
                              if exists('g:filetype_euphoria')
                                exe 'setf ' . g:filetype_euphoria
                              else
                                let n = 1
                                while n < 100 && n <= line("$")
                                  if getline(n) =~ "^\\s*\\(<'\\|'>\\)\\s*$"
                            	setf specman
                            	return
                                  endif
                                  let n = n + 1
                                endwhile
                                setf eiffel
                              endif
                            endfunc
                            
                            " Distinguish between Forth and F#.
                            " Provided by Doug Kearns.
    1              0.000006 func dist#ft#FTfs()
                              if exists("g:filetype_fs")
                                exe "setf " . g:filetype_fs
                              else
                                let line = getline(nextnonblank(1))
                                " comments and colon definitions
                                if line =~ '^\s*\.\=( ' || line =~ '^\s*\\G\= ' || line =~ '^\\$'
                            	  \ || line =~ '^\s*: \S'
                                  setf forth
                                else
                                  setf fsharp
                                endif
                              endif
                            endfunc
                            
                            " Distinguish between HTML, XHTML and Django
    1              0.000005 func dist#ft#FThtml()
                              let n = 1
                              while n < 10 && n <= line("$")
                                if getline(n) =~ '\<DTD\s\+XHTML\s'
                                  setf xhtml
                                  return
                                endif
                                if getline(n) =~ '{%\s*\(extends\|block\|load\)\>\|{#\s\+'
                                  setf htmldjango
                                  return
                                endif
                                let n = n + 1
                              endwhile
                              setf FALLBACK html
                            endfunc
                            
                            " Distinguish between standard IDL and MS-IDL
    1              0.000005 func dist#ft#FTidl()
                              let n = 1
                              while n < 50 && n <= line("$")
                                if getline(n) =~ '^\s*import\s\+"\(unknwn\|objidl\)\.idl"'
                                  setf msidl
                                  return
                                endif
                                let n = n + 1
                              endwhile
                              setf idl
                            endfunc
                            
                            " Distinguish between "default" and Cproto prototype file. */
    1              0.000009 func dist#ft#ProtoCheck(default)
                              " Cproto files have a comment in the first line and a function prototype in
                              " the second line, it always ends in ";".  Indent files may also have
                              " comments, thus we can't match comments to see the difference.
                              " IDL files can have a single ';' in the second line, require at least one
                              " chacter before the ';'.
                              if getline(2) =~ '.;$'
                                setf cpp
                              else
                                exe 'setf ' . a:default
                              endif
                            endfunc
                            
    1              0.000005 func dist#ft#FTm()
                              if exists("g:filetype_m")
                                exe "setf " . g:filetype_m
                                return
                              endif
                            
                              " excluding end(for|function|if|switch|while) common to Murphi
                              let octave_block_terminators = '\<end\%(_try_catch\|classdef\|enumeration\|events\|methods\|parfor\|properties\)\>'
                            
                              let objc_preprocessor = '^\s*#\s*\%(import\|include\|define\|if\|ifn\=def\|undef\|line\|error\|pragma\)\>'
                            
                              let n = 1
                              let saw_comment = 0 " Whether we've seen a multiline comment leader.
                              while n < 100
                                let line = getline(n)
                                if line =~ '^\s*/\*'
                                  " /* ... */ is a comment in Objective C and Murphi, so we can't conclude
                                  " it's either of them yet, but track this as a hint in case we don't see
                                  " anything more definitive.
                                  let saw_comment = 1
                                endif
                                if line =~ '^\s*//' || line =~ '^\s*@import\>' || line =~ objc_preprocessor
                                  setf objc
                                  return
                                endif
                                if line =~ '^\s*\%(#\|%!\)' || line =~ '^\s*unwind_protect\>' ||
                            	  \ line =~ '\%(^\|;\)\s*' .. octave_block_terminators
                                  setf octave
                                  return
                                endif
                                " TODO: could be Matlab or Octave
                                if line =~ '^\s*%'
                                  setf matlab
                                  return
                                endif
                                if line =~ '^\s*(\*'
                                  setf mma
                                  return
                                endif
                                if line =~ '^\c\s*\(\(type\|var\)\>\|--\)'
                                  setf murphi
                                  return
                                endif
                                let n = n + 1
                              endwhile
                            
                              if saw_comment
                                " We didn't see anything definitive, but this looks like either Objective C
                                " or Murphi based on the comment leader. Assume the former as it is more
                                " common.
                                setf objc
                              else
                                " Default is Matlab
                                setf matlab
                              endif
                            endfunc
                            
    1              0.000008 func dist#ft#FTmms()
                              let n = 1
                              while n < 20
                                let line = getline(n)
                                if line =~ '^\s*\(%\|//\)' || line =~ '^\*'
                                  setf mmix
                                  return
                                endif
                                if line =~ '^\s*#'
                                  setf make
                                  return
                                endif
                                let n = n + 1
                              endwhile
                              setf mmix
                            endfunc
                            
                            " This function checks if one of the first five lines start with a dot.  In
                            " that case it is probably an nroff file: 'filetype' is set and 1 is returned.
    1              0.000012 func dist#ft#FTnroff()
                              if getline(1)[0] . getline(2)[0] . getline(3)[0] . getline(4)[0] . getline(5)[0] =~ '\.'
                                setf nroff
                                return 1
                              endif
                              return 0
                            endfunc
                            
    1              0.000008 func dist#ft#FTmm()
                              let n = 1
                              while n < 20
                                let line = getline(n)
                                if line =~ '^\s*\(#\s*\(include\|import\)\>\|@import\>\|/\*\)'
                                  setf objcpp
                                  return
                                endif
                                let n = n + 1
                              endwhile
                              setf nroff
                            endfunc
                            
    1              0.000006 func dist#ft#FTpl()
                              if exists("g:filetype_pl")
                                exe "setf " . g:filetype_pl
                              else
                                " recognize Prolog by specific text in the first non-empty line
                                " require a blank after the '%' because Perl uses "%list" and "%translate"
                                let l = getline(nextnonblank(1))
                                if l =~ '\<prolog\>' || l =~ '^\s*\(%\+\(\s\|$\)\|/\*\)' || l =~ ':-'
                                  setf prolog
                                else
                                  setf perl
                                endif
                              endif
                            endfunc
                            
    1              0.000006 func dist#ft#FTinc()
                              if exists("g:filetype_inc")
                                exe "setf " . g:filetype_inc
                              else
                                let lines = getline(1).getline(2).getline(3)
                                if lines =~? "perlscript"
                                  setf aspperl
                                elseif lines =~ "<%"
                                  setf aspvbs
                                elseif lines =~ "<?"
                                  setf php
                                " Pascal supports // comments but they're vary rarely used for file
                                " headers so assume POV-Ray
                                elseif lines =~ '^\s*\%({\|(\*\)' || lines =~? s:ft_pascal_keywords
                                  setf pascal
                                else
                                  call dist#ft#FTasmsyntax()
                                  if exists("b:asmsyntax")
                            	exe "setf " . fnameescape(b:asmsyntax)
                                  else
                            	setf pov
                                  endif
                                endif
                              endif
                            endfunc
                            
    1              0.000011 func dist#ft#FTprogress_cweb()
                              if exists("g:filetype_w")
                                exe "setf " . g:filetype_w
                                return
                              endif
                              if getline(1) =~ '&ANALYZE' || getline(3) =~ '&GLOBAL-DEFINE'
                                setf progress
                              else
                                setf cweb
                              endif
                            endfunc
                            
    1              0.000007 func dist#ft#FTprogress_asm()
                              if exists("g:filetype_i")
                                exe "setf " . g:filetype_i
                                return
                              endif
                              " This function checks for an assembly comment the first ten lines.
                              " If not found, assume Progress.
                              let lnum = 1
                              while lnum <= 10 && lnum < line('$')
                                let line = getline(lnum)
                                if line =~ '^\s*;' || line =~ '^\*'
                                  call dist#ft#FTasm()
                                  return
                                elseif line !~ '^\s*$' || line =~ '^/\*'
                                  " Not an empty line: Doesn't look like valid assembly code.
                                  " Or it looks like a Progress /* comment
                                  break
                                endif
                                let lnum = lnum + 1
                              endw
                              setf progress
                            endfunc
                            
    1              0.000019 let s:ft_pascal_comments = '^\s*\%({\|(\*\|//\)'
    1              0.000013 let s:ft_pascal_keywords = '^\s*\%(program\|unit\|library\|uses\|begin\|procedure\|function\|const\|type\|var\)\>'
                            
    1              0.000006 func dist#ft#FTprogress_pascal()
                              if exists("g:filetype_p")
                                exe "setf " . g:filetype_p
                                return
                              endif
                              " This function checks for valid Pascal syntax in the first ten lines.
                              " Look for either an opening comment or a program start.
                              " If not found, assume Progress.
                              let lnum = 1
                              while lnum <= 10 && lnum < line('$')
                                let line = getline(lnum)
                                if line =~ s:ft_pascal_comments || line =~? s:ft_pascal_keywords
                                  setf pascal
                                  return
                                elseif line !~ '^\s*$' || line =~ '^/\*'
                                  " Not an empty line: Doesn't look like valid Pascal code.
                                  " Or it looks like a Progress /* comment
                                  break
                                endif
                                let lnum = lnum + 1
                              endw
                              setf progress
                            endfunc
                            
    1              0.000006 func dist#ft#FTpp()
                              if exists("g:filetype_pp")
                                exe "setf " . g:filetype_pp
                              else
                                let line = getline(nextnonblank(1))
                                if line =~ s:ft_pascal_comments || line =~? s:ft_pascal_keywords
                                  setf pascal
                                else
                                  setf puppet
                                endif
                              endif
                            endfunc
                            
    1              0.000005 func dist#ft#FTr()
                              let max = line("$") > 50 ? 50 : line("$")
                            
                              for n in range(1, max)
                                " Rebol is easy to recognize, check for that first
                                if getline(n) =~? '\<REBOL\>'
                                  setf rebol
                                  return
                                endif
                              endfor
                            
                              for n in range(1, max)
                                " R has # comments
                                if getline(n) =~ '^\s*#'
                                  setf r
                                  return
                                endif
                                " Rexx has /* comments */
                                if getline(n) =~ '^\s*/\*'
                                  setf rexx
                                  return
                                endif
                              endfor
                            
                              " Nothing recognized, use user default or assume Rexx
                              if exists("g:filetype_r")
                                exe "setf " . g:filetype_r
                              else
                                " Rexx used to be the default, but R appears to be much more popular.
                                setf r
                              endif
                            endfunc
                            
    1              0.000007 func dist#ft#McSetf()
                              " Rely on the file to start with a comment.
                              " MS message text files use ';', Sendmail files use '#' or 'dnl'
                              for lnum in range(1, min([line("$"), 20]))
                                let line = getline(lnum)
                                if line =~ '^\s*\(#\|dnl\)'
                                  setf m4  " Sendmail .mc file
                                  return
                                elseif line =~ '^\s*;'
                                  setf msmessages  " MS Message text file
                                  return
                                endif
                              endfor
                              setf m4  " Default: Sendmail .mc file
                            endfunc
                            
                            " Called from filetype.vim and scripts.vim.
    1              0.000008 func dist#ft#SetFileTypeSH(name)
                              if did_filetype()
                                " Filetype was already detected
                                return
                              endif
                              if expand("<amatch>") =~ g:ft_ignore_pat
                                return
                              endif
                              if a:name =~ '\<csh\>'
                                " Some .sh scripts contain #!/bin/csh.
                                call dist#ft#SetFileTypeShell("csh")
                                return
                              elseif a:name =~ '\<tcsh\>'
                                " Some .sh scripts contain #!/bin/tcsh.
                                call dist#ft#SetFileTypeShell("tcsh")
                                return
                              elseif a:name =~ '\<zsh\>'
                                " Some .sh scripts contain #!/bin/zsh.
                                call dist#ft#SetFileTypeShell("zsh")
                                return
                              elseif a:name =~ '\<ksh\>'
                                let b:is_kornshell = 1
                                if exists("b:is_bash")
                                  unlet b:is_bash
                                endif
                                if exists("b:is_sh")
                                  unlet b:is_sh
                                endif
                              elseif exists("g:bash_is_sh") || a:name =~ '\<bash\>' || a:name =~ '\<bash2\>'
                                let b:is_bash = 1
                                if exists("b:is_kornshell")
                                  unlet b:is_kornshell
                                endif
                                if exists("b:is_sh")
                                  unlet b:is_sh
                                endif
                              elseif a:name =~ '\<sh\>'
                                let b:is_sh = 1
                                if exists("b:is_kornshell")
                                  unlet b:is_kornshell
                                endif
                                if exists("b:is_bash")
                                  unlet b:is_bash
                                endif
                              endif
                              call dist#ft#SetFileTypeShell("sh")
                            endfunc
                            
                            " For shell-like file types, check for an "exec" command hidden in a comment,
                            " as used for Tcl.
                            " Also called from scripts.vim, thus can't be local to this script.
    1              0.000008 func dist#ft#SetFileTypeShell(name)
                              if did_filetype()
                                " Filetype was already detected
                                return
                              endif
                              if expand("<amatch>") =~ g:ft_ignore_pat
                                return
                              endif
                              let l = 2
                              while l < 20 && l < line("$") && getline(l) =~ '^\s*\(#\|$\)'
                                " Skip empty and comment lines.
                                let l = l + 1
                              endwhile
                              if l < line("$") && getline(l) =~ '\s*exec\s' && getline(l - 1) =~ '^\s*#.*\\$'
                                " Found an "exec" line after a comment with continuation
                                let n = substitute(getline(l),'\s*exec\s\+\([^ ]*/\)\=', '', '')
                                if n =~ '\<tclsh\|\<wish'
                                  setf tcl
                                  return
                                endif
                              endif
                              exe "setf " . a:name
                            endfunc
                            
    1              0.000005 func dist#ft#CSH()
                              if did_filetype()
                                " Filetype was already detected
                                return
                              endif
                              if exists("g:filetype_csh")
                                call dist#ft#SetFileTypeShell(g:filetype_csh)
                              elseif &shell =~ "tcsh"
                                call dist#ft#SetFileTypeShell("tcsh")
                              else
                                call dist#ft#SetFileTypeShell("csh")
                              endif
                            endfunc
                            
    1              0.000016 let s:ft_rules_udev_rules_pattern = '^\s*\cudev_rules\s*=\s*"\([^"]\{-1,}\)/*".*'
    1              0.000006 func dist#ft#FTRules()
                              let path = expand('<amatch>:p')
                              if path =~ '/\(etc/udev/\%(rules\.d/\)\=.*\.rules\|\%(usr/\)\=lib/udev/\%(rules\.d/\)\=.*\.rules\)$'
                                setf udevrules
                                return
                              endif
                              if path =~ '^/etc/ufw/'
                                setf conf  " Better than hog
                                return
                              endif
                              if path =~ '^/\(etc\|usr/share\)/polkit-1/rules\.d'
                                setf javascript
                                return
                              endif
                              try
                                let config_lines = readfile('/etc/udev/udev.conf')
                              catch /^Vim\%((\a\+)\)\=:E484/
                                setf hog
                                return
                              endtry
                              let dir = expand('<amatch>:p:h')
                              for line in config_lines
                                if line =~ s:ft_rules_udev_rules_pattern
                                  let udev_rules = substitute(line, s:ft_rules_udev_rules_pattern, '\1', "")
                                  if dir == udev_rules
                            	setf udevrules
                                  endif
                                  break
                                endif
                              endfor
                              setf hog
                            endfunc
                            
    1              0.000005 func dist#ft#SQL()
                              if exists("g:filetype_sql")
                                exe "setf " . g:filetype_sql
                              else
                                setf sql
                              endif
                            endfunc
                            
                            " If the file has an extension of 't' and is in a directory 't' or 'xt' then
                            " it is almost certainly a Perl test file.
                            " If the first line starts with '#' and contains 'perl' it's probably a Perl
                            " file.
                            " (Slow test) If a file contains a 'use' statement then it is almost certainly
                            " a Perl file.
    1              0.000006 func dist#ft#FTperl()
                              let dirname = expand("%:p:h:t")
                              if expand("%:e") == 't' && (dirname == 't' || dirname == 'xt')
                                setf perl
                                return 1
                              endif
                              if getline(1)[0] == '#' && getline(1) =~ 'perl'
                                setf perl
                                return 1
                              endif
                              let save_cursor = getpos('.')
                              call cursor(1,1)
                              let has_use = search('^use\s\s*\k', 'c', 30)
                              call setpos('.', save_cursor)
                              if has_use
                                setf perl
                                return 1
                              endif
                              return 0
                            endfunc
                            
                            " Choose context, plaintex, or tex (LaTeX) based on these rules:
                            " 1. Check the first line of the file for "%&<format>".
                            " 2. Check the first 1000 non-comment lines for LaTeX or ConTeXt keywords.
                            " 3. Default to "plain" or to g:tex_flavor, can be set in user's vimrc.
    1              0.000005 func dist#ft#FTtex()
                              let firstline = getline(1)
                              if firstline =~ '^%&\s*\a\+'
                                let format = tolower(matchstr(firstline, '\a\+'))
                                let format = substitute(format, 'pdf', '', '')
                                if format == 'tex'
                                  let format = 'latex'
                                elseif format == 'plaintex'
                                  let format = 'plain'
                                endif
                              elseif expand('%') =~ 'tex/context/.*/.*.tex'
                                let format = 'context'
                              else
                                " Default value, may be changed later:
                                let format = exists("g:tex_flavor") ? g:tex_flavor : 'plain'
                                " Save position, go to the top of the file, find first non-comment line.
                                let save_cursor = getpos('.')
                                call cursor(1,1)
                                let firstNC = search('^\s*[^[:space:]%]', 'c', 1000)
                                if firstNC " Check the next thousand lines for a LaTeX or ConTeXt keyword.
                                  let lpat = 'documentclass\>\|usepackage\>\|begin{\|newcommand\>\|renewcommand\>'
                                  let cpat = 'start\a\+\|setup\a\+\|usemodule\|enablemode\|enableregime\|setvariables\|useencoding\|usesymbols\|stelle\a\+\|verwende\a\+\|stel\a\+\|gebruik\a\+\|usa\a\+\|imposta\a\+\|regle\a\+\|utilisemodule\>'
                                  let kwline = search('^\s*\\\%(' . lpat . '\)\|^\s*\\\(' . cpat . '\)',
                            			      \ 'cnp', firstNC + 1000)
                                  if kwline == 1	" lpat matched
                            	let format = 'latex'
                                  elseif kwline == 2	" cpat matched
                            	let format = 'context'
                                  endif		" If neither matched, keep default set above.
                                  " let lline = search('^\s*\\\%(' . lpat . '\)', 'cn', firstNC + 1000)
                                  " let cline = search('^\s*\\\%(' . cpat . '\)', 'cn', firstNC + 1000)
                                  " if cline > 0
                                  "   let format = 'context'
                                  " endif
                                  " if lline > 0 && (cline == 0 || cline > lline)
                                  "   let format = 'tex'
                                  " endif
                                endif " firstNC
                                call setpos('.', save_cursor)
                              endif " firstline =~ '^%&\s*\a\+'
                            
                              " Translation from formats to file types.  TODO:  add AMSTeX, RevTex, others?
                              if format == 'plain'
                                setf plaintex
                              elseif format == 'context'
                                setf context
                              else " probably LaTeX
                                setf tex
                              endif
                              return
                            endfunc
                            
    1              0.000006 func dist#ft#FTxml()
                              let n = 1
                              while n < 100 && n <= line("$")
                                let line = getline(n)
                                " DocBook 4 or DocBook 5.
                                let is_docbook4 = line =~ '<!DOCTYPE.*DocBook'
                                let is_docbook5 = line =~ ' xmlns="http://docbook.org/ns/docbook"'
                                if is_docbook4 || is_docbook5
                                  let b:docbk_type = "xml"
                                  if is_docbook5
                            	let b:docbk_ver = 5
                                  else
                            	let b:docbk_ver = 4
                                  endif
                                  setf docbk
                                  return
                                endif
                                if line =~ 'xmlns:xbl="http://www.mozilla.org/xbl"'
                                  setf xbl
                                  return
                                endif
                                let n += 1
                              endwhile
                              setf xml
                            endfunc
                            
    1              0.000005 func dist#ft#FTy()
                              let n = 1
                              while n < 100 && n <= line("$")
                                let line = getline(n)
                                if line =~ '^\s*%'
                                  setf yacc
                                  return
                                endif
                                if getline(n) =~ '^\s*\(#\|class\>\)' && getline(n) !~ '^\s*#\s*include'
                                  setf racc
                                  return
                                endif
                                let n = n + 1
                              endwhile
                              setf yacc
                            endfunc
                            
    1              0.000006 func dist#ft#Redif()
                              let lnum = 1
                              while lnum <= 5 && lnum < line('$')
                                if getline(lnum) =~ "^\ctemplate-type:"
                                  setf redif
                                  return
                                endif
                                let lnum = lnum + 1
                              endwhile
                            endfunc
                            
                            
                            " Restore 'cpoptions'
    1              0.000048 let &cpo = s:cpo_save
    1              0.000058 unlet s:cpo_save

SCRIPT  C:\Users\Lenovo\AppData\Local\nvim-data\plugged\tagbar\syntax\tagbar.vim
Sourced 1 time
Total time:   0.001949
 Self time:   0.001949

count  total (s)   self (s)
                            " File:        tagbar.vim
                            " Description: Tagbar syntax settings
                            " Author:      Jan Larres <jan@majutsushi.net>
                            " Licence:     Vim licence
                            " Website:     https://preservim.github.io/tagbar
                            " Version:     3.0.0
                            
    1              0.000015 scriptencoding utf-8
                            
    1              0.000028 if exists('b:current_syntax')
                                finish
    1              0.000003 endif
                            
    1              0.000029 let s:ics = escape(join(g:tagbar_iconchars, ''), ']^\-')
                            
    1              0.000015 let s:pattern = '\(^[' . s:ics . '] \?\)\@3<=[^-+: ]\+[^:]\+$'
    1              0.000067 execute "syntax match TagbarKind '" . s:pattern . "'"
                            
    1              0.000017 let s:pattern = '\(\S\@<![' . s:ics . '][-+# ]\?\)\@<=[^*(]\+\(\*\?\(([^)]\+)\)\? :\)\@='
    1              0.000047 execute "syntax match TagbarScope '" . s:pattern . "'"
                            
    1              0.000012 let s:pattern = '\S\@<![' . s:ics . ']\([-+# ]\?\)\@='
    1              0.000028 execute "syntax match TagbarFoldIcon '" . s:pattern . "'"
                            
    1              0.000014 let s:pattern = '\(\S\@<![' . s:ics . ' ]\)\@<=+\([^-+# ]\)\@='
    1              0.000526 execute "syntax match TagbarVisibilityPublic '" . s:pattern . "'"
    1              0.000025 let s:pattern = '\(\S\@<![' . s:ics . ' ]\)\@<=#\([^-+# ]\)\@='
    1              0.000043 execute "syntax match TagbarVisibilityProtected '" . s:pattern . "'"
    1              0.000013 let s:pattern = '\(\S\@<![' . s:ics . ' ]\)\@<=-\([^-+# ]\)\@='
    1              0.000027 execute "syntax match TagbarVisibilityPrivate '" . s:pattern . "'"
                            
    1              0.000007 unlet s:pattern
                            
    1              0.000032 syntax match TagbarHelp      '^".*' contains=TagbarHelpKey,TagbarHelpTitle
    1              0.000018 syntax match TagbarHelpKey   '" \zs.*\ze:' contained
    1              0.000017 syntax match TagbarHelpTitle '" \zs-\+ \w\+ -\+' contained
                            
    1              0.000016 syntax match TagbarNestedKind '^\s\+\[[^]]\+\]$'
    1              0.000033 syntax match TagbarType       ' : \zs.*' contains=TagbarTagLineN
    1              0.000019 syntax match TagbarTagLineN   '\s\+\[[0-9]\+\]\(\s\+\|$\)'
    1              0.000022 syntax match TagbarSignature  '\(\<operator *( *) *\)\?\zs(.*)\ze'
    1              0.000012 syntax match TagbarPseudoID   '\*\ze :'
                            
    1              0.000010 highlight default link TagbarHelp       Comment
    1              0.000007 highlight default link TagbarHelpKey    Identifier
    1              0.000006 highlight default link TagbarHelpTitle  PreProc
    1              0.000006 highlight default link TagbarKind       Identifier
    1              0.000005 highlight default link TagbarNestedKind TagbarKind
    1              0.000006 highlight default link TagbarScope      Title
    1              0.000005 highlight default link TagbarType       Type
    1              0.000005 highlight default link TagbarTagLineN   Comment
    1              0.000005 highlight default link TagbarSignature  SpecialKey
    1              0.000005 highlight default link TagbarPseudoID   NonText
    1              0.000005 highlight default link TagbarFoldIcon   Statement
    1              0.000006 highlight default link TagbarHighlight  Search
                            
    1              0.000245 highlight default TagbarAccessPublic    guifg=Green ctermfg=Green
    1              0.000037 highlight default TagbarAccessProtected guifg=Blue  ctermfg=Blue
    1              0.000230 highlight default TagbarAccessPrivate   guifg=Red   ctermfg=Red
    1              0.000008 highlight default link TagbarVisibilityPublic    TagbarAccessPublic
    1              0.000007 highlight default link TagbarVisibilityProtected TagbarAccessProtected
    1              0.000005 highlight default link TagbarVisibilityPrivate   TagbarAccessPrivate
                            
    1              0.000010 let b:current_syntax = 'tagbar'
                            
                            " vim: ts=8 sw=4 sts=4 et foldenable foldmethod=marker foldcolumn=1

SCRIPT  C:\Users\Lenovo\AppData\Local\nvim-data\plugged\vim-polyglot\syntax\markdown.vim
Sourced 1 time
Total time:   0.538746
 Self time:   0.090305

count  total (s)   self (s)
    1   0.000425   0.000328 if polyglot#init#is_disabled(expand('<sfile>:p'), 'markdown', 'syntax/markdown.vim')
                              finish
    1              0.000003 endif
                            
                            " Vim syntax file
                            " Language:	Markdown
                            " Maintainer:	Ben Williams <benw@plasticboy.com>
                            " URL:		http://plasticboy.com/markdown-vim-mode/
                            " Remark:	Uses HTML syntax file
                            " TODO: 	Handle stuff contained within stuff (e.g. headings within blockquotes)
                            
                            
                            " Read the HTML syntax to start with
    1              0.000006 if version < 600
                              so <sfile>:p:h/html.vim
    1              0.000003 else
    1   0.533551   0.085207   runtime! syntax/html.vim
                            
    1              0.000025   if exists('b:current_syntax')
    1              0.000011     unlet b:current_syntax
    1              0.000004   endif
    1              0.000003 endif
                            
    1              0.000008 if version < 600
                              syntax clear
    1              0.000012 elseif exists("b:current_syntax")
                              finish
    1              0.000003 endif
                            
                            " don't use standard HiLink, it will not work with included syntax files
    1              0.000006 if version < 508
                              command! -nargs=+ HtmlHiLink hi link <args>
    1              0.000004 else
    1              0.000051   command! -nargs=+ HtmlHiLink hi def link <args>
    1              0.000003 endif
                            
    1              0.000009 syn spell toplevel
    1              0.000008 syn case ignore
    1              0.000010 syn sync linebreaks=1
                            
    1              0.000012 let s:conceal = ''
    1              0.000007 let s:concealends = ''
    1              0.000007 let s:concealcode = ''
    1              0.000032 if has('conceal') && get(g:, 'vim_markdown_conceal', 1)
    1              0.000008   let s:conceal = ' conceal'
    1              0.000007   let s:concealends = ' concealends'
    1              0.000004 endif
    1              0.000033 if has('conceal') && get(g:, 'vim_markdown_conceal_code_blocks', 1)
    1              0.000006   let s:concealcode = ' concealends'
    1              0.000002 endif
                            
                            " additions to HTML groups
    1              0.000010 if get(g:, 'vim_markdown_emphasis_multiline', 1)
    1              0.000006     let s:oneline = ''
                            else
                                let s:oneline = ' oneline'
    1              0.000004 endif
    1              0.000048 syn region mkdItalic matchgroup=mkdItalic start="\%(\*\|_\)"    end="\%(\*\|_\)"
    1              0.000031 syn region mkdBold matchgroup=mkdBold start="\%(\*\*\|__\)"    end="\%(\*\*\|__\)"
    1              0.000032 syn region mkdBoldItalic matchgroup=mkdBoldItalic start="\%(\*\*\*\|___\)"    end="\%(\*\*\*\|___\)"
    1              0.000114 execute 'syn region htmlItalic matchgroup=mkdItalic start="\%(^\|\s\)\zs\*\ze[^\\\*\t ]\%(\%([^*]\|\\\*\|\n\)*[^\\\*\t ]\)\?\*\_W" end="[^\\\*\t ]\zs\*\ze\_W" keepend contains=@Spell' . s:oneline . s:concealends
    1              0.000062 execute 'syn region htmlItalic matchgroup=mkdItalic start="\%(^\|\s\)\zs_\ze[^\\_\t ]" end="[^\\_\t ]\zs_\ze\_W" keepend contains=@Spell' . s:oneline . s:concealends
    1              0.000067 execute 'syn region htmlBold matchgroup=mkdBold start="\%(^\|\s\)\zs\*\*\ze\S" end="\S\zs\*\*" keepend contains=@Spell' . s:oneline . s:concealends
    1              0.000049 execute 'syn region htmlBold matchgroup=mkdBold start="\%(^\|\s\)\zs__\ze\S" end="\S\zs__" keepend contains=@Spell' . s:oneline . s:concealends
    1              0.000067 execute 'syn region htmlBoldItalic matchgroup=mkdBoldItalic start="\%(^\|\s\)\zs\*\*\*\ze\S" end="\S\zs\*\*\*" keepend contains=@Spell' . s:oneline . s:concealends
    1              0.000052 execute 'syn region htmlBoldItalic matchgroup=mkdBoldItalic start="\%(^\|\s\)\zs___\ze\S" end="\S\zs___" keepend contains=@Spell' . s:oneline . s:concealends
                            
                            " [link](URL) | [link][id] | [link][] | ![image](URL)
    1              0.000026 syn region mkdFootnotes matchgroup=mkdDelimiter start="\[^"    end="\]"
    1              0.000036 execute 'syn region mkdID matchgroup=mkdDelimiter    start="\["    end="\]" contained oneline' . s:conceal
    1              0.000035 execute 'syn region mkdURL matchgroup=mkdDelimiter   start="("     end=")"  contained oneline' . s:conceal
    1              0.000092 execute 'syn region mkdLink matchgroup=mkdDelimiter  start="\\\@<!!\?\[\ze[^]\n]*\n\?[^]\n]*\][[(]" end="\]" contains=@mkdNonListItem,@Spell nextgroup=mkdURL,mkdID skipwhite' . s:concealends
                            
                            " Autolink without angle brackets.
                            " mkd  inline links:      protocol     optional  user:pass@  sub/domain                    .com, .co.uk, etc         optional port   path/querystring/hash fragment
                            "                         ------------ _____________________ ----------------------------- _________________________ ----------------- __
    1              0.000083 syn match   mkdInlineURL /https\?:\/\/\(\w\+\(:\w\+\)\?@\)\?\([A-Za-z0-9][-_0-9A-Za-z]*\.\)\{1,}\(\w\{2,}\.\?\)\{1,}\(:[0-9]\{1,5}\)\?[^] \t]*/
                            
                            " Autolink with parenthesis.
    1              0.000088 syn region  mkdInlineURL matchgroup=mkdDelimiter start="(\(https\?:\/\/\(\w\+\(:\w\+\)\?@\)\?\([A-Za-z0-9][-_0-9A-Za-z]*\.\)\{1,}\(\w\{2,}\.\?\)\{1,}\(:[0-9]\{1,5}\)\?[^] \t]*)\)\@=" end=")"
                            
                            " Autolink with angle brackets.
    1              0.000104 syn region mkdInlineURL matchgroup=mkdDelimiter start="\\\@<!<\ze[a-z][a-z0-9,.-]\{1,22}:\/\/[^> ]*>" end=">"
                            
                            " Link definitions: [id]: URL (Optional Title)
    1              0.000069 syn region mkdLinkDef matchgroup=mkdDelimiter   start="^ \{,3}\zs\[\^\@!" end="]:" oneline nextgroup=mkdLinkDefTarget skipwhite
    1              0.000046 syn region mkdLinkDefTarget start="<\?\zs\S" excludenl end="\ze[>[:space:]\n]"   contained nextgroup=mkdLinkTitle,mkdLinkDef skipwhite skipnl oneline
    1              0.000025 syn region mkdLinkTitle matchgroup=mkdDelimiter start=+"+     end=+"+  contained
    1              0.000017 syn region mkdLinkTitle matchgroup=mkdDelimiter start=+'+     end=+'+  contained
    1              0.000036 syn region mkdLinkTitle matchgroup=mkdDelimiter start=+(+     end=+)+  contained
                            
                            "HTML headings
    1              0.000066 syn region htmlH1       matchgroup=mkdHeading     start="^\s*#"                   end="$" contains=mkdLink,mkdInlineURL,@Spell
    1              0.000048 syn region htmlH2       matchgroup=mkdHeading     start="^\s*##"                  end="$" contains=mkdLink,mkdInlineURL,@Spell
    1              0.000038 syn region htmlH3       matchgroup=mkdHeading     start="^\s*###"                 end="$" contains=mkdLink,mkdInlineURL,@Spell
    1              0.000027 syn region htmlH4       matchgroup=mkdHeading     start="^\s*####"                end="$" contains=mkdLink,mkdInlineURL,@Spell
    1              0.000027 syn region htmlH5       matchgroup=mkdHeading     start="^\s*#####"               end="$" contains=mkdLink,mkdInlineURL,@Spell
    1              0.000032 syn region htmlH6       matchgroup=mkdHeading     start="^\s*######"              end="$" contains=mkdLink,mkdInlineURL,@Spell
    1              0.000023 syn match  htmlH1       /^.\+\n=\+$/ contains=mkdLink,mkdInlineURL,@Spell
    1              0.000024 syn match  htmlH2       /^.\+\n-\+$/ contains=mkdLink,mkdInlineURL,@Spell
                            
                            "define Markdown groups
    1              0.000015 syn match  mkdLineBreak    /  \+$/
    1              0.000029 syn region mkdBlockquote   start=/^\s*>/                   end=/$/ contains=mkdLink,mkdInlineURL,mkdLineBreak,@Spell
    1              0.000058 execute 'syn region mkdCode matchgroup=mkdCodeDelimiter start=/\(\([^\\]\|^\)\\\)\@<!`/                     end=/`/'  . s:concealcode
    1              0.000053 execute 'syn region mkdCode matchgroup=mkdCodeDelimiter start=/\(\([^\\]\|^\)\\\)\@<!``/ skip=/[^`]`[^`]/   end=/``/' . s:concealcode
    1              0.000054 execute 'syn region mkdCode matchgroup=mkdCodeDelimiter start=/^\s*\z(`\{3,}\)[^`]*$/                       end=/^\s*\z1`*\s*$/'            . s:concealcode
    1              0.000047 execute 'syn region mkdCode matchgroup=mkdCodeDelimiter start=/\(\([^\\]\|^\)\\\)\@<!\~\~/  end=/\(\([^\\]\|^\)\\\)\@<!\~\~/'               . s:concealcode
    1              0.000055 execute 'syn region mkdCode matchgroup=mkdCodeDelimiter start=/^\s*\z(\~\{3,}\)\s*[0-9A-Za-z_+-]*\s*$/      end=/^\s*\z1\~*\s*$/'           . s:concealcode
    1              0.000048 execute 'syn region mkdCode matchgroup=mkdCodeDelimiter start="<pre\(\|\_s[^>]*\)\\\@<!>"                   end="</pre>"'                   . s:concealcode
    1              0.000043 execute 'syn region mkdCode matchgroup=mkdCodeDelimiter start="<code\(\|\_s[^>]*\)\\\@<!>"                  end="</code>"'                  . s:concealcode
    1              0.000025 syn region mkdFootnote     start="\[^"                     end="\]"
    1              0.000037 syn match  mkdCode         /^\s*\n\(\(\s\{8,}[^ ]\|\t\t\+[^\t]\).*\n\)\+/
    1              0.000031 syn match  mkdCode         /\%^\(\(\s\{4,}[^ ]\|\t\+[^\t]\).*\n\)\+/
    1              0.000029 syn match  mkdCode         /^\s*\n\(\(\s\{4,}[^ ]\|\t\+[^\t]\).*\n\)\+/ contained
    1              0.000022 syn match  mkdListItem     /^\s*\%([-*+]\|\d\+\.\)\ze\s\+/ contained
    1              0.000085 syn region mkdListItemLine start="^\s*\%([-*+]\|\d\+\.\)\s\+" end="$" oneline contains=@mkdNonListItem,mkdListItem,@Spell
    1              0.000066 syn region mkdNonListItemBlock start="\(\%^\(\s*\([-*+]\|\d\+\.\)\s\+\)\@!\|\n\(\_^\_$\|\s\{4,}[^ ]\|\t+[^\t]\)\@!\)" end="^\(\s*\([-*+]\|\d\+\.\)\s\+\)\@=" contains=@mkdNonListItem,@Spell
    1              0.000024 syn match  mkdRule         /^\s*\*\s\{0,1}\*\s\{0,1}\*\(\*\|\s\)*$/
    1              0.000040 syn match  mkdRule         /^\s*-\s\{0,1}-\s\{0,1}-\(-\|\s\)*$/
    1              0.000031 syn match  mkdRule         /^\s*_\s\{0,1}_\s\{0,1}_\(_\|\s\)*$/
                            
                            " YAML frontmatter
    1              0.000021 if get(g:, 'vim_markdown_frontmatter', 0)
                              syn include @yamlTop syntax/yaml.vim
                              syn region Comment matchgroup=mkdDelimiter start="\%^---$" end="^\(---\|\.\.\.\)$" contains=@yamlTop keepend
                              unlet! b:current_syntax
    1              0.000004 endif
                            
    1              0.000015 if get(g:, 'vim_markdown_toml_frontmatter', 0)
                              try
                                syn include @tomlTop syntax/toml.vim
                                syn region Comment matchgroup=mkdDelimiter start="\%^+++$" end="^+++$" transparent contains=@tomlTop keepend
                                unlet! b:current_syntax
                              catch /E484/
                                syn region Comment matchgroup=mkdDelimiter start="\%^+++$" end="^+++$"
                              endtry
    1              0.000003 endif
                            
    1              0.000016 if get(g:, 'vim_markdown_json_frontmatter', 0)
                              try
                                syn include @jsonTop syntax/json.vim
                                syn region Comment matchgroup=mkdDelimiter start="\%^{$" end="^}$" contains=@jsonTop keepend
                                unlet! b:current_syntax
                              catch /E484/
                                syn region Comment matchgroup=mkdDelimiter start="\%^{$" end="^}$"
                              endtry
    1              0.000003 endif
                            
    1              0.000013 if get(g:, 'vim_markdown_math', 0)
                              syn include @tex syntax/tex.vim
                              syn region mkdMath start="\\\@<!\$" end="\$" skip="\\\$" contains=@tex keepend
                              syn region mkdMath start="\\\@<!\$\$" end="\$\$" skip="\\\$" contains=@tex keepend
    1              0.000003 endif
                            
                            " Strike through
    1              0.000015 if get(g:, 'vim_markdown_strikethrough', 0)
                                execute 'syn region mkdStrike matchgroup=htmlStrike start="\%(\~\~\)" end="\%(\~\~\)"' . s:concealends
                                HtmlHiLink mkdStrike        htmlStrike
    1              0.000003 endif
                            
    1              0.000084 syn cluster mkdNonListItem contains=@htmlTop,htmlItalic,htmlBold,htmlBoldItalic,mkdFootnotes,mkdInlineURL,mkdLink,mkdLinkDef,mkdLineBreak,mkdBlockquote,mkdCode,mkdRule,htmlH1,htmlH2,htmlH3,htmlH4,htmlH5,htmlH6,mkdMath,mkdStrike
                            
                            "highlighting for Markdown groups
    1              0.000026 HtmlHiLink mkdString        String
    1              0.000016 HtmlHiLink mkdCode          String
    1              0.000014 HtmlHiLink mkdCodeDelimiter String
    1              0.000015 HtmlHiLink mkdCodeStart     String
    1              0.000015 HtmlHiLink mkdCodeEnd       String
    1              0.000015 HtmlHiLink mkdFootnote      Comment
    1              0.000014 HtmlHiLink mkdBlockquote    Comment
    1              0.000015 HtmlHiLink mkdListItem      Identifier
    1              0.000014 HtmlHiLink mkdRule          Identifier
    1              0.000014 HtmlHiLink mkdLineBreak     Visual
    1              0.000015 HtmlHiLink mkdFootnotes     htmlLink
    1              0.000014 HtmlHiLink mkdLink          htmlLink
    1              0.000014 HtmlHiLink mkdURL           htmlString
    1              0.000014 HtmlHiLink mkdInlineURL     htmlLink
    1              0.000014 HtmlHiLink mkdID            Identifier
    1              0.000014 HtmlHiLink mkdLinkDef       mkdID
    1              0.000014 HtmlHiLink mkdLinkDefTarget mkdURL
    1              0.000014 HtmlHiLink mkdLinkTitle     htmlString
    1              0.000014 HtmlHiLink mkdDelimiter     Delimiter
                            
    1              0.000013 let b:current_syntax = "mkd"
                            
    1              0.000008 delcommand HtmlHiLink
                            " vim: ts=8

SCRIPT  C:\Users\Lenovo\AppData\Local\nvim-data\plugged\vim-polyglot\syntax\html.vim
Sourced 1 time
Total time:   0.009178
 Self time:   0.009064

count  total (s)   self (s)
    1   0.000488   0.000374 if polyglot#init#is_disabled(expand('<sfile>:p'), 'html5', 'syntax/html.vim')
                              finish
    1              0.000004 endif
                            
                            " Vim syntax file
                            " Language:     HTML (version 5.1)
                            "               SVG (SVG 1.1 Second Edition)
                            "               MathML (MathML 3.0 Second Edition)
                            " Last Change:  2017 Mar 07
                            " License:      Public domain
                            "               (but let me know if you like :) )
                            "
                            " Note: This file just add new tags from HTML 5
                            "       and don't replace default html.vim syntax file
                            "
                            " Maintainer:   Kao, Wei-Ko(othree) ( othree AT gmail DOT com )
                            " Changes:      update to Draft 2016 Jan 13
                            "               add microdata Attributes
                            " Maintainer:   Rodrigo Machado <rcmachado@gmail.com>
                            " URL:          http://rm.blog.br/vim/syntax/html.vim
                            " Modified:     htdebeer <H.T.de.Beer@gmail.com>
                            " Changes:      add common SVG elements and attributes for inline SVG
                            
                            " Patch 7.4.1142
    1              0.000061 if has("patch-7.4-1142")
    1              0.000012   if has("win32")
    1              0.000040     syn iskeyword @,48-57,_,128-167,224-235,-
                              else
                                syn iskeyword @,48-57,_,192-255,-
    1              0.000003   endif
    1              0.000003 endif
                            
                            " HTML 5 tags
    1              0.000025 syn keyword htmlTagName contained article aside audio canvas command
    1              0.000019 syn keyword htmlTagName contained datalist details dialog embed figcaption figure footer
    1              0.000021 syn keyword htmlTagName contained header hgroup keygen main mark meter menu menuitem nav output
    1              0.000020 syn keyword htmlTagName contained progress ruby rt rp rb rtc section source summary time track video data
    1              0.000011 syn keyword htmlTagName contained template content shadow slot
    1              0.000007 syn keyword htmlTagName contained wbr bdi
    1              0.000005 syn keyword htmlTagName contained picture
                            
                            " SVG tags
                            " http://www.w3.org/TR/SVG/
                            " as found in http://www.w3.org/TR/SVG/eltindex.html
    1              0.000011 syn keyword htmlTagName contained svg 
    1              0.000022 syn keyword htmlTagName contained altGlyph altGlyphDef altGlyphItem 
    1              0.000024 syn keyword htmlTagName contained animate animateColor animateMotion animateTransform 
    1              0.000017 syn keyword htmlTagName contained circle ellipse rect line polyline polygon image path
    1              0.000011 syn keyword htmlTagName contained clipPath color-profile cursor 
    1              0.000023 syn keyword htmlTagName contained defs desc g symbol view use switch foreignObject
    1              0.000050 syn keyword htmlTagName contained filter feBlend feColorMatrix feComponentTransfer feComposite feConvolveMatrix feDiffuseLighting feDisplacementMap feDistantLight feFlood feFuncA feFuncB feFuncG feFuncR feGaussianBlur feImage feMerge feMergeNode feMorphology feOffset fePointLight feSpecularLighting feSpotLight feTile feTurbulence 
    1              0.000014 syn keyword htmlTagName contained font font-face font-face-format font-face-name font-face-src font-face-uri 
    1              0.000009 syn keyword htmlTagName contained glyph glyphRef hkern 
    1              0.000012 syn keyword htmlTagName contained linearGradient marker mask pattern radialGradient set stop
    1              0.000008 syn keyword htmlTagName contained missing-glyph mpath 
    1              0.000011 syn keyword htmlTagName contained text textPath tref tspan vkern
    1              0.000007 syn keyword htmlTagName contained metadata title
                            
                            " MathML tags
                            " https://www.w3.org/TR/MathML3/appendixi.html#index.elem
    1              0.000015 syn keyword htmlTagName contained abs and annotation annotation-xml apply approx arccos arccosh arccot arccoth
    1              0.000014 syn keyword htmlTagName contained arccsc arccsch arcsec arcsech arcsin arcsinh arctan arctanh arg bind
    1              0.000017 syn keyword htmlTagName contained bvar card cartesianproduct cbytes ceiling cerror ci cn codomain complexes
    1              0.000019 syn keyword htmlTagName contained compose condition conjugate cos cosh cot coth cs csc csch
    1              0.000019 syn keyword htmlTagName contained csymbol curl declare degree determinant diff divergence divide domain domainofapplication
    1              0.000127 syn keyword htmlTagName contained emptyset eq equivalent eulergamma exists exp exponentiale factorial factorof false
    1              0.000110 syn keyword htmlTagName contained floor fn forall gcd geq grad gt ident image imaginary
    1              0.000131 syn keyword htmlTagName contained imaginaryi implies in infinity int integers intersect interval inverse lambda
    1              0.000086 syn keyword htmlTagName contained laplacian lcm leq limit list ln log logbase lowlimit lt
    1              0.000059 syn keyword htmlTagName contained maction maligngroup malignmark math matrix matrixrow max mean median menclose
    1              0.000015 syn keyword htmlTagName contained merror mfenced mfrac mglyph mi mi" min minus mlabeledtr mlongdiv
    1              0.000021 syn keyword htmlTagName contained mmultiscripts mn mo mode moment momentabout mover mpadded mphantom mprescripts
    1              0.000014 syn keyword htmlTagName contained mroot mrow ms mscarries mscarry msgroup msline mspace msqrt msrow
    1              0.000014 syn keyword htmlTagName contained mstack mstyle msub msubsup msup mtable mtd mtext mtr munder
    1              0.000018 syn keyword htmlTagName contained munderover naturalnumbers neq none not notanumber notin notprsubset notsubset or
    1              0.000016 syn keyword htmlTagName contained otherwise outerproduct partialdiff pi piece piecewise plus power primes product
    1              0.000016 syn keyword htmlTagName contained prsubset quotient rationals real reals reln rem root scalarproduct sdev
    1              0.000016 syn keyword htmlTagName contained sec sech selector semantics sep set setdiff share sin sinh
    1              0.000016 syn keyword htmlTagName contained span subset sum tan tanh tendsto times transpose true union
    1              0.000009 syn keyword htmlTagName contained uplimit variance vector vectorproduct xor
                            
                            " Custom Element
    1              0.000050 syn match htmlTagName contained "\<[a-z][-.0-9_a-z]*-[-.0-9_a-z]*\>"
    1              0.000024 syn match htmlTagName contained "[.0-9_a-z]\@<=-[-.0-9_a-z]*\>"
                            
                            " HTML 5 arguments
                            " Core Attributes
    1              0.000015 syn keyword htmlArg contained accesskey class contenteditable contextmenu dir 
    1              0.000016 syn keyword htmlArg contained draggable hidden id is lang spellcheck style tabindex title translate
                            " Event-handler Attributes
    1              0.000013 syn keyword htmlArg contained onabort onblur oncanplay oncanplaythrough onchange
    1              0.000015 syn keyword htmlArg contained onclick oncontextmenu ondblclick ondrag ondragend ondragenter ondragleave ondragover 
    1              0.000016 syn keyword htmlArg contained ondragstart ondrop ondurationchange onemptied onended onerror onfocus onformchange 
    1              0.000015 syn keyword htmlArg contained onforminput oninput oninvalid onkeydown onkeypress onkeyup onload onloadeddata 
    1              0.000015 syn keyword htmlArg contained onloadedmetadata onloadstart onmousedown onmousemove onmouseout onmouseover onmouseup
    1              0.000015 syn keyword htmlArg contained onmousewheel onpause onplay onplaying onprogress onratechange onreadystatechange 
    1              0.000015 syn keyword htmlArg contained onscroll onseeked onseeking onselect onshow onstalled onsubmit onsuspend ontimeupdate 
    1              0.000007 syn keyword htmlArg contained onvolumechange onwaiting
                            " XML Attributes
    1              0.000009 syn keyword htmlArg contained xml:lang xml:space xml:base xmlns
                            " new features
                            " <body>
    1              0.000016 syn keyword htmlArg contained onafterprint onbeforeprint onbeforeunload onblur onerror onfocus onhashchange onload 
    1              0.000015 syn keyword htmlArg contained onmessage onoffline ononline onpopstate onredo onresize onstorage onundo onunload
                            " <video>, <audio>, <source>, <track>
    1              0.000023 syn keyword htmlArg contained autoplay preload controls loop poster media kind charset srclang track playsinline
                            " <form>, <input>, <button>
    1              0.000013 syn keyword htmlArg contained form autocomplete autofocus list min max step
    1              0.000013 syn keyword htmlArg contained formaction autofocus formenctype formmethod formtarget formnovalidate
    1              0.000008 syn keyword htmlArg contained required placeholder pattern
                            " <command>, <details>, <time>
    1              0.000010 syn keyword htmlArg contained label icon open datetime-local pubdate
                            " <script>
    1              0.000006 syn keyword htmlArg contained async
                            " <content>
    1              0.000006 syn keyword htmlArg contained select
                            " <iframe>
    1              0.000014 syn keyword htmlArg contained seamless srcdoc sandbox allowfullscreen allowusermedia allowpaymentrequest allowpresentation
                            " <picture>
    1              0.000007 syn keyword htmlArg contained srcset sizes
                            " <a>
    1              0.000007 syn keyword htmlArg contained download media
                            " <script>, <style>
    1              0.000006 syn keyword htmlArg contained nonce
                            " <area>, <a>, <img>, <iframe>, <link>
    1              0.000007 syn keyword htmlArg contained referrerpolicy
                            " https://w3c.github.io/webappsec-subresource-integrity/#the-integrity-attribute
    1              0.000007 syn keyword htmlArg contained integrity crossorigin
                            " <link>
    1              0.000006 syn keyword htmlArg contained prefetch 
                            " syn keyword htmlArg contained preload
                            " <img>
    1              0.000007 syn keyword htmlArg contained decoding
                            " https://w3c.github.io/selection-api/#extensions-to-globaleventhandlers
    1              0.000009 syn keyword htmlArg contained onselectstart onselectionchange
                            " https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/loading
    1              0.000005 syn keyword htmlArg contained loading
                            
                            " Custom Data Attributes
                            " http://w3c.github.io/html/single-page.html#embedding-custom-non-visible-data-with-the-data-attributes
    1              0.000078 syn match   htmlArg "\<data[-.0-9_a-z]*-[-.0-9_a-z]*\>" contained
                            
                            " Vendor Extension Attributes
                            " http://w3c.github.io/html/single-page.html#conformance-requirements-extensibility
    1              0.000020 syn match   htmlArg "\<x[-.0-9_a-z]*-[-.0-9_a-z]*\>" contained
                            
                            " Microdata
                            " http://dev.w3.org/html5/md/
    1              0.000012 syn keyword htmlArg contained itemid itemscope itemtype itemprop itemref
                            
                            " SVG
                            " http://www.w3.org/TR/SVG/
                            " Some common attributes from http://www.w3.org/TR/SVG/attindex.html
    1              0.000018 syn keyword htmlArg contained accent-height accumulate additive alphabetic amplitude arabic-form ascent attributeName attributeType azimuth 
    1              0.000012 syn keyword htmlArg contained baseFrequency baseProfile bbox begin bias by 
    1              0.000017 syn keyword htmlArg contained calcMode cap-height class clipPathUnits contentScriptType contentStyleType cx cy 
    1              0.000014 syn keyword htmlArg contained d descent diffuseConstant divisor dur dx dy 
    1              0.000015 syn keyword htmlArg contained edgeMode elevation end exponent externalResourcesRequired 
    1              0.000023 syn keyword htmlArg contained fill filterRes filterUnits font-family font-size font-stretch font-style font-variant font-weight format format from fx fy 
    1              0.000014 syn keyword htmlArg contained g1 g2 glyph-name glyphRef gradientTransform gradientUnits 
    1              0.000011 syn keyword htmlArg contained hanging height horiz-adv-x horiz-origin-x horiz-origin-y 
    1              0.000011 syn keyword htmlArg contained id ideographic in in2 intercept 
    1              0.000023 syn keyword htmlArg contained k k1 k2 k3 k4 kernelMatrix kernelUnitLength keyPoints keySplines keyTimes 
    1              0.000011 syn keyword htmlArg contained lang lengthAdjust limitingConeAngle local 
    1              0.000019 syn keyword htmlArg contained markerHeight markerUnits markerWidth maskContentUnits maskUnits mathematical max media method min mode name 
    1              0.000012 syn keyword htmlArg contained numOctaves 
    1              0.000045 syn keyword htmlArg contained offset onabort onactivate onbegin onclick onend onerror onfocusin onfocusout onload onmousedown onmousemove onmouseout onmouseover onmouseup onrepeat onresize onscroll onunload onzoom operator order orient orientation origin overline-position overline-thickness 
    1              0.000024 syn keyword htmlArg contained panose-1 path pathLength patternContentUnits patternTransform patternUnits points pointsAtX pointsAtY pointsAtZ preserveAlpha preserveAspectRatio primitiveUnits 
    1              0.000023 syn keyword htmlArg contained r radius refX refY rendering-intent repeatCount repeatDur requiredExtensions requiredFeatures restart result rotate rx ry 
    1              0.000032 syn keyword htmlArg contained scale seed slope spacing specularConstant specularExponent spreadMethod startOffset stdDeviation stemh stemv stitchTiles strikethrough-position strikethrough-thickness string surfaceScale systemLanguage 
    1              0.000017 syn keyword htmlArg contained tableValues target targetX targetY textLength title to transform type
    1              0.000015 syn keyword htmlArg contained u1 u2 underline-position underline-thickness unicode unicode-range units-per-em 
    1              0.000017 syn keyword htmlArg contained v-alphabetic v-hanging v-ideographic v-mathematical values version vert-adv-y vert-origin-x vert-origin-y viewBox viewTarget 
    1              0.000009 syn keyword htmlArg contained width widths 
    1              0.000022 syn keyword htmlArg contained x x-height x1 x2 xChannelSelector xlink:actuate xlink:actuate xlink:arcrole xlink:href xlink:role xlink:show xlink:title xlink:type xml:base xml:lang xml:space 
    1              0.000009 syn keyword htmlArg contained y y1 y2 yChannelSelector 
    1              0.000055 syn keyword htmlArg contained z zoomAndPan 
    1              0.000384 syn keyword htmlArg contained alignment-baseline baseline-shift clip-path clip-rule clip color-interpolation-filters color-interpolation color-profile color-rendering color cursor direction display dominant-baseline enable-background fill-opacity fill-rule fill filter flood-color flood-opacity font-family font-size-adjust font-size font-stretch font-style font-variant font-weight glyph-orientation-horizontal glyph-orientation-vertical image-rendering kerning letter-spacing lighting-color marker-end marker-mid marker-start mask opacity overflow pointer-events shape-rendering stop-color stop-opacity stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width stroke text-anchor text-decoration text-rendering unicode-bidi visibility word-spacing writing-mode
                            
                            " MathML attributes
                            " https://www.w3.org/TR/MathML3/chapter2.html#interf.toplevel.atts
    1              0.000534 syn keyword htmlArg contained accent accentunder actiontype align alignmentscope altimg altimg-height altimg-valign altimg-width alttext
    1              0.000430 syn keyword htmlArg contained annotation-xml background base baseline bevelled cd cdgroup charalign charspacing close
    1              0.000425 syn keyword htmlArg contained closure color columnalign columnalignment columnlines columnspacing columnspan columnwidth crossout decimalpoint
    1              0.000402 syn keyword htmlArg contained definitionURL denomalign depth display displaystyle edge encoding equalcolumns equalrows fence
    1              0.000389 syn keyword htmlArg contained fontfamily fontsize fontstyle fontweight form frame framespacing groupalign height indentalign
    1              0.000452 syn keyword htmlArg contained indentalignfirst indentalignlast indentshift indentshiftfirst indentshiftlast indenttarget index infixlinebreakstyle integer largeop
    1              0.000466 syn keyword htmlArg contained leftoverhang length linebreak linebreakmultchar linebreakstyle lineleading linethickness location longdivstyle lquote
    1              0.000412 syn keyword htmlArg contained lspace ltr macros math mathbackground mathcolor mathsize mathvariant maxsize maxwidth
    1              0.000283 syn keyword htmlArg contained mediummathspace menclose minlabelspacing minsize mode movablelimits msgroup mslinethickness name nargs
    1              0.000334 syn keyword htmlArg contained newline notation numalign number occurrence open order other overflow position
    1              0.000455 syn keyword htmlArg contained rightoverhang role rowalign rowlines rowspacing rowspan rquote rspace schemaLocation scope
    1              0.000465 syn keyword htmlArg contained scriptlevel scriptminsize scriptsize scriptsizemultiplier selection separator separators shift side stackalign
    1              0.000435 syn keyword htmlArg contained stretchy subscriptshift superscriptshift symmetric thickmathspace thinmathspace type valign verythickmathspace verythinmathspace
    1              0.000197 syn keyword htmlArg contained veryverythickmathspace veryverythinmathspace voffset width xref
                            

SCRIPT  C:\Users\Lenovo\scoop\apps\neovim\0.6.1\share\nvim\runtime\syntax\html.vim
Sourced 1 time
Total time:   0.436049
 Self time:   0.249032

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:             HTML
                            " Previous Maintainer:  Jorge Maldonado Ventura <jorgesumle@freakspot.net>
                            " Previous Maintainer:  Claudio Fleiner <claudio@fleiner.com>
                            " Repository:           https://notabug.org/jorgesumle/vim-html-syntax
                            " Last Change:          2021 Mar 02
                            "			Included patch #7900 to fix comments
                            "			Included patch #7916 to fix a few more things
                            "
                            
                            " Please check :help html.vim for some comments and a description of the options
                            
                            " quit when a syntax file was already loaded
    1              0.000034 if !exists("main_syntax")
    1              0.000013   if exists("b:current_syntax")
                                finish
    1              0.000004   endif
    1              0.000024   let main_syntax = 'html'
    1              0.000003 endif
                            
    1              0.000022 let s:cpo_save = &cpo
    1              0.000054 set cpo&vim
                            
    1              0.000012 syntax spell toplevel
                            
    1              0.000007 syn case ignore
                            
                            " mark illegal characters
    1              0.000048 syn match htmlError "[<>&]"
                            
                            
                            " tags
    1              0.000052 syn region  htmlString   contained start=+"+ end=+"+ contains=htmlSpecialChar,javaScriptExpression,@htmlPreproc
    1              0.000028 syn region  htmlString   contained start=+'+ end=+'+ contains=htmlSpecialChar,javaScriptExpression,@htmlPreproc
    1              0.000038 syn match   htmlValue    contained "=[\t ]*[^'" \t>][^ \t>]*"hs=s+1   contains=javaScriptExpression,@htmlPreproc
    1              0.000035 syn region  htmlEndTag             start=+</+      end=+>+ contains=htmlTagN,htmlTagError
    1              0.000058 syn region  htmlTag                start=+<[^/]+   end=+>+ fold contains=htmlTagN,htmlString,htmlArg,htmlValue,htmlTagError,htmlEvent,htmlCssDefinition,@htmlPreproc,@htmlArgCluster
    1              0.000057 syn match   htmlTagN     contained +<\s*[-a-zA-Z0-9]\++hs=s+1 contains=htmlTagName,htmlSpecialTagName,@htmlTagNameCluster
    1              0.000047 syn match   htmlTagN     contained +</\s*[-a-zA-Z0-9]\++hs=s+2 contains=htmlTagName,htmlSpecialTagName,@htmlTagNameCluster
    1              0.000013 syn match   htmlTagError contained "[^>]<"ms=s+1
                            
                            
                            " tag names
    1              0.000079 syn keyword htmlTagName contained address applet area a base basefont
    1              0.000018 syn keyword htmlTagName contained big blockquote br caption center
    1              0.000020 syn keyword htmlTagName contained cite code dd dfn dir div dl dt font
    1              0.000018 syn keyword htmlTagName contained form hr html img
    1              0.000014 syn keyword htmlTagName contained input isindex kbd li link map menu
    1              0.000015 syn keyword htmlTagName contained meta ol option param pre p samp span
    1              0.000015 syn keyword htmlTagName contained select small sub sup
    1              0.000042 syn keyword htmlTagName contained table td textarea th tr tt ul var xmp
    1              0.000071 syn match htmlTagName contained "\<\(b\|i\|u\|h[1-6]\|em\|strong\|head\|body\|title\)\>"
                            
                            " new html 4.0 tags
    1              0.000015 syn keyword htmlTagName contained abbr acronym bdo button col label
    1              0.000013 syn keyword htmlTagName contained colgroup fieldset iframe ins legend
    1              0.000014 syn keyword htmlTagName contained object optgroup q s tbody tfoot thead
                            
                            " new html 5 tags
    1              0.000013 syn keyword htmlTagName contained article aside audio bdi canvas data
    1              0.000014 syn keyword htmlTagName contained datalist details dialog embed figcaption
    1              0.000013 syn keyword htmlTagName contained figure footer header hgroup keygen main
    1              0.000013 syn keyword htmlTagName contained mark menuitem meter nav output picture
    1              0.000013 syn keyword htmlTagName contained progress rb rp rt rtc ruby section
    1              0.000014 syn keyword htmlTagName contained slot source summary template time track
    1              0.000007 syn keyword htmlTagName contained video wbr
                            
                            " legal arg names
    1              0.000008 syn keyword htmlArg contained action
    1              0.000013 syn keyword htmlArg contained align alink alt archive background bgcolor
    1              0.000012 syn keyword htmlArg contained border bordercolor cellpadding
    1              0.000017 syn keyword htmlArg contained cellspacing checked class clear code codebase color
    1              0.000015 syn keyword htmlArg contained cols colspan content coords enctype face
    1              0.000022 syn keyword htmlArg contained gutter height hspace id
    1              0.000011 syn keyword htmlArg contained link lowsrc marginheight
    1              0.000013 syn keyword htmlArg contained marginwidth maxlength method name prompt
    1              0.000015 syn keyword htmlArg contained rel rev rows rowspan scrolling selected shape
    1              0.000014 syn keyword htmlArg contained size src start target text type url
    1              0.000014 syn keyword htmlArg contained usemap ismap valign value vlink vspace width wrap
    1              0.000039 syn match   htmlArg contained "\<\(http-equiv\|href\|title\)="me=e-1
                            
                            " aria attributes
    1              0.000478 exe 'syn match htmlArg contained "\<aria-\%(' . join([
                                \ 'activedescendant', 'atomic', 'autocomplete', 'busy', 'checked', 'colcount',
                                \ 'colindex', 'colspan', 'controls', 'current', 'describedby', 'details',
                                \ 'disabled', 'dropeffect', 'errormessage', 'expanded', 'flowto', 'grabbed',
                                \ 'haspopup', 'hidden', 'invalid', 'keyshortcuts', 'label', 'labelledby', 'level',
                                \ 'live', 'modal', 'multiline', 'multiselectable', 'orientation', 'owns',
                                \ 'placeholder', 'posinset', 'pressed', 'readonly', 'relevant', 'required',
                                \ 'roledescription', 'rowcount', 'rowindex', 'rowspan', 'selected', 'setsize',
                                \ 'sort', 'valuemax', 'valuemin', 'valuenow', 'valuetext'
                                \ ], '\|') . '\)\>"'
    1              0.000010 syn keyword htmlArg contained role
                            
                            " Netscape extensions
    1              0.000014 syn keyword htmlTagName contained frame noframes frameset nobr blink
    1              0.000056 syn keyword htmlTagName contained layer ilayer nolayer spacer
    1              0.000075 syn keyword htmlArg     contained frameborder noresize pagex pagey above below
    1              0.000069 syn keyword htmlArg     contained left top visibility clip id noshade
    1              0.000021 syn match   htmlArg     contained "\<z-index\>"
                            
                            " Microsoft extensions
    1              0.000018 syn keyword htmlTagName contained marquee
                            
                            " html 4.0 arg names
    1              0.000022 syn match   htmlArg contained "\<\(accept-charset\|label\)\>"
    1              0.000078 syn keyword htmlArg contained abbr accept accesskey axis char charoff charset
    1              0.000057 syn keyword htmlArg contained cite classid codetype compact data datetime
    1              0.000059 syn keyword htmlArg contained declare defer dir disabled for frame
    1              0.000063 syn keyword htmlArg contained headers hreflang lang language longdesc
    1              0.000015 syn keyword htmlArg contained multiple nohref nowrap object profile readonly
    1              0.000013 syn keyword htmlArg contained rules scheme scope span standby style
    1              0.000011 syn keyword htmlArg contained summary tabindex valuetype version
                            
                            " html 5 arg names
    1              0.000013 syn keyword htmlArg contained allowfullscreen async autocomplete autofocus
    1              0.000014 syn keyword htmlArg contained autoplay challenge contenteditable contextmenu
    1              0.000014 syn keyword htmlArg contained controls crossorigin default dirname download
    1              0.000014 syn keyword htmlArg contained draggable dropzone form formaction formenctype
    1              0.000012 syn keyword htmlArg contained formmethod formnovalidate formtarget hidden
    1              0.000018 syn keyword htmlArg contained high icon inputmode keytype kind list loop low
    1              0.000015 syn keyword htmlArg contained max min minlength muted nonce novalidate open
    1              0.000016 syn keyword htmlArg contained optimum pattern placeholder poster preload
    1              0.000014 syn keyword htmlArg contained radiogroup required reversed sandbox spellcheck
    1              0.000018 syn keyword htmlArg contained sizes srcset srcdoc srclang step title translate
    1              0.000007 syn keyword htmlArg contained typemustmatch
                            
                            " special characters
    1              0.000040 syn match htmlSpecialChar "&#\=[0-9A-Za-z]\{1,8};"
                            
                            " Comments (the real ones or the old netscape ones)
    1              0.000019 if exists("html_wrong_comments")
                              syn region htmlComment        start=+<!--+    end=+--\s*>+    contains=@Spell
    1              0.000007 else
                              " The HTML 5.2 syntax 8.2.4.41: bogus comment is parser error; browser skips until next &gt
    1              0.000031   syn region htmlComment        start=+<!+      end=+>+         contains=htmlCommentError keepend
                              " Idem 8.2.4.42,51: Comment starts with <!-- and ends with -->
                              " Idem 8.2.4.43,44: Except <!--> and <!---> are parser errors
                              " Idem 8.2.4.52: dash-dash-bang (--!>) is error ignored by parser, also closes comment
    1              0.000052   syn region htmlComment matchgroup=htmlComment start=+<!--\%(-\?>\)\@!+        end=+--!\?>+    contains=htmlCommentNested,@htmlPreProc,@Spell keepend
                              " Idem 8.2.4.49: nested comment is parser error, except <!--> is all right
    1              0.000029   syn match htmlCommentNested contained "<!-->\@!"
    1              0.000012   syn match htmlCommentError  contained "[^><!]"
    1              0.000005 endif
    1              0.000025 syn region htmlComment  start=+<!DOCTYPE+       end=+>+ keepend
                            
                            " server-parsed commands
    1              0.000038 syn region htmlPreProc start=+<!--#+ end=+-->+ contains=htmlPreStmt,htmlPreError,htmlPreAttr
    1              0.000067 syn match htmlPreStmt contained "<!--#\(config\|echo\|exec\|fsize\|flastmod\|include\|printenv\|set\|if\|elif\|else\|endif\|geoguide\)\>"
    1              0.000017 syn match htmlPreError contained "<!--#\S*"ms=s+4
    1              0.000029 syn match htmlPreAttr contained "\w\+=[^"]\S\+" contains=htmlPreProcAttrError,htmlPreProcAttrName
    1              0.000073 syn region htmlPreAttr contained start=+\w\+="+ skip=+\\\\\|\\"+ end=+"+ contains=htmlPreProcAttrName keepend
    1              0.000015 syn match htmlPreProcAttrError contained "\w\+="he=e-1
    1              0.000036 syn match htmlPreProcAttrName contained "\(expr\|errmsg\|sizefmt\|timefmt\|var\|cgi\|cmd\|file\|virtual\|value\)="he=e-1
                            
    1              0.000017 if !exists("html_no_rendering")
                              " rendering
    1              0.000053   syn cluster htmlTop contains=@Spell,htmlTag,htmlEndTag,htmlSpecialChar,htmlPreProc,htmlComment,htmlLink,javaScript,@htmlPreproc
                            
    1              0.000031   syn region htmlStrike start="<del\>" end="</del\_s*>"me=s-1 contains=@htmlTop
    1              0.000043   syn region htmlStrike start="<strike\>" end="</strike\_s*>"me=s-1 contains=@htmlTop
                            
    1              0.000038   syn region htmlBold start="<b\>" end="</b\_s*>"me=s-1 contains=@htmlTop,htmlBoldUnderline,htmlBoldItalic
    1              0.000033   syn region htmlBold start="<strong\>" end="</strong\_s*>"me=s-1 contains=@htmlTop,htmlBoldUnderline,htmlBoldItalic
    1              0.000031   syn region htmlBoldUnderline contained start="<u\>" end="</u\_s*>"me=s-1 contains=@htmlTop,htmlBoldUnderlineItalic
    1              0.000028   syn region htmlBoldItalic contained start="<i\>" end="</i\_s*>"me=s-1 contains=@htmlTop,htmlBoldItalicUnderline
    1              0.000028   syn region htmlBoldItalic contained start="<em\>" end="</em\_s*>"me=s-1 contains=@htmlTop,htmlBoldItalicUnderline
    1              0.000023   syn region htmlBoldUnderlineItalic contained start="<i\>" end="</i\_s*>"me=s-1 contains=@htmlTop
    1              0.000023   syn region htmlBoldUnderlineItalic contained start="<em\>" end="</em\_s*>"me=s-1 contains=@htmlTop
    1              0.000043   syn region htmlBoldItalicUnderline contained start="<u\>" end="</u\_s*>"me=s-1 contains=@htmlTop,htmlBoldUnderlineItalic
                            
    1              0.000034   syn region htmlUnderline start="<u\>" end="</u\_s*>"me=s-1 contains=@htmlTop,htmlUnderlineBold,htmlUnderlineItalic
    1              0.000031   syn region htmlUnderlineBold contained start="<b\>" end="</b\_s*>"me=s-1 contains=@htmlTop,htmlUnderlineBoldItalic
    1              0.000032   syn region htmlUnderlineBold contained start="<strong\>" end="</strong\_s*>"me=s-1 contains=@htmlTop,htmlUnderlineBoldItalic
    1              0.000029   syn region htmlUnderlineItalic contained start="<i\>" end="</i\_s*>"me=s-1 contains=@htmlTop,htmlUnderlineItalicBold
    1              0.000027   syn region htmlUnderlineItalic contained start="<em\>" end="</em\_s*>"me=s-1 contains=@htmlTop,htmlUnderlineItalicBold
    1              0.000022   syn region htmlUnderlineItalicBold contained start="<b\>" end="</b\_s*>"me=s-1 contains=@htmlTop
    1              0.000026   syn region htmlUnderlineItalicBold contained start="<strong\>" end="</strong\_s*>"me=s-1 contains=@htmlTop
    1              0.000022   syn region htmlUnderlineBoldItalic contained start="<i\>" end="</i\_s*>"me=s-1 contains=@htmlTop
    1              0.000100   syn region htmlUnderlineBoldItalic contained start="<em\>" end="</em\_s*>"me=s-1 contains=@htmlTop
                            
    1              0.000034   syn region htmlItalic start="<i\>" end="</i\_s*>"me=s-1 contains=@htmlTop,htmlItalicBold,htmlItalicUnderline
    1              0.000023   syn region htmlItalic start="<em\>" end="</em\_s*>"me=s-1 contains=@htmlTop
    1              0.000027   syn region htmlItalicBold contained start="<b\>" end="</b\_s*>"me=s-1 contains=@htmlTop,htmlItalicBoldUnderline
    1              0.000030   syn region htmlItalicBold contained start="<strong\>" end="</strong\_s*>"me=s-1 contains=@htmlTop,htmlItalicBoldUnderline
    1              0.000023   syn region htmlItalicBoldUnderline contained start="<u\>" end="</u\_s*>"me=s-1 contains=@htmlTop
    1              0.000025   syn region htmlItalicUnderline contained start="<u\>" end="</u\_s*>"me=s-1 contains=@htmlTop,htmlItalicUnderlineBold
    1              0.000021   syn region htmlItalicUnderlineBold contained start="<b\>" end="</b\_s*>"me=s-1 contains=@htmlTop
    1              0.000045   syn region htmlItalicUnderlineBold contained start="<strong\>" end="</strong\_s*>"me=s-1 contains=@htmlTop
                            
    1              0.000018   syn match htmlLeadingSpace "^\s\+" contained
    1              0.000063   syn region htmlLink start="<a\>\_[^>]*\<href\>" end="</a\_s*>"me=s-1 contains=@Spell,htmlTag,htmlEndTag,htmlSpecialChar,htmlPreProc,htmlComment,htmlLeadingSpace,javaScript,@htmlPreproc
    1              0.000024   syn region htmlH1 start="<h1\>" end="</h1\_s*>"me=s-1 contains=@htmlTop
    1              0.000021   syn region htmlH2 start="<h2\>" end="</h2\_s*>"me=s-1 contains=@htmlTop
    1              0.000021   syn region htmlH3 start="<h3\>" end="</h3\_s*>"me=s-1 contains=@htmlTop
    1              0.000020   syn region htmlH4 start="<h4\>" end="</h4\_s*>"me=s-1 contains=@htmlTop
    1              0.000019   syn region htmlH5 start="<h5\>" end="</h5\_s*>"me=s-1 contains=@htmlTop
    1              0.000074   syn region htmlH6 start="<h6\>" end="</h6\_s*>"me=s-1 contains=@htmlTop
    1              0.000084   syn region htmlHead start="<head\>" end="</head\_s*>"me=s-1 end="<body\>"me=s-1 end="<h[1-6]\>"me=s-1 contains=htmlTag,htmlEndTag,htmlSpecialChar,htmlPreProc,htmlComment,htmlLink,htmlTitle,javaScript,cssStyle,@htmlPreproc
    1              0.000042   syn region htmlTitle start="<title\>" end="</title\_s*>"me=s-1 contains=htmlTag,htmlEndTag,htmlSpecialChar,htmlPreProc,htmlComment,javaScript,@htmlPreproc
    1              0.000004 endif
                            
    1              0.000012 syn keyword htmlTagName         contained noscript
    1              0.000023 syn keyword htmlSpecialTagName  contained script style
    1              0.000021 if main_syntax != 'java' || exists("java_javascript")
                              " JAVA SCRIPT
    1   0.202135   0.089456   syn include @htmlJavaScript syntax/javascript.vim
    1              0.000018   unlet b:current_syntax
    1              0.000069   syn region  javaScript start=+<script\_[^>]*>+ keepend end=+</script\_[^>]*>+me=s-1 contains=@htmlJavaScript,htmlCssStyleComment,htmlScriptTag,@htmlPreproc
    1              0.000040   syn region  htmlScriptTag     contained start=+<script+ end=+>+ fold contains=htmlTagN,htmlString,htmlArg,htmlValue,htmlTagError,htmlEvent
    1              0.000007   hi def link htmlScriptTag htmlTag
                            
                              " html events (i.e. arguments that include javascript commands)
    1              0.000019   if exists("html_extended_events")
                                syn region htmlEvent        contained start=+\<on\a\+\s*=[\t ]*'+ end=+'+ contains=htmlEventSQ
                                syn region htmlEvent        contained start=+\<on\a\+\s*=[\t ]*"+ end=+"+ contains=htmlEventDQ
    1              0.000006   else
    1              0.000028     syn region htmlEvent        contained start=+\<on\a\+\s*=[\t ]*'+ end=+'+ keepend contains=htmlEventSQ
    1              0.000029     syn region htmlEvent        contained start=+\<on\a\+\s*=[\t ]*"+ end=+"+ keepend contains=htmlEventDQ
    1              0.000005   endif
    1              0.000057   syn region htmlEventSQ        contained start=+'+ms=s+1 end=+'+me=s-1 contains=@htmlJavaScript
    1              0.000020   syn region htmlEventDQ        contained start=+"+ms=s+1 end=+"+me=s-1 contains=@htmlJavaScript
    1              0.000007   hi def link htmlEventSQ htmlEvent
    1              0.000004   hi def link htmlEventDQ htmlEvent
                            
                              " a javascript expression is used as an arg value
    1              0.000027   syn region  javaScriptExpression contained start=+&{+ keepend end=+};+ contains=@htmlJavaScript,@htmlPreproc
    1              0.000003 endif
                            
    1              0.000017 if main_syntax != 'java' || exists("java_vb")
                              " VB SCRIPT
    1   0.081335   0.067344   syn include @htmlVbScript syntax/vb.vim
    1              0.000023   unlet b:current_syntax
    1              0.000116   syn region  javaScript start=+<script \_[^>]*language *=\_[^>]*vbscript\_[^>]*>+ keepend end=+</script\_[^>]*>+me=s-1 contains=@htmlVbScript,htmlCssStyleComment,htmlScriptTag,@htmlPreproc
    1              0.000005 endif
                            
    1              0.000028 syn cluster htmlJavaScript      add=@htmlPreproc
                            
    1              0.000022 if main_syntax != 'java' || exists("java_css")
                              " embedded style sheets
    1              0.000014   syn keyword htmlArg           contained media
    1   0.136795   0.076449   syn include @htmlCss syntax/css.vim
    1              0.000021   unlet b:current_syntax
    1              0.000077   syn region cssStyle start=+<style+ keepend end=+</style>+ contains=@htmlCss,htmlTag,htmlEndTag,htmlCssStyleComment,@htmlPreproc
    1              0.000032   syn match htmlCssStyleComment contained "\(<!--\|-->\)"
    1              0.008616   syn region htmlCssDefinition matchgroup=htmlArg start='style="' keepend matchgroup=htmlString end='"' contains=css.*Attr,css.*Prop,cssComment,cssLength,cssColor,cssURL,cssImportant,cssError,cssString,@htmlPreproc
    1              0.000027   hi def link htmlStyleArg htmlString
    1              0.000005 endif
                            
    1              0.000021 if main_syntax == "html"
                              " synchronizing (does not always work if a comment includes legal
                              " html tags, but doing it right would mean to always start
                              " at the first line, which is too slow)
    1              0.000034   syn sync match htmlHighlight groupthere NONE "<[/a-zA-Z]"
    1              0.000024   syn sync match htmlHighlight groupthere javaScript "<script"
    1              0.000021   syn sync match htmlHighlightSkip "^.*['\"].*$"
    1              0.000010   syn sync minlines=10
    1              0.000003 endif
                            
                            " The default highlighting.
    1              0.000010 hi def link htmlTag                     Function
    1              0.000007 hi def link htmlEndTag                  Identifier
    1              0.000007 hi def link htmlArg                     Type
    1              0.000007 hi def link htmlTagName                 htmlStatement
    1              0.000008 hi def link htmlSpecialTagName          Exception
    1              0.000007 hi def link htmlValue                   String
    1              0.000006 hi def link htmlSpecialChar             Special
                            
    1              0.000019 if !exists("html_no_rendering")
    1              0.000008   hi def link htmlH1                      Title
    1              0.000007   hi def link htmlH2                      htmlH1
    1              0.000006   hi def link htmlH3                      htmlH2
    1              0.000005   hi def link htmlH4                      htmlH3
    1              0.000005   hi def link htmlH5                      htmlH4
    1              0.000006   hi def link htmlH6                      htmlH5
    1              0.000007   hi def link htmlHead                    PreProc
    1              0.000072   hi def link htmlTitle                   Title
    1              0.000009   hi def link htmlBoldItalicUnderline     htmlBoldUnderlineItalic
    1              0.000008   hi def link htmlUnderlineBold           htmlBoldUnderline
    1              0.000007   hi def link htmlUnderlineItalicBold     htmlBoldUnderlineItalic
    1              0.000007   hi def link htmlUnderlineBoldItalic     htmlBoldUnderlineItalic
    1              0.000008   hi def link htmlItalicUnderline         htmlUnderlineItalic
    1              0.000008   hi def link htmlItalicBold              htmlBoldItalic
    1              0.000018   hi def link htmlItalicBoldUnderline     htmlBoldUnderlineItalic
    1              0.000006   hi def link htmlItalicUnderlineBold     htmlBoldUnderlineItalic
    1              0.000007   hi def link htmlLink                    Underlined
    1              0.000007   hi def link htmlLeadingSpace            None
    1              0.000016   if !exists("html_my_rendering")
    1              0.000042     hi def htmlBold                term=bold cterm=bold gui=bold
    1              0.000075     hi def htmlBoldUnderline       term=bold,underline cterm=bold,underline gui=bold,underline
    1              0.000052     hi def htmlBoldItalic          term=bold,italic cterm=bold,italic gui=bold,italic
    1              0.000086     hi def htmlBoldUnderlineItalic term=bold,italic,underline cterm=bold,italic,underline gui=bold,italic,underline
    1              0.000043     hi def htmlUnderline           term=underline cterm=underline gui=underline
    1              0.000081     hi def htmlUnderlineItalic     term=italic,underline cterm=italic,underline gui=italic,underline
    1              0.000008     hi def htmlItalic              term=italic cterm=italic gui=italic
    1              0.000073     if v:version > 800 || v:version == 800 && has("patch1038")
    1              0.000036         hi def htmlStrike              term=strikethrough cterm=strikethrough gui=strikethrough
                                else
                                    hi def htmlStrike              term=underline cterm=underline gui=underline
    1              0.000003     endif
    1              0.000003   endif
    1              0.000002 endif
                            
    1              0.000007 hi def link htmlPreStmt            PreProc
    1              0.000007 hi def link htmlPreError           Error
    1              0.000006 hi def link htmlPreProc            PreProc
    1              0.000006 hi def link htmlPreAttr            String
    1              0.000006 hi def link htmlPreProcAttrName    PreProc
    1              0.000006 hi def link htmlPreProcAttrError   Error
    1              0.000006 hi def link htmlString             String
    1              0.000007 hi def link htmlStatement          Statement
    1              0.000006 hi def link htmlComment            Comment
    1              0.000006 hi def link htmlCommentNested      htmlError
    1              0.000006 hi def link htmlCommentError       htmlError
    1              0.000006 hi def link htmlTagError           htmlError
    1              0.000007 hi def link htmlEvent              javaScript
    1              0.000005 hi def link htmlError              Error
                            
    1              0.000006 hi def link javaScript             Special
    1              0.000007 hi def link javaScriptExpression   javaScript
    1              0.000006 hi def link htmlCssStyleComment    Comment
    1              0.000005 hi def link htmlCssDefinition      Special
                            
    1              0.000013 let b:current_syntax = "html"
                            
    1              0.000010 if main_syntax == 'html'
    1              0.000020   unlet main_syntax
    1              0.000003 endif
                            
    1              0.000038 let &cpo = s:cpo_save
    1              0.000008 unlet s:cpo_save
                            " vim: ts=8

SCRIPT  C:\Users\Lenovo\AppData\Local\nvim-data\plugged\vim-polyglot\syntax\javascript.vim
Sourced 1 time
Total time:   0.040953
 Self time:   0.038299

count  total (s)   self (s)
    1   0.000582   0.000393 if polyglot#init#is_disabled(expand('<sfile>:p'), 'javascript', 'syntax/javascript.vim')
                              finish
    1              0.000004 endif
                            
                            " Vim syntax file
                            " Language:     JavaScript
                            " Maintainer:   vim-javascript community
                            " URL:          https://github.com/pangloss/vim-javascript
                            
    1              0.000014 if !exists("main_syntax")
                              if version < 600
                                syntax clear
                              elseif exists("b:current_syntax")
                                finish
                              endif
                              let main_syntax = 'javascript'
    1              0.000002 endif
                            
                            " Dollar sign is permitted anywhere in an identifier
    1              0.000021 if (v:version > 704 || v:version == 704 && has('patch1142')) && main_syntax == 'javascript'
                              syntax iskeyword @,48-57,_,192-255,$
    1              0.000003 else
    1              0.000136   setlocal iskeyword+=$
    1              0.000003 endif
                            
    1              0.000011 syntax sync fromstart
                            " TODO: Figure out what type of casing I need
                            " syntax case ignore
    1              0.000008 syntax case match
                            
    1              0.000034 syntax match   jsNoise          /[:,;]/
    1              0.000038 syntax match   jsDot            /\./ skipwhite skipempty nextgroup=jsObjectProp,jsFuncCall,jsPrototype,jsTaggedTemplate
    1              0.000017 syntax match   jsObjectProp     contained /\<\K\k*/
    1              0.000020 syntax match   jsFuncCall       /\<\K\k*\ze\s*(/
    1              0.000015 syntax match   jsParensError    /[)}\]]/
                            
                            " Program Keywords
    1              0.000242 syntax keyword jsStorageClass   const var let skipwhite skipempty nextgroup=jsDestructuringBlock,jsDestructuringArray,jsVariableDef
    1              0.000025 syntax match   jsVariableDef    contained /\<\K\k*/ skipwhite skipempty nextgroup=jsFlowDefinition
    1              0.000348 syntax keyword jsOperatorKeyword delete instanceof typeof void new in of skipwhite skipempty nextgroup=@jsExpression
    1              0.000033 syntax match   jsOperator       "[-!|&+<>=%/*~^]" skipwhite skipempty nextgroup=@jsExpression
    1              0.000019 syntax match   jsOperator       /::/ skipwhite skipempty nextgroup=@jsExpression
    1              0.000011 syntax keyword jsBooleanTrue    true
    1              0.000010 syntax keyword jsBooleanFalse   false
                            
                            " Modules
    1              0.000086 syntax keyword jsImport                       import skipwhite skipempty nextgroup=jsModuleAsterisk,jsModuleKeyword,jsModuleGroup,jsFlowImportType
    1              0.000090 syntax keyword jsExport                       export skipwhite skipempty nextgroup=@jsAll,jsModuleGroup,jsExportDefault,jsModuleAsterisk,jsModuleKeyword,jsFlowTypeStatement
    1              0.000029 syntax match   jsModuleKeyword      contained /\<\K\k*/ skipwhite skipempty nextgroup=jsModuleAs,jsFrom,jsModuleComma
    1              0.000063 syntax keyword jsExportDefault      contained default skipwhite skipempty nextgroup=@jsExpression
    1              0.000020 syntax keyword jsExportDefaultGroup contained default skipwhite skipempty nextgroup=jsModuleAs,jsFrom,jsModuleComma
    1              0.000022 syntax match   jsModuleAsterisk     contained /\*/ skipwhite skipempty nextgroup=jsModuleKeyword,jsModuleAs,jsFrom
    1              0.000063 syntax keyword jsModuleAs           contained as skipwhite skipempty nextgroup=jsModuleKeyword,jsExportDefaultGroup
    1              0.000016 syntax keyword jsFrom               contained from skipwhite skipempty nextgroup=jsString
    1              0.000024 syntax match   jsModuleComma        contained /,/ skipwhite skipempty nextgroup=jsModuleKeyword,jsModuleAsterisk,jsModuleGroup,jsFlowTypeKeyword
                            
                            " Strings, Templates, Numbers
    1              0.000062 syntax region  jsString           start=+\z(["']\)+  skip=+\\\%(\z1\|$\)+  end=+\z1+ end=+$+  contains=jsSpecial extend
    1              0.000038 syntax region  jsTemplateString   start=+`+  skip=+\\`+  end=+`+     contains=jsTemplateExpression,jsSpecial extend
    1              0.000024 syntax match   jsTaggedTemplate   /\<\K\k*\ze`/ nextgroup=jsTemplateString
    1              0.000044 syntax match   jsNumber           /\c\<\%(\d\+\%(e[+-]\=\d\+\)\=\|0b[01]\+\|0o\o\+\|0x\%(\x\|_\)\+\)n\=\>/
    1              0.000061 syntax keyword jsNumber           Infinity
    1              0.000052 syntax match   jsFloat            /\c\<\%(\d\+\.\d\+\|\d\+\.\|\.\d\+\)\%(e[+-]\=\d\+\)\=\>/
                            
                            " Regular Expressions
    1              0.000074 syntax match   jsSpecial            contained "\v\\%(x\x\x|u%(\x{4}|\{\x{4,5}})|c\u|.)"
    1              0.000079 syntax region  jsTemplateExpression contained matchgroup=jsTemplateBraces start=+${+ end=+}+ contains=@jsExpression keepend
    1              0.000032 syntax region  jsRegexpCharClass    contained start=+\[+ skip=+\\.+ end=+\]+ contains=jsSpecial extend
    1              0.000019 syntax match   jsRegexpBoundary     contained "\v\c[$^]|\\b"
    1              0.000015 syntax match   jsRegexpBackRef      contained "\v\\[1-9]\d*"
    1              0.000030 syntax match   jsRegexpQuantifier   contained "\v[^\\]%([?*+]|\{\d+%(,\d*)?})\??"lc=1
    1              0.000127 syntax match   jsRegexpOr           contained "|"
    1              0.000024 syntax match   jsRegexpMod          contained "\v\(\?[:=!>]"lc=1
    1              0.000069 syntax region  jsRegexpGroup        contained start="[^\\]("lc=1 skip="\\.\|\[\(\\.\|[^]]\+\)\]" end=")" contains=jsRegexpCharClass,@jsRegexpSpecial keepend
    1              0.000111 syntax region  jsRegexpString   start=+\%(\%(\<return\|\<typeof\|\_[^)\]'"[:blank:][:alnum:]_$]\)\s*\)\@<=/\ze[^*/]+ skip=+\\.\|\[[^]]\{1,}\]+ end=+/[gimyus]\{,6}+ contains=jsRegexpCharClass,jsRegexpGroup,@jsRegexpSpecial oneline keepend extend
    1              0.000032 syntax cluster jsRegexpSpecial    contains=jsSpecial,jsRegexpBoundary,jsRegexpBackRef,jsRegexpQuantifier,jsRegexpOr,jsRegexpMod
                            
                            " Objects
    1              0.000026 syntax match   jsObjectShorthandProp contained /\<\k*\ze\s*/ skipwhite skipempty nextgroup=jsObjectSeparator
    1              0.000496 syntax match   jsObjectKey         contained /\<\k*\ze\s*:/ contains=jsFunctionKey skipwhite skipempty nextgroup=jsObjectValue
    1              0.000062 syntax region  jsObjectKeyString   contained start=+\z(["']\)+  skip=+\\\%(\z1\|$\)+  end=+\z1\|$+  contains=jsSpecial skipwhite skipempty nextgroup=jsObjectValue
    1              0.000039 syntax region  jsObjectKeyComputed contained matchgroup=jsBrackets start=/\[/ end=/]/ contains=@jsExpression skipwhite skipempty nextgroup=jsObjectValue,jsFuncArgs extend
    1              0.000011 syntax match   jsObjectSeparator   contained /,/
    1              0.000029 syntax region  jsObjectValue       contained matchgroup=jsObjectColon start=/:/ end=/[,}]\@=/ contains=@jsExpression extend
    1              0.000022 syntax match   jsObjectFuncName    contained /\<\K\k*\ze\_s*(/ skipwhite skipempty nextgroup=jsFuncArgs
    1              0.000021 syntax match   jsFunctionKey       contained /\<\K\k*\ze\s*:\s*function\>/
    1              0.000039 syntax match   jsObjectMethodType  contained /\<[gs]et\ze\s\+\K\k*/ skipwhite skipempty nextgroup=jsObjectFuncName
    1              0.000042 syntax region  jsObjectStringKey   contained start=+\z(["']\)+  skip=+\\\%(\z1\|$\)+  end=+\z1\|$+  contains=jsSpecial extend skipwhite skipempty nextgroup=jsFuncArgs,jsObjectValue
                            
    1              0.000114 exe 'syntax keyword jsNull      null             '.(exists('g:javascript_conceal_null')      ? 'conceal cchar='.g:javascript_conceal_null       : '')
    1              0.000049 exe 'syntax keyword jsReturn    return contained '.(exists('g:javascript_conceal_return')    ? 'conceal cchar='.g:javascript_conceal_return     : '').' skipwhite nextgroup=@jsExpression'
    1              0.000037 exe 'syntax keyword jsUndefined undefined        '.(exists('g:javascript_conceal_undefined') ? 'conceal cchar='.g:javascript_conceal_undefined  : '')
    1              0.000034 exe 'syntax keyword jsNan       NaN              '.(exists('g:javascript_conceal_NaN')       ? 'conceal cchar='.g:javascript_conceal_NaN        : '')
    1              0.000037 exe 'syntax keyword jsPrototype prototype        '.(exists('g:javascript_conceal_prototype') ? 'conceal cchar='.g:javascript_conceal_prototype  : '')
    1              0.000031 exe 'syntax keyword jsThis      this             '.(exists('g:javascript_conceal_this')      ? 'conceal cchar='.g:javascript_conceal_this       : '')
    1              0.000028 exe 'syntax keyword jsSuper     super  contained '.(exists('g:javascript_conceal_super')     ? 'conceal cchar='.g:javascript_conceal_super      : '')
                            
                            " Statement Keywords
    1              0.000031 syntax match   jsBlockLabel              /\<\K\k*\s*::\@!/    contains=jsNoise skipwhite skipempty nextgroup=jsBlock
    1              0.000019 syntax match   jsBlockLabelKey contained /\<\K\k*\ze\s*\_[;]/
    1              0.000013 syntax keyword jsStatement     contained with yield debugger
    1              0.000015 syntax keyword jsStatement     contained break continue skipwhite skipempty nextgroup=jsBlockLabelKey
    1              0.000018 syntax keyword jsConditional            if              skipwhite skipempty nextgroup=jsParenIfElse
    1              0.000021 syntax keyword jsConditional            else            skipwhite skipempty nextgroup=jsCommentIfElse,jsIfElseBlock
    1              0.000016 syntax keyword jsConditional            switch          skipwhite skipempty nextgroup=jsParenSwitch
    1              0.000022 syntax keyword jsRepeat                 while for       skipwhite skipempty nextgroup=jsParenRepeat,jsForAwait
    1              0.000020 syntax keyword jsDo                     do              skipwhite skipempty nextgroup=jsRepeatBlock
    1              0.000052 syntax region  jsSwitchCase   contained matchgroup=jsLabel start=/\<\%(case\|default\)\>/ end=/:\@=/ contains=@jsExpression,jsLabel skipwhite skipempty nextgroup=jsSwitchColon keepend
    1              0.000089 syntax keyword jsTry                    try             skipwhite skipempty nextgroup=jsTryCatchBlock
    1              0.000018 syntax keyword jsFinally      contained finally         skipwhite skipempty nextgroup=jsFinallyBlock
    1              0.000017 syntax keyword jsCatch        contained catch           skipwhite skipempty nextgroup=jsParenCatch,jsTryCatchBlock
    1              0.000011 syntax keyword jsException              throw
    1              0.000013 syntax keyword jsAsyncKeyword           async await
    1              0.000026 syntax match   jsSwitchColon   contained /::\@!/        skipwhite skipempty nextgroup=jsSwitchBlock
                            
                            " Keywords
    1              0.000075 syntax keyword jsGlobalObjects     ArrayBuffer Array BigInt BigInt64Array BigUint64Array Float32Array Float64Array Int16Array Int32Array Int8Array Uint16Array Uint32Array Uint8Array Uint8ClampedArray Boolean Buffer Collator DataView Date DateTimeFormat Function Intl Iterator JSON Map Set WeakMap WeakRef WeakSet Math Number NumberFormat Object ParallelArray Promise Proxy Reflect RegExp String Symbol Uint8ClampedArray WebAssembly console document fetch window
    1              0.000018 syntax keyword jsGlobalNodeObjects  module exports global process __dirname __filename
    1              0.000026 syntax match   jsGlobalNodeObjects  /\<require\>/ containedin=jsFuncCall
    1              0.000023 syntax keyword jsExceptions         Error EvalError InternalError RangeError ReferenceError StopIteration SyntaxError TypeError URIError
    1              0.000023 syntax keyword jsBuiltins           decodeURI decodeURIComponent encodeURI encodeURIComponent eval isFinite isNaN parseFloat parseInt uneval
                            " DISCUSS: How imporant is this, really? Perhaps it should be linked to an error because I assume the keywords are reserved?
    1              0.000034 syntax keyword jsFutureKeys         abstract enum int short boolean interface byte long char final native synchronized float package throws goto private transient implements protected volatile double public
                            
                            " DISCUSS: Should we really be matching stuff like this?
                            " DOM2 Objects
    1              0.000033 syntax keyword jsGlobalObjects  DOMImplementation DocumentFragment Document Node NodeList NamedNodeMap CharacterData Attr Element Text Comment CDATASection DocumentType Notation Entity EntityReference ProcessingInstruction
    1              0.000010 syntax keyword jsExceptions     DOMException
                            
                            " DISCUSS: Should we really be matching stuff like this?
                            " DOM2 CONSTANT
    1              0.000037 syntax keyword jsDomErrNo       INDEX_SIZE_ERR DOMSTRING_SIZE_ERR HIERARCHY_REQUEST_ERR WRONG_DOCUMENT_ERR INVALID_CHARACTER_ERR NO_DATA_ALLOWED_ERR NO_MODIFICATION_ALLOWED_ERR NOT_FOUND_ERR NOT_SUPPORTED_ERR INUSE_ATTRIBUTE_ERR INVALID_STATE_ERR SYNTAX_ERR INVALID_MODIFICATION_ERR NAMESPACE_ERR INVALID_ACCESS_ERR
    1              0.000028 syntax keyword jsDomNodeConsts  ELEMENT_NODE ATTRIBUTE_NODE TEXT_NODE CDATA_SECTION_NODE ENTITY_REFERENCE_NODE ENTITY_NODE PROCESSING_INSTRUCTION_NODE COMMENT_NODE DOCUMENT_NODE DOCUMENT_TYPE_NODE DOCUMENT_FRAGMENT_NODE NOTATION_NODE
                            
                            " DISCUSS: Should we really be special matching on these props?
                            " HTML events and internal variables
    1              0.000030 syntax keyword jsHtmlEvents     onblur onclick oncontextmenu ondblclick onfocus onkeydown onkeypress onkeyup onmousedown onmousemove onmouseout onmouseover onmouseup onresize
                            
                            " Code blocks
    1              0.000047 syntax region  jsBracket                      matchgroup=jsBrackets            start=/\[/ end=/\]/ contains=@jsExpression,jsSpreadExpression extend fold
    1              0.000037 syntax region  jsParen                        matchgroup=jsParens              start=/(/  end=/)/  contains=@jsExpression extend fold nextgroup=jsFlowDefinition
    1              0.000029 syntax region  jsParenDecorator     contained matchgroup=jsParensDecorator     start=/(/  end=/)/  contains=@jsAll extend fold
    1              0.000037 syntax region  jsParenIfElse        contained matchgroup=jsParensIfElse        start=/(/  end=/)/  contains=@jsAll skipwhite skipempty nextgroup=jsCommentIfElse,jsIfElseBlock,jsReturn extend fold
    1              0.000036 syntax region  jsParenRepeat        contained matchgroup=jsParensRepeat        start=/(/  end=/)/  contains=@jsAll skipwhite skipempty nextgroup=jsCommentRepeat,jsRepeatBlock,jsReturn extend fold
    1              0.000031 syntax region  jsParenSwitch        contained matchgroup=jsParensSwitch        start=/(/  end=/)/  contains=@jsAll skipwhite skipempty nextgroup=jsSwitchBlock extend fold
    1              0.000060 syntax region  jsParenCatch         contained matchgroup=jsParensCatch         start=/(/  end=/)/  skipwhite skipempty nextgroup=jsTryCatchBlock extend fold
    1              0.000083 syntax region  jsFuncArgs           contained matchgroup=jsFuncParens          start=/(/  end=/)/  contains=jsFuncArgCommas,jsComment,jsFuncArgExpression,jsDestructuringBlock,jsDestructuringArray,jsRestExpression,jsFlowArgumentDef skipwhite skipempty nextgroup=jsCommentFunction,jsFuncBlock,jsFlowReturn extend fold
    1              0.000077 syntax region  jsClassBlock         contained matchgroup=jsClassBraces         start=/{/  end=/}/  contains=jsClassFuncName,jsClassMethodType,jsArrowFunction,jsArrowFuncArgs,jsComment,jsGenerator,jsDecorator,jsClassProperty,jsClassPropertyComputed,jsClassStringKey,jsAsyncKeyword,jsNoise extend fold
    1              0.000050 syntax region  jsFuncBlock          contained matchgroup=jsFuncBraces          start=/{/  end=/}/  contains=@jsAll,jsBlock extend fold
    1              0.000035 syntax region  jsIfElseBlock        contained matchgroup=jsIfElseBraces        start=/{/  end=/}/  contains=@jsAll,jsBlock extend fold
    1              0.000035 syntax region  jsTryCatchBlock      contained matchgroup=jsTryCatchBraces      start=/{/  end=/}/  contains=@jsAll,jsBlock skipwhite skipempty nextgroup=jsCatch,jsFinally extend fold
    1              0.000025 syntax region  jsFinallyBlock       contained matchgroup=jsFinallyBraces       start=/{/  end=/}/  contains=@jsAll,jsBlock extend fold
    1              0.000034 syntax region  jsSwitchBlock        contained matchgroup=jsSwitchBraces        start=/{/  end=/}/  contains=@jsAll,jsBlock,jsSwitchCase extend fold
    1              0.000028 syntax region  jsRepeatBlock        contained matchgroup=jsRepeatBraces        start=/{/  end=/}/  contains=@jsAll,jsBlock extend fold
    1              0.000135 syntax region  jsDestructuringBlock contained matchgroup=jsDestructuringBraces start=/{/  end=/}/  contains=jsDestructuringProperty,jsDestructuringAssignment,jsDestructuringNoise,jsDestructuringPropertyComputed,jsSpreadExpression,jsComment nextgroup=jsFlowDefinition extend fold
    1              0.000077 syntax region  jsDestructuringArray contained matchgroup=jsDestructuringBraces start=/\[/ end=/\]/ contains=jsDestructuringPropertyValue,jsDestructuringNoise,jsDestructuringProperty,jsSpreadExpression,jsDestructuringBlock,jsDestructuringArray,jsComment nextgroup=jsFlowDefinition extend fold
    1              0.000123 syntax region  jsObject             contained matchgroup=jsObjectBraces        start=/{/  end=/}/  contains=jsObjectKey,jsObjectKeyString,jsObjectKeyComputed,jsObjectShorthandProp,jsObjectSeparator,jsObjectFuncName,jsObjectMethodType,jsGenerator,jsComment,jsObjectStringKey,jsSpreadExpression,jsDecorator,jsAsyncKeyword,jsTemplateString extend fold
    1              0.000061 syntax region  jsBlock                        matchgroup=jsBraces              start=/{/  end=/}/  contains=@jsAll,jsSpreadExpression extend fold
    1              0.000073 syntax region  jsModuleGroup        contained matchgroup=jsModuleBraces        start=/{/ end=/}/   contains=jsModuleKeyword,jsModuleComma,jsModuleAs,jsComment,jsFlowTypeKeyword skipwhite skipempty nextgroup=jsFrom fold
    1              0.000051 syntax region  jsSpreadExpression   contained matchgroup=jsSpreadOperator      start=/\.\.\./ end=/[,}\]]\@=/ contains=@jsExpression
    1              0.000027 syntax region  jsRestExpression     contained matchgroup=jsRestOperator        start=/\.\.\./ end=/[,)]\@=/
    1              0.000050 syntax region  jsTernaryIf                    matchgroup=jsTernaryIfOperator   start=/?:\@!/  end=/\%(:\|}\@=\)/  contains=@jsExpression extend skipwhite skipempty nextgroup=@jsExpression
                            " These must occur here or they will be override by jsTernaryIf
    1              0.000022 syntax match   jsOperator           /?\.\ze\_D/
    1              0.000085 syntax match   jsOperator           /??/ skipwhite skipempty nextgroup=@jsExpression
                            
    1              0.000036 syntax match   jsGenerator            contained /\*/ skipwhite skipempty nextgroup=jsFuncName,jsFuncArgs,jsFlowFunctionGroup
    1              0.000022 syntax match   jsFuncName             contained /\<\K\k*/ skipwhite skipempty nextgroup=jsFuncArgs,jsFlowFunctionGroup
    1              0.000036 syntax region  jsFuncArgExpression    contained matchgroup=jsFuncArgOperator start=/=/ end=/[,)]\@=/ contains=@jsExpression extend
    1              0.000028 syntax match   jsFuncArgCommas        contained ','
    1              0.000014 syntax keyword jsArguments            contained arguments
    1              0.000014 syntax keyword jsForAwait             contained await skipwhite skipempty nextgroup=jsParenRepeat
                            
                            " Matches a single keyword argument with no parens
    1              0.000035 syntax match   jsArrowFuncArgs  /\<\K\k*\ze\s*=>/ skipwhite contains=jsFuncArgs skipwhite skipempty nextgroup=jsArrowFunction extend
                            " Matches a series of arguments surrounded in parens
    1              0.000028 syntax match   jsArrowFuncArgs  /([^()]*)\ze\s*=>/ contains=jsFuncArgs skipempty skipwhite nextgroup=jsArrowFunction extend
                            
    1              0.000088 exe 'syntax match jsFunction /\<function\>/      skipwhite skipempty nextgroup=jsGenerator,jsFuncName,jsFuncArgs,jsFlowFunctionGroup skipwhite '.(exists('g:javascript_conceal_function') ? 'conceal cchar='.g:javascript_conceal_function : '')
    1              0.000057 exe 'syntax match jsArrowFunction /=>/           skipwhite skipempty nextgroup=jsFuncBlock,jsCommentFunction '.(exists('g:javascript_conceal_arrow_function') ? 'conceal cchar='.g:javascript_conceal_arrow_function : '')
    1              0.000054 exe 'syntax match jsArrowFunction /()\ze\s*=>/   skipwhite skipempty nextgroup=jsArrowFunction '.(exists('g:javascript_conceal_noarg_arrow_function') ? 'conceal cchar='.g:javascript_conceal_noarg_arrow_function : '')
    1              0.000047 exe 'syntax match jsArrowFunction /_\ze\s*=>/    skipwhite skipempty nextgroup=jsArrowFunction '.(exists('g:javascript_conceal_underscore_arrow_function') ? 'conceal cchar='.g:javascript_conceal_underscore_arrow_function : '')
                            
                            " Classes
    1              0.000012 syntax keyword jsClassKeyword           contained class
    1              0.000016 syntax keyword jsExtendsKeyword         contained extends skipwhite skipempty nextgroup=@jsExpression
    1              0.000013 syntax match   jsClassNoise             contained /\./
    1              0.000029 syntax match   jsClassFuncName          contained /\<\K\k*\ze\s*[(<]/ skipwhite skipempty nextgroup=jsFuncArgs,jsFlowClassFunctionGroup
    1              0.000041 syntax match   jsClassMethodType        contained /\<\%([gs]et\|static\)\ze\s\+\K\k*/ skipwhite skipempty nextgroup=jsAsyncKeyword,jsClassFuncName,jsClassProperty
    1              0.000074 syntax region  jsClassDefinition                  start=/\<class\>/ end=/\(\<extends\>\s\+\)\@<!{\@=/ contains=jsClassKeyword,jsExtendsKeyword,jsClassNoise,@jsExpression,jsFlowClassGroup skipwhite skipempty nextgroup=jsCommentClass,jsClassBlock,jsFlowClassGroup
    1              0.000026 syntax match   jsClassProperty          contained /\<\K\k*\ze\s*[=;]/ skipwhite skipempty nextgroup=jsClassValue,jsFlowClassDef
    1              0.000026 syntax region  jsClassValue             contained start=/=/ end=/\_[;}]\@=/ contains=@jsExpression
    1              0.000039 syntax region  jsClassPropertyComputed  contained matchgroup=jsBrackets start=/\[/ end=/]/ contains=@jsExpression skipwhite skipempty nextgroup=jsFuncArgs,jsClassValue extend
    1              0.000041 syntax region  jsClassStringKey         contained start=+\z(["']\)+  skip=+\\\%(\z1\|$\)+  end=+\z1\|$+  contains=jsSpecial extend skipwhite skipempty nextgroup=jsFuncArgs
                            
                            " Destructuring
    1              0.000015 syntax match   jsDestructuringPropertyValue     contained /\k\+/
    1              0.000022 syntax match   jsDestructuringProperty          contained /\k\+\ze\s*=/ skipwhite skipempty nextgroup=jsDestructuringValue
    1              0.000039 syntax match   jsDestructuringAssignment        contained /\k\+\ze\s*:/ skipwhite skipempty nextgroup=jsDestructuringValueAssignment
    1              0.000027 syntax region  jsDestructuringValue             contained start=/=/ end=/[,}\]]\@=/ contains=@jsExpression extend
    1              0.000043 syntax region  jsDestructuringValueAssignment   contained start=/:/ end=/[,}=]\@=/ contains=jsDestructuringPropertyValue,jsDestructuringBlock,jsNoise,jsDestructuringNoise skipwhite skipempty nextgroup=jsDestructuringValue extend
    1              0.000017 syntax match   jsDestructuringNoise             contained /[,[\]]/
    1              0.000037 syntax region  jsDestructuringPropertyComputed  contained matchgroup=jsDestructuringBraces start=/\[/ end=/]/ contains=@jsExpression skipwhite skipempty nextgroup=jsDestructuringValue,jsDestructuringValueAssignment,jsDestructuringNoise extend fold
                            
                            " Comments
    1              0.000021 syntax keyword jsCommentTodo    contained TODO FIXME XXX TBD NOTE
    1              0.000063 syntax region  jsComment        start=+//+ end=/$/ contains=jsCommentTodo,@Spell extend keepend
    1              0.000161 syntax region  jsComment        start=+/\*+  end=+\*/+ contains=jsCommentTodo,@Spell fold extend keepend
    1              0.000091 syntax region  jsEnvComment     start=/\%^#!/ end=/$/ display
                            
                            " Specialized Comments - These are special comment regexes that are used in
                            " odd places that maintain the proper nextgroup functionality. It sucks we
                            " can't make jsComment a skippable type of group for nextgroup
    1              0.000080 syntax region  jsCommentFunction    contained start=+//+ end=/$/    contains=jsCommentTodo,@Spell skipwhite skipempty nextgroup=jsFuncBlock,jsFlowReturn extend keepend
    1              0.000064 syntax region  jsCommentFunction    contained start=+/\*+ end=+\*/+ contains=jsCommentTodo,@Spell skipwhite skipempty nextgroup=jsFuncBlock,jsFlowReturn fold extend keepend
    1              0.000060 syntax region  jsCommentClass       contained start=+//+ end=/$/    contains=jsCommentTodo,@Spell skipwhite skipempty nextgroup=jsClassBlock,jsFlowClassGroup extend keepend
    1              0.000059 syntax region  jsCommentClass       contained start=+/\*+ end=+\*/+ contains=jsCommentTodo,@Spell skipwhite skipempty nextgroup=jsClassBlock,jsFlowClassGroup fold extend keepend
    1              0.000050 syntax region  jsCommentIfElse      contained start=+//+ end=/$/    contains=jsCommentTodo,@Spell skipwhite skipempty nextgroup=jsIfElseBlock extend keepend
    1              0.000050 syntax region  jsCommentIfElse      contained start=+/\*+ end=+\*/+ contains=jsCommentTodo,@Spell skipwhite skipempty nextgroup=jsIfElseBlock fold extend keepend
    1              0.000034 syntax region  jsCommentRepeat      contained start=+//+ end=/$/    contains=jsCommentTodo,@Spell skipwhite skipempty nextgroup=jsRepeatBlock extend keepend
    1              0.000034 syntax region  jsCommentRepeat      contained start=+/\*+ end=+\*/+ contains=jsCommentTodo,@Spell skipwhite skipempty nextgroup=jsRepeatBlock fold extend keepend
                            
                            " Decorators
    1              0.000031 syntax match   jsDecorator                    /^\s*@/ nextgroup=jsDecoratorFunction
    1              0.000024 syntax match   jsDecoratorFunction  contained /\h[a-zA-Z0-9_.]*/ nextgroup=jsParenDecorator
                            
    1              0.000028 if exists("javascript_plugin_jsdoc")
    1   0.028910   0.026444   runtime extras/jsdoc.vim
                              " NGDoc requires JSDoc
    1              0.000019   if exists("javascript_plugin_ngdoc")
                                runtime extras/ngdoc.vim
    1              0.000003   endif
    1              0.000002 endif
                            
    1              0.000012 if exists("javascript_plugin_flow")
                              runtime extras/flow.vim
    1              0.000003 endif
                            
    1              0.000307 syntax cluster jsExpression  contains=jsBracket,jsParen,jsObject,jsTernaryIf,jsTaggedTemplate,jsTemplateString,jsString,jsRegexpString,jsNumber,jsFloat,jsOperator,jsOperatorKeyword,jsBooleanTrue,jsBooleanFalse,jsNull,jsFunction,jsArrowFunction,jsGlobalObjects,jsExceptions,jsFutureKeys,jsDomErrNo,jsDomNodeConsts,jsHtmlEvents,jsFuncCall,jsUndefined,jsNan,jsPrototype,jsBuiltins,jsNoise,jsClassDefinition,jsArrowFunction,jsArrowFuncArgs,jsParensError,jsComment,jsArguments,jsThis,jsSuper,jsDo,jsForAwait,jsAsyncKeyword,jsStatement,jsDot
    1              0.000041 syntax cluster jsAll         contains=@jsExpression,jsStorageClass,jsConditional,jsRepeat,jsReturn,jsException,jsTry,jsNoise,jsBlockLabel
                            
                            " Define the default highlighting.
                            " For version 5.7 and earlier: only when not done already
                            " For version 5.8 and later: only when an item doesn't have highlighting yet
    1              0.000015 if version >= 508 || !exists("did_javascript_syn_inits")
    1              0.000006   if version < 508
                                let did_javascript_syn_inits = 1
                                command -nargs=+ HiLink hi link <args>
    1              0.000004   else
    1              0.000038     command -nargs=+ HiLink hi def link <args>
    1              0.000004   endif
    1              0.000019   HiLink jsComment              Comment
    1              0.000016   HiLink jsEnvComment           PreProc
    1              0.000016   HiLink jsParensIfElse         jsParens
    1              0.000015   HiLink jsParensRepeat         jsParens
    1              0.000015   HiLink jsParensSwitch         jsParens
    1              0.000014   HiLink jsParensCatch          jsParens
    1              0.000016   HiLink jsCommentTodo          Todo
    1              0.000015   HiLink jsString               String
    1              0.000014   HiLink jsObjectKeyString      String
    1              0.000014   HiLink jsTemplateString       String
    1              0.000013   HiLink jsObjectStringKey      String
    1              0.000014   HiLink jsClassStringKey       String
    1              0.000016   HiLink jsTaggedTemplate       StorageClass
    1              0.000015   HiLink jsTernaryIfOperator    Operator
    1              0.000015   HiLink jsRegexpString         String
    1              0.000015   HiLink jsRegexpBoundary       SpecialChar
    1              0.000016   HiLink jsRegexpQuantifier     SpecialChar
    1              0.000015   HiLink jsRegexpOr             Conditional
    1              0.000014   HiLink jsRegexpMod            SpecialChar
    1              0.000014   HiLink jsRegexpBackRef        SpecialChar
    1              0.000016   HiLink jsRegexpGroup          jsRegexpString
    1              0.000015   HiLink jsRegexpCharClass      Character
    1              0.000017   HiLink jsCharacter            Character
    1              0.000015   HiLink jsPrototype            Special
    1              0.000015   HiLink jsConditional          Conditional
    1              0.000016   HiLink jsBranch               Conditional
    1              0.000015   HiLink jsLabel                Label
    1              0.000073   HiLink jsReturn               Statement
    1              0.000015   HiLink jsRepeat               Repeat
    1              0.000014   HiLink jsDo                   Repeat
    1              0.000014   HiLink jsStatement            Statement
    1              0.000014   HiLink jsException            Exception
    1              0.000014   HiLink jsTry                  Exception
    1              0.000015   HiLink jsFinally              Exception
    1              0.000014   HiLink jsCatch                Exception
    1              0.000015   HiLink jsAsyncKeyword         Keyword
    1              0.000014   HiLink jsForAwait             Keyword
    1              0.000021   HiLink jsArrowFunction        Type
    1              0.000024   HiLink jsFunction             Type
    1              0.000038   HiLink jsGenerator            jsFunction
    1              0.000026   HiLink jsArrowFuncArgs        jsFuncArgs
    1              0.000170   HiLink jsFuncName             Function
    1              0.000065   HiLink jsFuncCall             Function
    1              0.000031   HiLink jsClassFuncName        jsFuncName
    1              0.000026   HiLink jsObjectFuncName       Function
    1              0.000026   HiLink jsArguments            Special
    1              0.000029   HiLink jsError                Error
    1              0.000029   HiLink jsParensError          Error
    1              0.000025   HiLink jsOperatorKeyword      jsOperator
    1              0.000029   HiLink jsOperator             Operator
    1              0.000024   HiLink jsOf                   Operator
    1              0.000025   HiLink jsStorageClass         StorageClass
    1              0.000023   HiLink jsClassKeyword         Keyword
    1              0.000024   HiLink jsExtendsKeyword       Keyword
    1              0.000023   HiLink jsThis                 Special
    1              0.000022   HiLink jsSuper                Constant
    1              0.000025   HiLink jsNan                  Number
    1              0.000024   HiLink jsNull                 Type
    1              0.000024   HiLink jsUndefined            Type
    1              0.000023   HiLink jsNumber               Number
    1              0.000023   HiLink jsFloat                Float
    1              0.000024   HiLink jsBooleanTrue          Boolean
    1              0.000112   HiLink jsBooleanFalse         Boolean
    1              0.000032   HiLink jsObjectColon          jsNoise
    1              0.000031   HiLink jsNoise                Noise
    1              0.000070   HiLink jsDot                  Noise
    1              0.000031   HiLink jsBrackets             Noise
    1              0.000025   HiLink jsParens               Noise
    1              0.000023   HiLink jsBraces               Noise
    1              0.000024   HiLink jsFuncBraces           Noise
    1              0.000023   HiLink jsFuncParens           Noise
    1              0.000024   HiLink jsClassBraces          Noise
    1              0.000022   HiLink jsClassNoise           Noise
    1              0.000014   HiLink jsIfElseBraces         Noise
    1              0.000013   HiLink jsTryCatchBraces       Noise
    1              0.000013   HiLink jsModuleBraces         Noise
    1              0.000013   HiLink jsObjectBraces         Noise
    1              0.000014   HiLink jsObjectSeparator      Noise
    1              0.000013   HiLink jsFinallyBraces        Noise
    1              0.000013   HiLink jsRepeatBraces         Noise
    1              0.000013   HiLink jsSwitchBraces         Noise
    1              0.000016   HiLink jsSpecial              Special
    1              0.000014   HiLink jsTemplateBraces       Noise
    1              0.000016   HiLink jsGlobalObjects        Constant
    1              0.000015   HiLink jsGlobalNodeObjects    Constant
    1              0.000014   HiLink jsExceptions           Constant
    1              0.000014   HiLink jsBuiltins             Constant
    1              0.000015   HiLink jsImport               Include
    1              0.000015   HiLink jsExport               Include
    1              0.000016   HiLink jsExportDefault        StorageClass
    1              0.000016   HiLink jsExportDefaultGroup   jsExportDefault
    1              0.000015   HiLink jsModuleAs             Include
    1              0.000014   HiLink jsModuleComma          jsNoise
    1              0.000013   HiLink jsModuleAsterisk       Noise
    1              0.000014   HiLink jsFrom                 Include
    1              0.000014   HiLink jsDecorator            Special
    1              0.000015   HiLink jsDecoratorFunction    Function
    1              0.000015   HiLink jsParensDecorator      jsParens
    1              0.000016   HiLink jsFuncArgOperator      jsFuncArgs
    1              0.000016   HiLink jsClassProperty        jsObjectKey
    1              0.000015   HiLink jsObjectShorthandProp  jsObjectKey
    1              0.000015   HiLink jsSpreadOperator       Operator
    1              0.000014   HiLink jsRestOperator         Operator
    1              0.000015   HiLink jsRestExpression       jsFuncArgs
    1              0.000014   HiLink jsSwitchColon          Noise
    1              0.000016   HiLink jsClassMethodType      Type
    1              0.000014   HiLink jsObjectMethodType     Type
    1              0.000015   HiLink jsClassDefinition      jsFuncName
    1              0.000015   HiLink jsBlockLabel           Identifier
    1              0.000016   HiLink jsBlockLabelKey        jsBlockLabel
                            
    1              0.000020   HiLink jsDestructuringBraces     Noise
    1              0.000016   HiLink jsDestructuringProperty   jsFuncArgs
    1              0.000017   HiLink jsDestructuringAssignment jsObjectKey
    1              0.000014   HiLink jsDestructuringNoise      Noise
                            
    1              0.000015   HiLink jsCommentFunction      jsComment
    1              0.000015   HiLink jsCommentClass         jsComment
    1              0.000014   HiLink jsCommentIfElse        jsComment
    1              0.000013   HiLink jsCommentRepeat        jsComment
                            
    1              0.000014   HiLink jsDomErrNo             Constant
    1              0.000014   HiLink jsDomNodeConsts        Constant
    1              0.000017   HiLink jsDomElemAttrs         Label
    1              0.000040   HiLink jsDomElemFuncs         PreProc
                            
    1              0.000022   HiLink jsHtmlEvents           Special
    1              0.000015   HiLink jsHtmlElemAttrs        Label
    1              0.000015   HiLink jsHtmlElemFuncs        PreProc
                            
    1              0.000014   HiLink jsCssStyles            Label
                            
    1              0.000008   delcommand HiLink
    1              0.000004 endif
                            
                            " Define the htmlJavaScript for HTML syntax html.vim
    1              0.000035 syntax cluster  htmlJavaScript       contains=@jsAll,jsImport,jsExport
    1              0.000022 syntax cluster  javaScriptExpression contains=@jsAll
                            
                            " Vim's default html.vim highlights all javascript as 'Special'
    1              0.000008 hi! def link javaScript              NONE
                            
    1              0.000020 let b:current_syntax = "javascript"
    1              0.000017 if main_syntax == 'javascript'
                              unlet main_syntax
    1              0.000037 endif

SCRIPT  C:\Users\Lenovo\AppData\Local\nvim-data\plugged\vim-polyglot\extras\jsdoc.vim
Sourced 1 time
Total time:   0.001719
 Self time:   0.001607

count  total (s)   self (s)
    1   0.000483   0.000372 if polyglot#init#is_disabled(expand('<sfile>:p'), 'javascript', 'extras/jsdoc.vim')
                              finish
    1              0.000004 endif
                            
                            "" syntax coloring for javadoc comments (HTML)
    1              0.000097 syntax region jsComment    matchgroup=jsComment start="/\*\s*"  end="\*/" contains=jsDocTags,jsCommentTodo,jsCvsTag,@jsHtml,@Spell fold
                            
                            " tags containing a param
    1              0.000123 syntax match  jsDocTags         contained "@\(alias\|api\|augments\|borrows\|class\|constructs\|default\|defaultvalue\|emits\|exception\|exports\|extends\|fires\|kind\|link\|listens\|member\|member[oO]f\|mixes\|module\|name\|namespace\|requires\|template\|throws\|var\|variation\|version\)\>" skipwhite nextgroup=jsDocParam
                            " tags containing type and param
    1              0.000042 syntax match  jsDocTags         contained "@\(arg\|argument\|cfg\|param\|property\|prop\|typedef\)\>" skipwhite nextgroup=jsDocType
                            " tags containing type but no param
    1              0.000076 syntax match  jsDocTags         contained "@\(callback\|define\|enum\|external\|implements\|this\|type\|return\|returns\|yields\)\>" skipwhite nextgroup=jsDocTypeNoParam
                            " tags containing references
    1              0.000050 syntax match  jsDocTags         contained "@\(lends\|see\|tutorial\)\>" skipwhite nextgroup=jsDocSeeTag
                            " other tags (no extra syntax)
    1              0.000134 syntax match  jsDocTags         contained "@\(abstract\|access\|accessor\|async\|author\|classdesc\|constant\|const\|constructor\|copyright\|deprecated\|desc\|description\|dict\|event\|example\|file\|file[oO]verview\|final\|function\|global\|ignore\|inherit[dD]oc\|inner\|instance\|interface\|license\|localdoc\|method\|mixin\|nosideeffects\|override\|overview\|preserve\|private\|protected\|public\|readonly\|since\|static\|struct\|todo\|summary\|undocumented\|virtual\)\>"
                            
    1              0.000040 syntax region jsDocType         contained matchgroup=jsDocTypeBrackets start="{" end="}" contains=jsDocTypeRecord oneline skipwhite nextgroup=jsDocParam
    1              0.000029 syntax match  jsDocType         contained "\%(#\|\"\|\w\|\.\|:\|\/\)\+" skipwhite nextgroup=jsDocParam
    1              0.000022 syntax region jsDocTypeRecord   contained start=/{/ end=/}/ contains=jsDocTypeRecord extend
    1              0.000021 syntax region jsDocTypeRecord   contained start=/\[/ end=/\]/ contains=jsDocTypeRecord extend
    1              0.000016 syntax region jsDocTypeNoParam  contained start="{" end="}" oneline
    1              0.000020 syntax match  jsDocTypeNoParam  contained "\%(#\|\"\|\w\|\.\|:\|\/\)\+"
    1              0.000056 syntax match  jsDocParam        contained "\%(#\|\$\|-\|'\|\"\|{.\{-}}\|\w\|\.\|:\|\/\|\[.\{-}]\|=\)\+"
    1              0.000021 syntax region jsDocSeeTag       contained matchgroup=jsDocSeeTag start="{" end="}" contains=jsDocTags
                            
    1              0.000018 if version >= 508 || !exists("did_javascript_syn_inits")
    1              0.000007   if version < 508
                                let did_javascript_syn_inits = 1
                                command -nargs=+ HiLink hi link <args>
    1              0.000004   else
    1              0.000047     command -nargs=+ HiLink hi def link <args>
    1              0.000004   endif
    1              0.000026   HiLink jsDocTags              Special
    1              0.000024   HiLink jsDocSeeTag            Function
    1              0.000017   HiLink jsDocType              Type
    1              0.000016   HiLink jsDocTypeBrackets      jsDocType
    1              0.000014   HiLink jsDocTypeRecord        jsDocType
    1              0.000014   HiLink jsDocTypeNoParam       Type
    1              0.000015   HiLink jsDocParam             Label
    1              0.000006   delcommand HiLink
    1              0.000053 endif

SCRIPT  C:\Users\Lenovo\scoop\apps\neovim\0.6.1\share\nvim\runtime\syntax\javascript.vim
Sourced 1 time
Total time:   0.000369
 Self time:   0.000369

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:	JavaScript
                            " Maintainer:	Claudio Fleiner <claudio@fleiner.com>
                            " Updaters:	Scott Shattuck (ss) <ss@technicalpursuit.com>
                            " URL:		http://www.fleiner.com/vim/syntax/javascript.vim
                            " Changes:	(ss) added keywords, reserved words, and other identifiers
                            "		(ss) repaired several quoting and grouping glitches
                            "		(ss) fixed regex parsing issue with multiple qualifiers [gi]
                            "		(ss) additional factoring of keywords, globals, and members
                            " Last Change:	2021 Mar 30
                            " 		2013 Jun 12: adjusted javaScriptRegexpString (Kevin Locke)
                            " 		2018 Apr 14: adjusted javaScriptRegexpString (LongJohnCoder)
                            
                            " tuning parameters:
                            " unlet javaScript_fold
                            
    1              0.000054 if !exists("main_syntax")
                              " quit when a syntax file was already loaded
                              if exists("b:current_syntax")
                                finish
                              endif
                              let main_syntax = 'javascript'
    1              0.000033 elseif exists("b:current_syntax") && b:current_syntax == "javascript"
    1              0.000007   finish
                            endif
                            
                            let s:cpo_save = &cpo
                            set cpo&vim
                            
                            
                            syn keyword javaScriptCommentTodo      TODO FIXME XXX TBD contained
                            syn match   javaScriptLineComment      "\/\/.*" contains=@Spell,javaScriptCommentTodo
                            syn match   javaScriptCommentSkip      "^[ \t]*\*\($\|[ \t]\+\)"
                            syn region  javaScriptComment	       start="/\*"  end="\*/" contains=@Spell,javaScriptCommentTodo
                            syn match   javaScriptSpecial	       "\\\d\d\d\|\\."
                            syn region  javaScriptStringD	       start=+"+  skip=+\\\\\|\\"+  end=+"\|$+	contains=javaScriptSpecial,@htmlPreproc
                            syn region  javaScriptStringS	       start=+'+  skip=+\\\\\|\\'+  end=+'\|$+	contains=javaScriptSpecial,@htmlPreproc
                            syn region  javaScriptStringT	       start=+`+  skip=+\\\\\|\\`+  end=+`+	contains=javaScriptSpecial,javaScriptEmbed,@htmlPreproc
                            
                            syn region  javaScriptEmbed	       start=+${+  end=+}+	contains=@javaScriptEmbededExpr
                            
                            syn match   javaScriptSpecialCharacter "'\\.'"
                            syn match   javaScriptNumber	       "-\=\<\d\+L\=\>\|0[xX][0-9a-fA-F]\+\>"
                            syn match   javaScriptNumber	       "-\=\<\d\+\%(_\d\+\)*\>"
                            syn region  javaScriptRegexpString     start=+[,(=+]\s*/[^/*]+ms=e-1,me=e-1 skip=+\\\\\|\\/+ end=+/[gimuys]\{0,2\}\s*$+ end=+/[gimuys]\{0,2\}\s*[+;.,)\]}]+me=e-1 end=+/[gimuys]\{0,2\}\s\+\/+me=e-1 contains=@htmlPreproc,javaScriptComment oneline
                            
                            syn keyword javaScriptConditional	if else switch
                            syn keyword javaScriptRepeat		while for do in
                            syn keyword javaScriptBranch		break continue
                            syn keyword javaScriptOperator		new delete instanceof typeof
                            syn keyword javaScriptType		Array Boolean Date Function Number Object String RegExp
                            syn keyword javaScriptStatement		return with await
                            syn keyword javaScriptBoolean		true false
                            syn keyword javaScriptNull		null undefined
                            syn keyword javaScriptIdentifier	arguments this var let
                            syn keyword javaScriptLabel		case default
                            syn keyword javaScriptException		try catch finally throw
                            syn keyword javaScriptMessage		alert confirm prompt status
                            syn keyword javaScriptGlobal		self window top parent
                            syn keyword javaScriptMember		document event location 
                            syn keyword javaScriptDeprecated	escape unescape
                            syn keyword javaScriptReserved		abstract boolean byte char class const debugger double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile async
                            
                            syn cluster  javaScriptEmbededExpr	contains=javaScriptBoolean,javaScriptNull,javaScriptIdentifier,javaScriptStringD,javaScriptStringS,javaScriptStringT
                            
                            if exists("javaScript_fold")
                                syn match	javaScriptFunction	"\<function\>"
                                syn region	javaScriptFunctionFold	start="\<function\>.*[^};]$" end="^\z1}.*$" transparent fold keepend
                            
                                syn sync match javaScriptSync	grouphere javaScriptFunctionFold "\<function\>"
                                syn sync match javaScriptSync	grouphere NONE "^}"
                            
                                setlocal foldmethod=syntax
                                setlocal foldtext=getline(v:foldstart)
                            else
                                syn keyword javaScriptFunction	function
                                syn match	javaScriptBraces	   "[{}\[\]]"
                                syn match	javaScriptParens	   "[()]"
                            endif
                            
                            if main_syntax == "javascript"
                              syn sync fromstart
                              syn sync maxlines=100
                            
                              syn sync ccomment javaScriptComment
                            endif
                            
                            " Define the default highlighting.
                            " Only when an item doesn't have highlighting yet
                            hi def link javaScriptComment		Comment
                            hi def link javaScriptLineComment		Comment
                            hi def link javaScriptCommentTodo		Todo
                            hi def link javaScriptSpecial		Special
                            hi def link javaScriptStringS		String
                            hi def link javaScriptStringD		String
                            hi def link javaScriptStringT		String
                            hi def link javaScriptCharacter		Character
                            hi def link javaScriptSpecialCharacter	javaScriptSpecial
                            hi def link javaScriptNumber		javaScriptValue
                            hi def link javaScriptConditional		Conditional
                            hi def link javaScriptRepeat		Repeat
                            hi def link javaScriptBranch		Conditional
                            hi def link javaScriptOperator		Operator
                            hi def link javaScriptType			Type
                            hi def link javaScriptStatement		Statement
                            hi def link javaScriptFunction		Function
                            hi def link javaScriptBraces		Function
                            hi def link javaScriptError		Error
                            hi def link javaScrParenError		javaScriptError
                            hi def link javaScriptNull			Keyword
                            hi def link javaScriptBoolean		Boolean
                            hi def link javaScriptRegexpString		String
                            
                            hi def link javaScriptIdentifier		Identifier
                            hi def link javaScriptLabel		Label
                            hi def link javaScriptException		Exception
                            hi def link javaScriptMessage		Keyword
                            hi def link javaScriptGlobal		Keyword
                            hi def link javaScriptMember		Keyword
                            hi def link javaScriptDeprecated		Exception 
                            hi def link javaScriptReserved		Keyword
                            hi def link javaScriptDebug		Debug
                            hi def link javaScriptConstant		Label
                            hi def link javaScriptEmbed		Special
                            
                            
                            
                            let b:current_syntax = "javascript"
                            if main_syntax == 'javascript'
                              unlet main_syntax
                            endif
                            let &cpo = s:cpo_save
                            unlet s:cpo_save
                            
                            " vim: ts=8

SCRIPT  C:\Users\Lenovo\AppData\Local\nvim-data\plugged\vim-polyglot\after\syntax\javascript.vim
Sourced 1 time
Total time:   0.068998
 Self time:   0.029253

count  total (s)   self (s)
    1   0.000504   0.000393 if polyglot#init#is_disabled(expand('<sfile>:p'), 'jsx', 'after/syntax/javascript.vim')
                              finish
    1              0.000003 endif
                            
    1              0.000014 if get(g:, 'vim_jsx_pretty_disable_js', 0)
                              finish
    1              0.000002 endif
                            
    1   0.068327   0.028693 source <sfile>:h/jsx.vim

SCRIPT  C:\Users\Lenovo\AppData\Local\nvim-data\plugged\vim-polyglot\after\syntax\jsx.vim
Sourced 1 time
Total time:   0.038803
 Self time:   0.035408

count  total (s)   self (s)
    1   0.000498   0.000376 if polyglot#init#is_disabled(expand('<sfile>:p'), 'jsx', 'after/syntax/jsx.vim')
                              finish
    1              0.000004 endif
                            
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " Vim syntax file
                            "
                            " Language: javascript.jsx
                            " Maintainer: MaxMellon <maxmellon1994@gmail.com>
                            "
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    1              0.000026 let s:jsx_cpo = &cpo
    1              0.000031 set cpo&vim
                            
    1              0.000010 syntax case match
                            
    1              0.000015 if exists('b:current_syntax')
    1              0.000012   let s:current_syntax = b:current_syntax
    1              0.000009   unlet b:current_syntax
    1              0.000003 endif
                            
    1              0.000011 if exists('s:current_syntax')
    1              0.000010   let b:current_syntax = s:current_syntax
    1              0.000002 endif
                            
    1              0.000019 if hlexists("jsDebugger") || hlexists("jsNoise")    " yuezk/vim-js or pangloss/vim-javascript
    1              0.000039   syntax cluster jsExpression add=jsxRegion
                            elseif hlexists("javascriptOpSymbols")    " othree/yajs.vim
                              " refine the javascript line comment
                              syntax region javascriptLineComment start=+//+ end=/$/ contains=@Spell,javascriptCommentTodo extend keepend
                              syntax cluster javascriptValue add=jsxRegion
                              syntax cluster javascriptNoReserved add=jsxElement,jsxTag
                            else    " build-in javascript syntax
                              " refine the javascript line comment
                              syntax region javaScriptLineComment start=+//+ end=/$/ contains=@Spell,javascriptCommentTodo extend keepend
                            
                              " refine the template string syntax
                              syntax region javaScriptEmbed matchgroup=javaScriptEmbedBraces start=+\${+ end=+}+ contained contains=@javaScriptEmbededExpr
                            
                              " add a javaScriptBlock group for build-in syntax
                              syntax region javaScriptBlock
                                    \ matchgroup=javaScriptBraces
                                    \ start="{"
                                    \ end="}"
                                    \ contained
                                    \ extend
                                    \ contains=javaScriptBlock,@javaScriptEmbededExpr,javaScript.*
                                    \ fold
                            
                              syntax cluster javaScriptEmbededExpr add=jsxRegion,javaScript.*
    1              0.000004 endif
                            
    1   0.034780   0.031508 runtime syntax/jsx_pretty.vim
                            
    1              0.000012 let b:current_syntax = 'javascript.jsx'
                            
    1              0.000036 let &cpo = s:jsx_cpo
    1              0.000033 unlet s:jsx_cpo

SCRIPT  C:\Users\Lenovo\AppData\Local\nvim-data\plugged\vim-polyglot\after\syntax\jsx_pretty.vim
Sourced 1 time
Total time:   0.002513
 Self time:   0.002399

count  total (s)   self (s)
    1   0.000485   0.000371 if polyglot#init#is_disabled(expand('<sfile>:p'), 'jsx', 'after/syntax/jsx_pretty.vim')
                              finish
    1              0.000009 endif
                            
    1              0.000023 let s:highlight_close_tag = get(g:, 'vim_jsx_pretty_highlight_close_tag', 0)
                            
                            " detect jsx region
    1              0.000169 syntax region jsxRegion
                                  \ start=+\%(\%(\_[([,?:=+\-*/>{}]\|<\s\+\|&&\|||\|=>\|\<return\|\<default\|\<await\|\<yield\)\_s*\)\@<=<\_s*\%(>\|\z(\%(script\|\s*\<T\>\)\@!\<[_$A-Za-z][-:._$A-Za-z0-9]*\>\)\%(\_s*\%([-+*)\]}&|?,]\|/\%([/*]\|\_s*>\)\@!\)\)\@!\)+
                                  \ end=++
                                  \ contains=jsxElement
                            
                            " <tag id="sample">
                            " ~~~~~~~~~~~~~~~~~
                            " and self close tag
                            " <tag id="sample"   />
                            " ~~~~~~~~~~~~~~~~~~~
    1              0.000135 syntax region jsxTag
                                  \ start=+<+
                                  \ matchgroup=jsxOpenPunct
                                  \ end=+>+
                                  \ matchgroup=NONE
                                  \ end=+\%(/\_s*>\)\@=+
                                  \ contained
                                  \ contains=jsxOpenTag,jsxAttrib,jsxExpressionBlock,jsxSpreadOperator,jsComment,@javascriptComments,javaScriptLineComment,javaScriptComment,typescriptLineComment,typescriptComment
                                  \ keepend
                                  \ extend
                                  \ skipwhite
                                  \ skipempty
                                  \ nextgroup=jsxCloseString
                            
                            " <tag></tag>
                            " ~~~~~~~~~~~
                            " and fragment
                            " <></>
                            " ~~~~~
                            " and self close tag
                            " <tag />
                            " ~~~~~~~
    1              0.000171 syntax region jsxElement
                                  \ start=+<\_s*\%(>\|\${\|\z(\<[-:._$A-Za-z0-9]\+\>\)\)+
                                  \ end=+/\_s*>+
                                  \ end=+<\_s*/\_s*\z1\_s*>+
                                  \ contains=jsxElement,jsxTag,jsxExpressionBlock,jsxComment,jsxCloseTag,@Spell
                                  \ keepend
                                  \ extend
                                  \ contained
                                  \ fold
                            
                            " <tag key={this.props.key}>
                            " ~~~~
                            " and fragment start tag
                            " <>
                            " ~~
    1              0.000090 exe 'syntax region jsxOpenTag
                                  \ matchgroup=jsxOpenPunct
                                  \ start=+<+
                                  \ end=+>+
                                  \ matchgroup=NONE
                                  \ end=+\>+
                                  \ contained
                                  \ contains=jsxTagName
                                  \ nextgroup=jsxAttrib
                                  \ skipwhite
                                  \ skipempty
                                  \ ' .(s:highlight_close_tag ? 'transparent' : '')
                            
                            
                            " <tag key={this.props.key}>
                            "          ~~~~~~~~~~~~~~~~
    1              0.000106 syntax region jsxExpressionBlock
                                  \ matchgroup=jsxBraces
                                  \ start=+{+
                                  \ end=+}+
                                  \ contained
                                  \ extend
                                  \ contains=@jsExpression,jsSpreadExpression,@javascriptExpression,javascriptSpreadOp,@javaScriptEmbededExpr,@typescriptExpression,typescriptObjectSpread,jsComment,@javascriptComments,javaScriptLineComment,javaScriptComment,typescriptLineComment,typescriptComment
                            
                            " <foo.bar>
                            "     ~
    1              0.000012 syntax match jsxDot +\.+ contained
                            
                            " <foo:bar>
                            "     ~
    1              0.000011 syntax match jsxNamespace +:+ contained
                            
                            " <tag id="sample">
                            "        ~
    1              0.000021 syntax match jsxEqual +=+ contained skipwhite skipempty nextgroup=jsxString,jsxExpressionBlock,jsxRegion
                            
                            " <tag />
                            "      ~~
    1              0.000011 syntax match jsxCloseString +/\_s*>+ contained
                            
                            " </tag>
                            " ~~~~~~
                            " and fragment close tag
                            " </>
                            " ~~~
    1              0.000030 syntax region jsxCloseTag
                                  \ matchgroup=jsxClosePunct
                                  \ start=+<\_s*/+
                                  \ end=+>+
                                  \ contained
                                  \ contains=jsxTagName
                            
                            " <tag key={this.props.key}>
                            "      ~~~
    1              0.000043 syntax match jsxAttrib
                                  \ +\<[_$A-Za-z][-:_$A-Za-z0-9]*\>+
                                  \ contained
                                  \ nextgroup=jsxEqual
                                  \ skipwhite
                                  \ skipempty
                                  \ contains=jsxAttribKeyword,jsxNamespace
                            
                            " <MyComponent ...>
                            "  ~~~~~~~~~~~
                            " NOT
                            " <someCamel ...>
                            "      ~~~~~
    1              0.000042 exe 'syntax match jsxComponentName
                                  \ +\<[_$]\?[A-Z][-_$A-Za-z0-9]*\>+
                                  \ contained
                                  \ ' .(s:highlight_close_tag ? 'transparent' : '')
                            
                            " <tag key={this.props.key}>
                            "  ~~~
    1              0.000068 exe 'syntax match jsxTagName
                                  \ +\<[-:._$A-Za-z0-9]\+\>+
                                  \ contained
                                  \ contains=jsxComponentName,jsxDot,jsxNamespace
                                  \ nextgroup=jsxAttrib
                                  \ skipempty
                                  \ skipwhite
                                  \ ' .(s:highlight_close_tag ? 'transparent' : '')
                            
                            " <tag id="sample">
                            "         ~~~~~~~~
                            " and
                            " <tag id='sample'>
                            "         ~~~~~~~~
    1              0.000045 syntax region jsxString start=+\z(["']\)+  skip=+\\\\\|\\\z1\|\\\n+  end=+\z1+ extend contained contains=@Spell
                            
    1              0.000026 let s:tags = get(g:, 'vim_jsx_pretty_template_tags', ['html', 'jsx'])
    1              0.000029 let s:enable_tagged_jsx = !empty(s:tags)
                            
                            " add support to JSX inside the tagged template string
                            " https://github.com/developit/htm
    1              0.000012 if s:enable_tagged_jsx
    1              0.000085   exe 'syntax match jsxRegion +\%(' . join(s:tags, '\|') . '\)\%(\_s*`\)\@=+ contains=jsTemplateStringTag,jsTaggedTemplate,javascriptTagRef skipwhite skipempty nextgroup=jsxTaggedRegion'
                            
    1              0.000095   syntax region jsxTaggedRegion
                                    \ matchgroup=jsxBackticks
                                    \ start=+`+
                                    \ end=+`+
                                    \ extend
                                    \ contained
                                    \ contains=jsxElement,jsxExpressionBlock
                                    \ transparent
                            
    1              0.000063   syntax region jsxExpressionBlock
                                    \ matchgroup=jsxBraces
                                    \ start=+\${+
                                    \ end=+}+
                                    \ extend
                                    \ contained
                                    \ contains=@jsExpression,jsSpreadExpression,@javascriptExpression,javascriptSpreadOp,@javaScriptEmbededExpr,@typescriptExpression,typescriptObjectSpread
                            
    1              0.000072   syntax region jsxOpenTag
                                    \ matchgroup=jsxOpenPunct
                                    \ start=+<\%(\${\)\@=+
                                    \ matchgroup=NONE
                                    \ end=+}\@1<=+
                                    \ contained
                                    \ contains=jsxExpressionBlock
                                    \ skipwhite
                                    \ skipempty
                                    \ nextgroup=jsxAttrib,jsxSpreadOperator
                            
    1              0.000011   syntax keyword jsxAttribKeyword class contained
                            
    1              0.000021   syntax match jsxSpreadOperator +\.\.\.+ contained nextgroup=jsxExpressionBlock skipwhite
                            
    1              0.000012   syntax match jsxCloseTag +<//>+ contained
                            
    1              0.000020   syntax match jsxComment +<!--\_.\{-}-->+
    1              0.000003 endif
                            
                            " Highlight the tag name
    1              0.000010 highlight def link jsxTag Function
    1              0.000007 highlight def link jsxTagName Identifier
    1              0.000006 highlight def link jsxComponentName Function
                            
    1              0.000006 highlight def link jsxAttrib Type
    1              0.000006 highlight def link jsxAttribKeyword jsxAttrib
    1              0.000006 highlight def link jsxString String
    1              0.000005 highlight def link jsxComment Comment
                            
    1              0.000005 highlight def link jsxDot Operator
    1              0.000006 highlight def link jsxNamespace Operator
    1              0.000005 highlight def link jsxEqual Operator
    1              0.000005 highlight def link jsxSpreadOperator Operator
    1              0.000005 highlight def link jsxBraces Special
                            
    1              0.000009 if s:highlight_close_tag
                              highlight def link jsxCloseString Identifier
                              highlight def link jsxOpenPunct jsxTag
    1              0.000005 else
                              " Highlight the jsxCloseString (i.e. />), jsxPunct (i.e. <,>) and jsxCloseTag (i.e. <//>)
    1              0.000006   highlight def link jsxCloseString Comment
    1              0.000006   highlight def link jsxOpenPunct jsxPunct
    1              0.000003 endif
                            
    1              0.000006 highlight def link jsxPunct jsxCloseString
    1              0.000005 highlight def link jsxClosePunct jsxPunct
    1              0.000005 highlight def link jsxCloseTag jsxCloseString
                            
    1              0.000023 let s:vim_jsx_pretty_colorful_config = get(g:, 'vim_jsx_pretty_colorful_config', 0)
                            
    1              0.000009 if s:vim_jsx_pretty_colorful_config == 1
                              highlight def link jsObjectKey Label
                              highlight def link jsArrowFuncArgs Type
                              highlight def link jsFuncArgs Type
    1              0.000044 endif

SCRIPT  C:\Users\Lenovo\AppData\Local\nvim-data\plugged\vim-polyglot\syntax\vb.vim
Sourced 1 time
Total time:   0.012245
 Self time:   0.012132

count  total (s)   self (s)
    1   0.000483   0.000371 if polyglot#init#is_disabled(expand('<sfile>:p'), 'visual-basic', 'syntax/vb.vim')
                              finish
    1              0.000003 endif
                            
                            " Vim syntax file
                            " Language:     Visual Basic
                            " Maintainer:   Doug Kearns <dougkearns@gmail.com>
                            " Former Maintainer:    Tim Chase <vb.vim@tim.thechases.com>
                            " Former Maintainer:    Robert M. Cortopassi <cortopar@mindspring.com>
                            "       (tried multiple times to contact, but email bounced)
                            " Last Change:
                            "   2021 Nov 26  Incorporated additions from Doug Kearns
                            "   2005 May 25  Synched with work by Thomas Barthel
                            "   2004 May 30  Added a few keywords
                            
                            " This was thrown together after seeing numerous requests on the
                            " VIM and VIM-DEV mailing lists.  It is by no means complete.
                            " Send comments, suggestions and requests to the maintainer.
                            
                            " quit when a syntax file was already loaded
    1              0.000013 if exists("b:current_syntax")
                                    finish
    1              0.000003 endif
                            
                            " VB is case insensitive
    1              0.000011 syn case ignore
                            
    1              0.000028 syn keyword vbConditional If Then ElseIf Else Select Case
                            
    1              0.000019 syn keyword vbOperator AddressOf And ByRef ByVal Eqv Imp In
    1              0.000014 syn keyword vbOperator Is Like Mod Not Or To Xor
                            
    1              0.000037 syn match vbOperator "[()+.,\-/*=&]"
    1              0.000017 syn match vbOperator "[<>]=\="
    1              0.000012 syn match vbOperator "<>"
    1              0.000014 syn match vbOperator "\s\+_$"
                            
    1              0.000011 syn keyword vbBoolean  True False
    1              0.000011 syn keyword vbConst Null Nothing
                            
    1              0.000016 syn keyword vbRepeat Do For ForEach Loop Next
    1              0.000012 syn keyword vbRepeat Step To Until Wend While
                            
    1              0.000015 syn keyword vbEvents AccessKeyPress Activate ActiveRowChanged
    1              0.000013 syn keyword vbEvents AfterAddFile AfterChangeFileName AfterCloseFile
    1              0.000012 syn keyword vbEvents AfterColEdit AfterColUpdate AfterDelete
    1              0.000013 syn keyword vbEvents AfterInsert AfterLabelEdit AfterRemoveFile
    1              0.000011 syn keyword vbEvents AfterUpdate AfterWriteFile AmbientChanged
    1              0.000018 syn keyword vbEvents ApplyChanges Associate AsyncProgress
    1              0.000013 syn keyword vbEvents AsyncReadComplete AsyncReadProgress AxisActivated
    1              0.000011 syn keyword vbEvents AxisLabelActivated AxisLabelSelected
    1              0.000013 syn keyword vbEvents AxisLabelUpdated AxisSelected AxisTitleActivated
    1              0.000012 syn keyword vbEvents AxisTitleSelected AxisTitleUpdated AxisUpdated
    1              0.000012 syn keyword vbEvents BeforeClick BeforeColEdit BeforeColUpdate
    1              0.000012 syn keyword vbEvents BeforeConnect BeforeDelete BeforeInsert
    1              0.000012 syn keyword vbEvents BeforeLabelEdit BeforeLoadFile BeforeUpdate
    1              0.000011 syn keyword vbEvents BeginRequest BeginTrans ButtonClick
    1              0.000012 syn keyword vbEvents ButtonCompleted ButtonDropDown ButtonGotFocus
    1              0.000014 syn keyword vbEvents ButtonLostFocus CallbackKeyDown Change Changed
    1              0.000014 syn keyword vbEvents ChartActivated ChartSelected ChartUpdated Click
    1              0.000015 syn keyword vbEvents Close CloseQuery CloseUp ColEdit ColResize
    1              0.000013 syn keyword vbEvents Collapse ColumnClick CommitTrans Compare
    1              0.000012 syn keyword vbEvents ConfigChageCancelled ConfigChanged
    1              0.000013 syn keyword vbEvents ConfigChangedCancelled Connect ConnectionRequest
    1              0.000011 syn keyword vbEvents CurrentRecordChanged DECommandAdded
    1              0.000012 syn keyword vbEvents DECommandPropertyChanged DECommandRemoved
    1              0.000012 syn keyword vbEvents DEConnectionAdded DEConnectionPropertyChanged
    1              0.000012 syn keyword vbEvents DEConnectionRemoved DataArrival DataChanged
    1              0.000012 syn keyword vbEvents DataUpdated DateClicked DblClick Deactivate
    1              0.000012 syn keyword vbEvents DevModeChange DeviceArrival DeviceOtherEvent
    1              0.000011 syn keyword vbEvents DeviceQueryRemove DeviceQueryRemoveFailed
    1              0.000010 syn keyword vbEvents DeviceRemoveComplete DeviceRemovePending
    1              0.000012 syn keyword vbEvents Disconnect DisplayChanged Dissociate
    1              0.000013 syn keyword vbEvents DoGetNewFileName Done DonePainting DownClick
    1              0.000015 syn keyword vbEvents DragDrop DragOver DropDown EditProperty EditQuery
    1              0.000015 syn keyword vbEvents EndRequest EnterCell EnterFocus ExitFocus Expand
    1              0.000013 syn keyword vbEvents FontChanged FootnoteActivated FootnoteSelected
    1              0.000013 syn keyword vbEvents FootnoteUpdated Format FormatSize GotFocus
    1              0.000012 syn keyword vbEvents HeadClick HeightChanged Hide InfoMessage
    1              0.000017 syn keyword vbEvents IniProperties InitProperties Initialize
    1              0.000025 syn keyword vbEvents ItemActivated ItemAdded ItemCheck ItemClick
    1              0.000012 syn keyword vbEvents ItemReloaded ItemRemoved ItemRenamed
    1              0.000014 syn keyword vbEvents ItemSeletected KeyDown KeyPress KeyUp LeaveCell
    1              0.000052 syn keyword vbEvents LegendActivated LegendSelected LegendUpdated
    1              0.000013 syn keyword vbEvents LinkClose LinkError LinkExecute LinkNotify
    1              0.000013 syn keyword vbEvents LinkOpen Load LostFocus MouseDown MouseMove
    1              0.000013 syn keyword vbEvents MouseUp NodeCheck NodeClick OLECompleteDrag
    1              0.000015 syn keyword vbEvents OLEDragDrop OLEDragOver OLEGiveFeedback OLESetData
    1              0.000014 syn keyword vbEvents OLEStartDrag ObjectEvent ObjectMove OnAddNew
    1              0.000014 syn keyword vbEvents OnComm Paint PanelClick PanelDblClick PathChange
    1              0.000011 syn keyword vbEvents PatternChange PlotActivated PlotSelected
    1              0.000012 syn keyword vbEvents PlotUpdated PointActivated PointLabelActivated
    1              0.000013 syn keyword vbEvents PointLabelSelected PointLabelUpdated PointSelected
    1              0.000012 syn keyword vbEvents PointUpdated PowerQuerySuspend PowerResume
    1              0.000012 syn keyword vbEvents PowerStatusChanged PowerSuspend ProcessTag
    1              0.000011 syn keyword vbEvents ProcessingTimeout QueryChangeConfig QueryClose
    1              0.000011 syn keyword vbEvents QueryComplete QueryCompleted QueryTimeout
    1              0.000012 syn keyword vbEvents QueryUnload ReadProperties RepeatedControlLoaded
    1              0.000011 syn keyword vbEvents RepeatedControlUnloaded Reposition
    1              0.000012 syn keyword vbEvents RequestChangeFileName RequestWriteFile Resize
    1              0.000011 syn keyword vbEvents ResultsChanged RetainedProject RollbackTrans
    1              0.000011 syn keyword vbEvents RowColChange RowCurrencyChange RowResize
    1              0.000014 syn keyword vbEvents RowStatusChanged Scroll SelChange SelectionChanged
    1              0.000012 syn keyword vbEvents SendComplete SendProgress SeriesActivated
    1              0.000013 syn keyword vbEvents SeriesSelected SeriesUpdated SettingChanged Show
    1              0.000013 syn keyword vbEvents SplitChange Start StateChanged StatusUpdate
    1              0.000013 syn keyword vbEvents SysColorsChanged Terminate TimeChanged Timer
    1              0.000012 syn keyword vbEvents TitleActivated TitleSelected TitleUpdated
    1              0.000010 syn keyword vbEvents UnboundAddData UnboundDeleteRow
    1              0.000017 syn keyword vbEvents UnboundGetRelativeBookmark UnboundReadData
    1              0.000013 syn keyword vbEvents UnboundWriteData Unformat Unload UpClick Updated
    1              0.000011 syn keyword vbEvents UserEvent Validate ValidationError
    1              0.000012 syn keyword vbEvents VisibleRecordChanged WillAssociate WillChangeData
    1              0.000010 syn keyword vbEvents WillDissociate WillExecute WillUpdateRows
    1              0.000007 syn keyword vbEvents WriteProperties
                            
                            
    1              0.000021 syn keyword vbFunction Abs Array Asc AscB AscW Atn Avg BOF CBool CByte
    1              0.000019 syn keyword vbFunction CCur CDate CDbl CInt CLng CSng CStr CVDate CVErr
    1              0.000018 syn keyword vbFunction CVar CallByName Cdec Choose Chr ChrB ChrW Command
    1              0.000017 syn keyword vbFunction Cos Count CreateObject CurDir DDB Date DateAdd
    1              0.000016 syn keyword vbFunction DateDiff DatePart DateSerial DateValue Day Dir
    1              0.000017 syn keyword vbFunction DoEvents EOF Environ Error Exp FV FileAttr
    1              0.000015 syn keyword vbFunction FileDateTime FileLen FilterFix Fix Format
    1              0.000012 syn keyword vbFunction FormatCurrency FormatDateTime FormatNumber
    1              0.000013 syn keyword vbFunction FormatPercent FreeFile GetAllStrings GetAttr
    1              0.000013 syn keyword vbFunction GetAutoServerSettings GetObject GetSetting Hex
    1              0.000015 syn keyword vbFunction Hour IIf IMEStatus IPmt InStr Input InputB
    1              0.000016 syn keyword vbFunction InputBox InstrB Int IsArray IsDate IsEmpty IsError
    1              0.000015 syn keyword vbFunction IsMissing IsNull IsNumeric IsObject Join LBound
    1              0.000016 syn keyword vbFunction LCase LOF LTrim Left LeftB Len LenB LoadPicture
    1              0.000014 syn keyword vbFunction LoadResData LoadResPicture LoadResString Loc Log
    1              0.000016 syn keyword vbFunction MIRR Max Mid MidB Min Minute Month MonthName
    1              0.000017 syn keyword vbFunction MsgBox NPV NPer Now Oct PPmt PV Partition Pmt
    1              0.000016 syn keyword vbFunction QBColor RGB RTrim Rate Replace Right RightB Rnd
    1              0.000024 syn keyword vbFunction Round SLN SYD Second Seek Sgn Shell Sin Space Spc
    1              0.000016 syn keyword vbFunction Split Sqr StDev StDevP Str StrComp StrConv
    1              0.000016 syn keyword vbFunction StrReverse String Sum Switch Tab Tan Time
    1              0.000016 syn keyword vbFunction TimeSerial TimeValue Timer Trim TypeName UBound
    1              0.000267 syn keyword vbFunction UCase Val Var VarP VarType Weekday WeekdayName
    1              0.000065 syn keyword vbFunction Year
                            
    1              0.000206 syn keyword vbMethods AboutBox Accept Activate Add AddCustom AddFile
    1              0.000147 syn keyword vbMethods AddFromFile AddFromGuid AddFromString
    1              0.000226 syn keyword vbMethods AddFromTemplate AddItem AddNew AddToAddInToolbar
    1              0.000154 syn keyword vbMethods AddToolboxProgID Append AppendAppendChunk
    1              0.000275 syn keyword vbMethods AppendChunk Arrange Assert AsyncRead BatchUpdate
    1              0.000183 syn keyword vbMethods BeginQueryEdit BeginTrans Bind BuildPath
    1              0.000138 syn keyword vbMethods CanPropertyChange Cancel CancelAsyncRead
    1              0.000180 syn keyword vbMethods CancelBatch CancelUpdate CaptureImage CellText
    1              0.000182 syn keyword vbMethods CellValue Circle Clear ClearFields ClearSel
    1              0.000233 syn keyword vbMethods ClearSelCols ClearStructure Clone Close Cls
    1              0.000145 syn keyword vbMethods ColContaining CollapseAll ColumnSize CommitTrans
    1              0.000185 syn keyword vbMethods CompactDatabase Compose Connect Copy CopyFile
    1              0.000142 syn keyword vbMethods CopyFolder CopyQueryDef Count CreateDatabase
    1              0.000141 syn keyword vbMethods CreateDragImage CreateEmbed CreateField
    1              0.000185 syn keyword vbMethods CreateFolder CreateGroup CreateIndex CreateLink
    1              0.000167 syn keyword vbMethods CreatePreparedStatement CreatePropery CreateQuery
    1              0.000145 syn keyword vbMethods CreateQueryDef CreateRelation CreateTableDef
    1              0.000143 syn keyword vbMethods CreateTextFile CreateToolWindow CreateUser
    1              0.000189 syn keyword vbMethods CreateWorkspace Customize Cut Delete
    1              0.000146 syn keyword vbMethods DeleteColumnLabels DeleteColumns DeleteFile
    1              0.000152 syn keyword vbMethods DeleteFolder DeleteLines DeleteRowLabels
    1              0.000249 syn keyword vbMethods DeleteRows DeselectAll DesignerWindow DoVerb Drag
    1              0.000277 syn keyword vbMethods Draw DriveExists Edit EditCopy EditPaste EndDoc
    1              0.000192 syn keyword vbMethods EnsureVisible EstablishConnection Execute Exists
    1              0.000190 syn keyword vbMethods Expand Export ExportReport ExtractIcon Fetch
    1              0.000249 syn keyword vbMethods FetchVerbs FileExists Files FillCache Find
    1              0.000314 syn keyword vbMethods FindFirst FindItem FindLast FindNext FindPrevious
    1              0.000196 syn keyword vbMethods FolderExists Forward GetAbsolutePathName
    1              0.000257 syn keyword vbMethods GetBaseName GetBookmark GetChunk GetClipString
    1              0.000258 syn keyword vbMethods GetData GetDrive GetDriveName GetFile GetFileName
    1              0.000190 syn keyword vbMethods GetFirstVisible GetFolder GetFormat GetHeader
    1              0.000146 syn keyword vbMethods GetLineFromChar GetNumTicks GetParentFolderName
    1              0.000146 syn keyword vbMethods GetRows GetSelectedPart GetSelection
    1              0.000151 syn keyword vbMethods GetSpecialFolder GetTempName GetText
    1              0.000197 syn keyword vbMethods GetVisibleCount GoBack GoForward Hide HitTest
    1              0.000163 syn keyword vbMethods HoldFields Idle Import InitializeLabels Insert
    1              0.000015 syn keyword vbMethods InsertColumnLabels InsertColumns InsertFile
    1              0.000012 syn keyword vbMethods InsertLines InsertObjDlg InsertRowLabels
    1              0.000016 syn keyword vbMethods InsertRows Item Keys KillDoc Layout Line Lines
    1              0.000014 syn keyword vbMethods LinkExecute LinkPoke LinkRequest LinkSend Listen
    1              0.000014 syn keyword vbMethods LoadFile LoadResData LoadResPicture LoadResString
    1              0.000013 syn keyword vbMethods LogEvent MakeCompileFile MakeCompiledFile
    1              0.000013 syn keyword vbMethods MakeReplica MoreResults Move MoveData MoveFile
    1              0.000012 syn keyword vbMethods MoveFirst MoveFolder MoveLast MoveNext
    1              0.000014 syn keyword vbMethods MovePrevious NavigateTo NewPage NewPassword
    1              0.000014 syn keyword vbMethods NextRecordset OLEDrag OnAddinsUpdate OnConnection
    1              0.000013 syn keyword vbMethods OnDisconnection OnStartupComplete Open
    1              0.000013 syn keyword vbMethods OpenAsTextStream OpenConnection OpenDatabase
    1              0.000019 syn keyword vbMethods OpenQueryDef OpenRecordset OpenResultset OpenURL
    1              0.000014 syn keyword vbMethods Overlay PSet PaintPicture PastSpecialDlg Paste
    1              0.000013 syn keyword vbMethods PeekData Play Point PopulatePartial PopupMenu
    1              0.000013 syn keyword vbMethods Print PrintForm PrintReport PropertyChanged Quit
    1              0.000011 syn keyword vbMethods Raise RandomDataFill RandomFillColumns
    1              0.000013 syn keyword vbMethods RandomFillRows ReFill Read ReadAll ReadFromFile
    1              0.000013 syn keyword vbMethods ReadLine ReadProperty Rebind Refresh RefreshLink
    1              0.000012 syn keyword vbMethods RegisterDatabase ReleaseInstance Reload Remove
    1              0.000014 syn keyword vbMethods RemoveAddInFromToolbar RemoveAll RemoveItem Render
    1              0.000014 syn keyword vbMethods RepairDatabase ReplaceLine Reply ReplyAll Requery
    1              0.000014 syn keyword vbMethods ResetCustom ResetCustomLabel ResolveName
    1              0.000012 syn keyword vbMethods RestoreToolbar Resync Rollback RollbackTrans
    1              0.000014 syn keyword vbMethods RowBookmark RowContaining RowTop Save SaveAs
    1              0.000014 syn keyword vbMethods SaveFile SaveToFile SaveToOle1File SaveToolbar
    1              0.000015 syn keyword vbMethods Scale ScaleX ScaleY Scroll SelPrint SelectAll
    1              0.000015 syn keyword vbMethods SelectPart Send SendData Set SetAutoServerSettings
    1              0.000014 syn keyword vbMethods SetData SetFocus SetOption SetSelection SetSize
    1              0.000063 syn keyword vbMethods SetText SetViewport Show ShowColor ShowFont
    1              0.000014 syn keyword vbMethods ShowHelp ShowOpen ShowPrinter ShowSave
    1              0.000016 syn keyword vbMethods ShowWhatsThis SignOff SignOn Size Skip SkipLine
    1              0.000013 syn keyword vbMethods Span Split SplitContaining StartLabelEdit
    1              0.000014 syn keyword vbMethods StartLogging Stop Synchronize Tag TextHeight
    1              0.000013 syn keyword vbMethods TextWidth ToDefaults Trace TwipsToChartPart
    1              0.000013 syn keyword vbMethods TypeByChartType URLFor Update UpdateControls
    1              0.000014 syn keyword vbMethods UpdateRecord UpdateRow Upto ValidateControls Value
    1              0.000012 syn keyword vbMethods WhatsThisMode Write WriteBlankLines WriteLine
    1              0.000011 syn keyword vbMethods WriteProperty WriteTemplate ZOrder
    1              0.000011 syn keyword vbMethods rdoCreateEnvironment rdoRegisterDataSource
                            
    1              0.000020 syn keyword vbStatement Alias AppActivate As Base Beep Begin Call ChDir
    1              0.000019 syn keyword vbStatement ChDrive Close Const Date Declare DefBool DefByte
    1              0.000017 syn keyword vbStatement DefCur DefDate DefDbl DefDec DefInt DefLng DefObj
    1              0.000017 syn keyword vbStatement DefSng DefStr DefVar Deftype DeleteSetting Dim Do
    1              0.000017 syn keyword vbStatement Each ElseIf End Enum Erase Error Event Exit
    1              0.000017 syn keyword vbStatement Explicit FileCopy For ForEach Function Get GoSub
    1              0.000017 syn keyword vbStatement GoTo Gosub Implements Kill LSet Let Lib LineInput
    1              0.000019 syn keyword vbStatement Load Lock Loop Mid MkDir Name Next On OnError Open
    1              0.000015 syn keyword vbStatement Option Preserve Private Property Public Put RSet
    1              0.000014 syn keyword vbStatement RaiseEvent Randomize ReDim Redim Reset Resume
    1              0.000015 syn keyword vbStatement Return RmDir SavePicture SaveSetting Seek SendKeys
    1              0.000017 syn keyword vbStatement Sendkeys Set SetAttr Static Step Stop Sub Time
    1              0.000015 syn keyword vbStatement Type Unload Unlock Until Wend While Width With
    1              0.000007 syn keyword vbStatement Write
                            
    1              0.000019 syn keyword vbKeyword As Binary ByRef ByVal Date Empty Error Friend Get
    1              0.000018 syn keyword vbKeyword Input Is Len Lock Me Mid New Nothing Null On
    1              0.000017 syn keyword vbKeyword Option Optional ParamArray Print Private Property
    1              0.000013 syn keyword vbKeyword Public PublicNotCreateable OnNewProcessSingleUse
    1              0.000013 syn keyword vbKeyword InSameProcessMultiUse GlobalMultiUse Resume Seek
    1              0.000013 syn keyword vbKeyword Set Static Step String Time WithEvents
                            
    1              0.000017 syn keyword vbTodo contained    TODO
                            
                            "Datatypes
    1              0.000023 syn keyword vbTypes Boolean Byte Currency Date Decimal Double Empty
    1              0.000014 syn keyword vbTypes Integer Long Object Single String Variant
                            
                            "VB defined values
    1              0.000018 syn keyword vbDefine dbBigInt dbBinary dbBoolean dbByte dbChar
    1              0.000014 syn keyword vbDefine dbCurrency dbDate dbDecimal dbDouble dbFloat
    1              0.000014 syn keyword vbDefine dbGUID dbInteger dbLong dbLongBinary dbMemo
    1              0.000014 syn keyword vbDefine dbNumeric dbSingle dbText dbTime dbTimeStamp
    1              0.000007 syn keyword vbDefine dbVarBinary
                            
                            "VB defined values
    1              0.000013 syn keyword vbDefine vb3DDKShadow vb3DFace vb3DHighlight vb3DLight
    1              0.000012 syn keyword vbDefine vb3DShadow vbAbort vbAbortRetryIgnore
    1              0.000012 syn keyword vbDefine vbActiveBorder vbActiveTitleBar vbAlias
    1              0.000012 syn keyword vbDefine vbApplicationModal vbApplicationWorkspace
    1              0.000013 syn keyword vbDefine vbAppTaskManager vbAppWindows vbArchive vbArray
    1              0.000013 syn keyword vbDefine vbBack vbBinaryCompare vbBlack vbBlue vbBoolean
    1              0.000012 syn keyword vbDefine vbButtonFace vbButtonShadow vbButtonText vbByte
    1              0.000013 syn keyword vbDefine vbCalGreg vbCalHijri vbCancel vbCr vbCritical
    1              0.000013 syn keyword vbDefine vbCrLf vbCurrency vbCyan vbDatabaseCompare
    1              0.000013 syn keyword vbDefine vbDataObject vbDate vbDecimal vbDefaultButton1
    1              0.000013 syn keyword vbDefine vbDefaultButton2 vbDefaultButton3 vbDefaultButton4
    1              0.000013 syn keyword vbDefine vbDesktop vbDirectory vbDouble vbEmpty vbError
    1              0.000012 syn keyword vbDefine vbExclamation vbFirstFourDays vbFirstFullWeek
    1              0.000012 syn keyword vbDefine vbFirstJan1 vbFormCode vbFormControlMenu
    1              0.000013 syn keyword vbDefine vbFormFeed vbFormMDIForm vbFriday vbFromUnicode
    1              0.000013 syn keyword vbDefine vbGrayText vbGreen vbHidden vbHide vbHighlight
    1              0.000013 syn keyword vbDefine vbHighlightText vbHiragana vbIgnore vbIMEAlphaDbl
    1              0.000011 syn keyword vbDefine vbIMEAlphaSng vbIMEDisable vbIMEHiragana
    1              0.000012 syn keyword vbDefine vbIMEKatakanaDbl vbIMEKatakanaSng vbIMEModeAlpha
    1              0.000010 syn keyword vbDefine vbIMEModeAlphaFull vbIMEModeDisable
    1              0.000010 syn keyword vbDefine vbIMEModeHangul vbIMEModeHangulFull
    1              0.000016 syn keyword vbDefine vbIMEModeHiragana vbIMEModeKatakana
    1              0.000036 syn keyword vbDefine vbIMEModeKatakanaHalf vbIMEModeNoControl
    1              0.000013 syn keyword vbDefine vbIMEModeOff vbIMEModeOn vbIMENoOp vbIMEOff
    1              0.000012 syn keyword vbDefine vbIMEOn vbInactiveBorder vbInactiveCaptionText
    1              0.000012 syn keyword vbDefine vbInactiveTitleBar vbInfoBackground vbInformation
    1              0.000013 syn keyword vbDefine vbInfoText vbInteger vbKatakana vbKey0 vbKey1
    1              0.000014 syn keyword vbDefine vbKey2 vbKey3 vbKey4 vbKey5 vbKey6 vbKey7 vbKey8
    1              0.000014 syn keyword vbDefine vbKey9 vbKeyA vbKeyAdd vbKeyB vbKeyBack vbKeyC
    1              0.000013 syn keyword vbDefine vbKeyCancel vbKeyCapital vbKeyClear vbKeyControl
    1              0.000013 syn keyword vbDefine vbKeyD vbKeyDecimal vbKeyDelete vbKeyDivide
    1              0.000014 syn keyword vbDefine vbKeyDown vbKeyE vbKeyEnd vbKeyEscape vbKeyExecute
    1              0.000014 syn keyword vbDefine vbKeyF vbKeyF1 vbKeyF10 vbKeyF11 vbKeyF12 vbKeyF13
    1              0.000014 syn keyword vbDefine vbKeyF14 vbKeyF15 vbKeyF16 vbKeyF2 vbKeyF3 vbKeyF4
    1              0.000013 syn keyword vbDefine vbKeyF5 vbKeyF6 vbKeyF7 vbKeyF8 vbKeyF9 vbKeyG
    1              0.000014 syn keyword vbDefine vbKeyH vbKeyHelp vbKeyHome vbKeyI vbKeyInsert
    1              0.000014 syn keyword vbDefine vbKeyJ vbKeyK vbKeyL vbKeyLButton vbKeyLeft vbKeyM
    1              0.000013 syn keyword vbDefine vbKeyMButton vbKeyMenu vbKeyMultiply vbKeyN
    1              0.000011 syn keyword vbDefine vbKeyNumlock vbKeyNumpad0 vbKeyNumpad1
    1              0.000011 syn keyword vbDefine vbKeyNumpad2 vbKeyNumpad3 vbKeyNumpad4
    1              0.000010 syn keyword vbDefine vbKeyNumpad5 vbKeyNumpad6 vbKeyNumpad7
    1              0.000012 syn keyword vbDefine vbKeyNumpad8 vbKeyNumpad9 vbKeyO vbKeyP
    1              0.000014 syn keyword vbDefine vbKeyPageDown vbKeyPageUp vbKeyPause vbKeyPrint
    1              0.000013 syn keyword vbDefine vbKeyQ vbKeyR vbKeyRButton vbKeyReturn vbKeyRight
    1              0.000013 syn keyword vbDefine vbKeyS vbKeySelect vbKeySeparator vbKeyShift
    1              0.000014 syn keyword vbDefine vbKeySnapshot vbKeySpace vbKeySubtract vbKeyT
    1              0.000015 syn keyword vbDefine vbKeyTab vbKeyU vbKeyUp vbKeyV vbKeyW vbKeyX
    1              0.000014 syn keyword vbDefine vbKeyY vbKeyZ vbLf vbLong vbLowerCase vbMagenta
    1              0.000016 syn keyword vbDefine vbMaximizedFocus vbMenuBar vbMenuText
    1              0.000012 syn keyword vbDefine vbMinimizedFocus vbMinimizedNoFocus vbMonday
    1              0.000012 syn keyword vbDefine vbMsgBox vbMsgBoxHelpButton vbMsgBoxRight
    1              0.000011 syn keyword vbDefine vbMsgBoxRtlReading vbMsgBoxSetForeground
    1              0.000013 syn keyword vbDefine vbMsgBoxText vbNarrow vbNewLine vbNo vbNormal
    1              0.000012 syn keyword vbDefine vbNormalFocus vbNormalNoFocus vbNull vbNullChar
    1              0.000012 syn keyword vbDefine vbNullString vbObject vbObjectError vbOK
    1              0.000013 syn keyword vbDefine vbOKCancel vbOKOnly vbProperCase vbQuestion
    1              0.000014 syn keyword vbDefine vbReadOnly vbRed vbRetry vbRetryCancel vbSaturday
    1              0.000013 syn keyword vbDefine vbScrollBars vbSingle vbString vbSunday vbSystem
    1              0.000012 syn keyword vbDefine vbSystemModal vbTab vbTextCompare vbThursday
    1              0.000021 syn keyword vbDefine vbTitleBarText vbTuesday vbUnicode vbUpperCase
    1              0.000012 syn keyword vbDefine vbUseSystem vbUseSystemDayOfWeek vbVariant
    1              0.000016 syn keyword vbDefine vbVerticalTab vbVolume vbWednesday vbWhite vbWide
    1              0.000013 syn keyword vbDefine vbWindowBackground vbWindowFrame vbWindowText
    1              0.000011 syn keyword vbDefine vbYellow vbYes vbYesNo vbYesNoCancel
                            
                            "Numbers
                            "integer number, or floating point number without a dot.
    1              0.000029 syn match vbNumber "\<\d\+\>"
                            "floating point number, with dot
    1              0.000027 syn match vbNumber "\<\d\+\.\d*\>"
                            "floating point number, starting with a dot
    1              0.000013 syn match vbNumber "\.\d\+\>"
                            "syn match  vbNumber            "{[[:xdigit:]-]\+}\|&[hH][[:xdigit:]]\+&"
                            "syn match  vbNumber            ":[[:xdigit:]]\+"
                            "syn match  vbNumber            "[-+]\=\<\d\+\>"
    1              0.000039 syn match  vbFloat              "[-+]\=\<\d\+[eE][\-+]\=\d\+"
    1              0.000027 syn match  vbFloat              "[-+]\=\<\d\+\.\d*\([eE][\-+]\=\d\+\)\="
    1              0.000032 syn match  vbFloat              "[-+]\=\<\.\d\+\([eE][\-+]\=\d\+\)\="
                            
                            " String and Character constants
    1              0.000032 syn region  vbString		start=+"+  end=+"\|$+
    1              0.000037 syn region  vbComment		start="\(^\|\s\)REM\s" end="$" contains=vbTodo
    1              0.000032 syn region  vbComment		start="\(^\|\s\)\'"   end="$" contains=vbTodo
    1              0.000017 syn match   vbLineLabel		"^\h\w\+:"
    1              0.000022 syn match   vbLineNumber	"^\d\+\(:\|\s\|$\)"
    1              0.000029 syn match   vbTypeSpecifier  "\<\a\w*[@\$%&!#]"ms=s+1
    1              0.000022 syn match   vbTypeSpecifier  "#[a-zA-Z0-9]"me=e-1
                            " Conditional Compilation
    1              0.000023 syn match  vbPreProc "^#const\>"
    1              0.000037 syn region vbPreProc matchgroup=PreProc start="^#if\>"     end="\<then\>" transparent contains=TOP
    1              0.000074 syn region vbPreProc matchgroup=PreProc start="^#elseif\>" end="\<then\>" transparent contains=TOP
    1              0.000018 syn match  vbPreProc "^#else\>"
    1              0.000018 syn match  vbPreProc "^#end\s*if\>"
                            
                            " Define the default highlighting.
                            " Only when an item doesn't have highlighting yet
                            
    1              0.000013 hi def link vbBoolean           Boolean
    1              0.000008 hi def link vbLineNumber        Comment
    1              0.000007 hi def link vbLineLabel         Comment
    1              0.000007 hi def link vbComment           Comment
    1              0.000008 hi def link vbConditional       Conditional
    1              0.000008 hi def link vbConst             Constant
    1              0.000007 hi def link vbDefine            Constant
    1              0.000010 hi def link vbError             Error
    1              0.000008 hi def link vbFunction          Identifier
    1              0.000009 hi def link vbIdentifier        Identifier
    1              0.000007 hi def link vbNumber            Number
    1              0.000007 hi def link vbFloat             Float
    1              0.000007 hi def link vbMethods           PreProc
    1              0.000007 hi def link vbOperator          Operator
    1              0.000006 hi def link vbRepeat            Repeat
    1              0.000006 hi def link vbString            String
    1              0.000008 hi def link vbStatement         Statement
    1              0.000008 hi def link vbKeyword           Statement
    1              0.000007 hi def link vbEvents            Special
    1              0.000008 hi def link vbTodo              Todo
    1              0.000006 hi def link vbTypes             Type
    1              0.000007 hi def link vbTypeSpecifier     Type
    1              0.000005 hi def link vbPreProc           PreProc
                            
    1              0.000023 let b:current_syntax = "vb"
                            
                            " vim: ts=8

SCRIPT  C:\Users\Lenovo\scoop\apps\neovim\0.6.1\share\nvim\runtime\syntax\vb.vim
Sourced 1 time
Total time:   0.000223
 Self time:   0.000223

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:	Visual Basic
                            " Maintainer:	Tim Chase <vb.vim@tim.thechases.com>
                            " Former Maintainer:	Robert M. Cortopassi <cortopar@mindspring.com>
                            "	(tried multiple times to contact, but email bounced)
                            " Last Change:
                            "   2005 May 25  Synched with work by Thomas Barthel
                            "   2004 May 30  Added a few keywords
                            
                            " This was thrown together after seeing numerous requests on the
                            " VIM and VIM-DEV mailing lists.  It is by no means complete.
                            " Send comments, suggestions and requests to the maintainer.
                            
                            " quit when a syntax file was already loaded
    1              0.000038 if exists("b:current_syntax")
    1              0.000007 	finish
                            endif
                            
                            " VB is case insensitive
                            syn case ignore
                            
                            syn keyword vbConditional If Then ElseIf Else Select Case
                            
                            syn keyword vbOperator AddressOf And ByRef ByVal Eqv Imp In
                            syn keyword vbOperator Is Like Mod Not Or To Xor
                            
                            syn match vbOperator "[()+.,\-/*=&]"
                            syn match vbOperator "[<>]=\="
                            syn match vbOperator "<>"
                            syn match vbOperator "\s\+_$"
                            
                            syn keyword vbBoolean  True False
                            syn keyword vbConst Null Nothing
                            
                            syn keyword vbRepeat Do For ForEach Loop Next
                            syn keyword vbRepeat Step To Until Wend While
                            
                            syn keyword vbEvents AccessKeyPress Activate ActiveRowChanged
                            syn keyword vbEvents AfterAddFile AfterChangeFileName AfterCloseFile
                            syn keyword vbEvents AfterColEdit AfterColUpdate AfterDelete
                            syn keyword vbEvents AfterInsert AfterLabelEdit AfterRemoveFile
                            syn keyword vbEvents AfterUpdate AfterWriteFile AmbientChanged
                            syn keyword vbEvents ApplyChanges Associate AsyncProgress
                            syn keyword vbEvents AsyncReadComplete AsyncReadProgress AxisActivated
                            syn keyword vbEvents AxisLabelActivated AxisLabelSelected
                            syn keyword vbEvents AxisLabelUpdated AxisSelected AxisTitleActivated
                            syn keyword vbEvents AxisTitleSelected AxisTitleUpdated AxisUpdated
                            syn keyword vbEvents BeforeClick BeforeColEdit BeforeColUpdate
                            syn keyword vbEvents BeforeConnect BeforeDelete BeforeInsert
                            syn keyword vbEvents BeforeLabelEdit BeforeLoadFile BeforeUpdate
                            syn keyword vbEvents BeginRequest BeginTrans ButtonClick
                            syn keyword vbEvents ButtonCompleted ButtonDropDown ButtonGotFocus
                            syn keyword vbEvents ButtonLostFocus CallbackKeyDown Change Changed
                            syn keyword vbEvents ChartActivated ChartSelected ChartUpdated Click
                            syn keyword vbEvents Close CloseQuery CloseUp ColEdit ColResize
                            syn keyword vbEvents Collapse ColumnClick CommitTrans Compare
                            syn keyword vbEvents ConfigChageCancelled ConfigChanged
                            syn keyword vbEvents ConfigChangedCancelled Connect ConnectionRequest
                            syn keyword vbEvents CurrentRecordChanged DECommandAdded
                            syn keyword vbEvents DECommandPropertyChanged DECommandRemoved
                            syn keyword vbEvents DEConnectionAdded DEConnectionPropertyChanged
                            syn keyword vbEvents DEConnectionRemoved DataArrival DataChanged
                            syn keyword vbEvents DataUpdated DateClicked DblClick Deactivate
                            syn keyword vbEvents DevModeChange DeviceArrival DeviceOtherEvent
                            syn keyword vbEvents DeviceQueryRemove DeviceQueryRemoveFailed
                            syn keyword vbEvents DeviceRemoveComplete DeviceRemovePending
                            syn keyword vbEvents Disconnect DisplayChanged Dissociate
                            syn keyword vbEvents DoGetNewFileName Done DonePainting DownClick
                            syn keyword vbEvents DragDrop DragOver DropDown EditProperty EditQuery
                            syn keyword vbEvents EndRequest EnterCell EnterFocus ExitFocus Expand
                            syn keyword vbEvents FontChanged FootnoteActivated FootnoteSelected
                            syn keyword vbEvents FootnoteUpdated Format FormatSize GotFocus
                            syn keyword vbEvents HeadClick HeightChanged Hide InfoMessage
                            syn keyword vbEvents IniProperties InitProperties Initialize
                            syn keyword vbEvents ItemActivated ItemAdded ItemCheck ItemClick
                            syn keyword vbEvents ItemReloaded ItemRemoved ItemRenamed
                            syn keyword vbEvents ItemSeletected KeyDown KeyPress KeyUp LeaveCell
                            syn keyword vbEvents LegendActivated LegendSelected LegendUpdated
                            syn keyword vbEvents LinkClose LinkError LinkExecute LinkNotify
                            syn keyword vbEvents LinkOpen Load LostFocus MouseDown MouseMove
                            syn keyword vbEvents MouseUp NodeCheck NodeClick OLECompleteDrag
                            syn keyword vbEvents OLEDragDrop OLEDragOver OLEGiveFeedback OLESetData
                            syn keyword vbEvents OLEStartDrag ObjectEvent ObjectMove OnAddNew
                            syn keyword vbEvents OnComm Paint PanelClick PanelDblClick PathChange
                            syn keyword vbEvents PatternChange PlotActivated PlotSelected
                            syn keyword vbEvents PlotUpdated PointActivated PointLabelActivated
                            syn keyword vbEvents PointLabelSelected PointLabelUpdated PointSelected
                            syn keyword vbEvents PointUpdated PowerQuerySuspend PowerResume
                            syn keyword vbEvents PowerStatusChanged PowerSuspend ProcessTag
                            syn keyword vbEvents ProcessingTimeout QueryChangeConfig QueryClose
                            syn keyword vbEvents QueryComplete QueryCompleted QueryTimeout
                            syn keyword vbEvents QueryUnload ReadProperties RepeatedControlLoaded
                            syn keyword vbEvents RepeatedControlUnloaded Reposition
                            syn keyword vbEvents RequestChangeFileName RequestWriteFile Resize
                            syn keyword vbEvents ResultsChanged RetainedProject RollbackTrans
                            syn keyword vbEvents RowColChange RowCurrencyChange RowResize
                            syn keyword vbEvents RowStatusChanged Scroll SelChange SelectionChanged
                            syn keyword vbEvents SendComplete SendProgress SeriesActivated
                            syn keyword vbEvents SeriesSelected SeriesUpdated SettingChanged Show
                            syn keyword vbEvents SplitChange Start StateChanged StatusUpdate
                            syn keyword vbEvents SysColorsChanged Terminate TimeChanged Timer
                            syn keyword vbEvents TitleActivated TitleSelected TitleUpdated
                            syn keyword vbEvents UnboundAddData UnboundDeleteRow
                            syn keyword vbEvents UnboundGetRelativeBookmark UnboundReadData
                            syn keyword vbEvents UnboundWriteData Unformat Unload UpClick Updated
                            syn keyword vbEvents UserEvent Validate ValidationError
                            syn keyword vbEvents VisibleRecordChanged WillAssociate WillChangeData
                            syn keyword vbEvents WillDissociate WillExecute WillUpdateRows
                            syn keyword vbEvents WriteProperties
                            
                            
                            syn keyword vbFunction Abs Array Asc AscB AscW Atn Avg BOF CBool CByte
                            syn keyword vbFunction CCur CDate CDbl CInt CLng CSng CStr CVDate CVErr
                            syn keyword vbFunction CVar CallByName Cdec Choose Chr ChrB ChrW Command
                            syn keyword vbFunction Cos Count CreateObject CurDir DDB Date DateAdd
                            syn keyword vbFunction DateDiff DatePart DateSerial DateValue Day Dir
                            syn keyword vbFunction DoEvents EOF Environ Error Exp FV FileAttr
                            syn keyword vbFunction FileDateTime FileLen FilterFix Fix Format
                            syn keyword vbFunction FormatCurrency FormatDateTime FormatNumber
                            syn keyword vbFunction FormatPercent FreeFile GetAllStrings GetAttr
                            syn keyword vbFunction GetAutoServerSettings GetObject GetSetting Hex
                            syn keyword vbFunction Hour IIf IMEStatus IPmt InStr Input InputB
                            syn keyword vbFunction InputBox InstrB Int IsArray IsDate IsEmpty IsError
                            syn keyword vbFunction IsMissing IsNull IsNumeric IsObject Join LBound
                            syn keyword vbFunction LCase LOF LTrim Left LeftB Len LenB LoadPicture
                            syn keyword vbFunction LoadResData LoadResPicture LoadResString Loc Log
                            syn keyword vbFunction MIRR Max Mid MidB Min Minute Month MonthName
                            syn keyword vbFunction MsgBox NPV NPer Now Oct PPmt PV Partition Pmt
                            syn keyword vbFunction QBColor RGB RTrim Rate Replace Right RightB Rnd
                            syn keyword vbFunction Round SLN SYD Second Seek Sgn Shell Sin Space Spc
                            syn keyword vbFunction Split Sqr StDev StDevP Str StrComp StrConv
                            syn keyword vbFunction StrReverse String Sum Switch Tab Tan Time
                            syn keyword vbFunction TimeSerial TimeValue Timer Trim TypeName UBound
                            syn keyword vbFunction UCase Val Var VarP VarType Weekday WeekdayName
                            syn keyword vbFunction Year
                            
                            syn keyword vbMethods AboutBox Accept Activate Add AddCustom AddFile
                            syn keyword vbMethods AddFromFile AddFromGuid AddFromString
                            syn keyword vbMethods AddFromTemplate AddItem AddNew AddToAddInToolbar
                            syn keyword vbMethods AddToolboxProgID Append AppendAppendChunk
                            syn keyword vbMethods AppendChunk Arrange Assert AsyncRead BatchUpdate
                            syn keyword vbMethods BeginQueryEdit BeginTrans Bind BuildPath
                            syn keyword vbMethods CanPropertyChange Cancel CancelAsyncRead
                            syn keyword vbMethods CancelBatch CancelUpdate CaptureImage CellText
                            syn keyword vbMethods CellValue Circle Clear ClearFields ClearSel
                            syn keyword vbMethods ClearSelCols ClearStructure Clone Close Cls
                            syn keyword vbMethods ColContaining CollapseAll ColumnSize CommitTrans
                            syn keyword vbMethods CompactDatabase Compose Connect Copy CopyFile
                            syn keyword vbMethods CopyFolder CopyQueryDef Count CreateDatabase
                            syn keyword vbMethods CreateDragImage CreateEmbed CreateField
                            syn keyword vbMethods CreateFolder CreateGroup CreateIndex CreateLink
                            syn keyword vbMethods CreatePreparedStatement CreatePropery CreateQuery
                            syn keyword vbMethods CreateQueryDef CreateRelation CreateTableDef
                            syn keyword vbMethods CreateTextFile CreateToolWindow CreateUser
                            syn keyword vbMethods CreateWorkspace Customize Cut Delete
                            syn keyword vbMethods DeleteColumnLabels DeleteColumns DeleteFile
                            syn keyword vbMethods DeleteFolder DeleteLines DeleteRowLabels
                            syn keyword vbMethods DeleteRows DeselectAll DesignerWindow DoVerb Drag
                            syn keyword vbMethods Draw DriveExists Edit EditCopy EditPaste EndDoc
                            syn keyword vbMethods EnsureVisible EstablishConnection Execute Exists
                            syn keyword vbMethods Expand Export ExportReport ExtractIcon Fetch
                            syn keyword vbMethods FetchVerbs FileExists Files FillCache Find
                            syn keyword vbMethods FindFirst FindItem FindLast FindNext FindPrevious
                            syn keyword vbMethods FolderExists Forward GetAbsolutePathName
                            syn keyword vbMethods GetBaseName GetBookmark GetChunk GetClipString
                            syn keyword vbMethods GetData GetDrive GetDriveName GetFile GetFileName
                            syn keyword vbMethods GetFirstVisible GetFolder GetFormat GetHeader
                            syn keyword vbMethods GetLineFromChar GetNumTicks GetParentFolderName
                            syn keyword vbMethods GetRows GetSelectedPart GetSelection
                            syn keyword vbMethods GetSpecialFolder GetTempName GetText
                            syn keyword vbMethods GetVisibleCount GoBack GoForward Hide HitTest
                            syn keyword vbMethods HoldFields Idle Import InitializeLabels Insert
                            syn keyword vbMethods InsertColumnLabels InsertColumns InsertFile
                            syn keyword vbMethods InsertLines InsertObjDlg InsertRowLabels
                            syn keyword vbMethods InsertRows Item Keys KillDoc Layout Line Lines
                            syn keyword vbMethods LinkExecute LinkPoke LinkRequest LinkSend Listen
                            syn keyword vbMethods LoadFile LoadResData LoadResPicture LoadResString
                            syn keyword vbMethods LogEvent MakeCompileFile MakeCompiledFile
                            syn keyword vbMethods MakeReplica MoreResults Move MoveData MoveFile
                            syn keyword vbMethods MoveFirst MoveFolder MoveLast MoveNext
                            syn keyword vbMethods MovePrevious NavigateTo NewPage NewPassword
                            syn keyword vbMethods NextRecordset OLEDrag OnAddinsUpdate OnConnection
                            syn keyword vbMethods OnDisconnection OnStartupComplete Open
                            syn keyword vbMethods OpenAsTextStream OpenConnection OpenDatabase
                            syn keyword vbMethods OpenQueryDef OpenRecordset OpenResultset OpenURL
                            syn keyword vbMethods Overlay PSet PaintPicture PastSpecialDlg Paste
                            syn keyword vbMethods PeekData Play Point PopulatePartial PopupMenu
                            syn keyword vbMethods Print PrintForm PrintReport PropertyChanged Quit
                            syn keyword vbMethods Raise RandomDataFill RandomFillColumns
                            syn keyword vbMethods RandomFillRows ReFill Read ReadAll ReadFromFile
                            syn keyword vbMethods ReadLine ReadProperty Rebind Refresh RefreshLink
                            syn keyword vbMethods RegisterDatabase ReleaseInstance Reload Remove
                            syn keyword vbMethods RemoveAddInFromToolbar RemoveAll RemoveItem Render
                            syn keyword vbMethods RepairDatabase ReplaceLine Reply ReplyAll Requery
                            syn keyword vbMethods ResetCustom ResetCustomLabel ResolveName
                            syn keyword vbMethods RestoreToolbar Resync Rollback RollbackTrans
                            syn keyword vbMethods RowBookmark RowContaining RowTop Save SaveAs
                            syn keyword vbMethods SaveFile SaveToFile SaveToOle1File SaveToolbar
                            syn keyword vbMethods Scale ScaleX ScaleY Scroll SelPrint SelectAll
                            syn keyword vbMethods SelectPart Send SendData Set SetAutoServerSettings
                            syn keyword vbMethods SetData SetFocus SetOption SetSelection SetSize
                            syn keyword vbMethods SetText SetViewport Show ShowColor ShowFont
                            syn keyword vbMethods ShowHelp ShowOpen ShowPrinter ShowSave
                            syn keyword vbMethods ShowWhatsThis SignOff SignOn Size Skip SkipLine
                            syn keyword vbMethods Span Split SplitContaining StartLabelEdit
                            syn keyword vbMethods StartLogging Stop Synchronize Tag TextHeight
                            syn keyword vbMethods TextWidth ToDefaults Trace TwipsToChartPart
                            syn keyword vbMethods TypeByChartType URLFor Update UpdateControls
                            syn keyword vbMethods UpdateRecord UpdateRow Upto ValidateControls Value
                            syn keyword vbMethods WhatsThisMode Write WriteBlankLines WriteLine
                            syn keyword vbMethods WriteProperty WriteTemplate ZOrder
                            syn keyword vbMethods rdoCreateEnvironment rdoRegisterDataSource
                            
                            syn keyword vbStatement Alias AppActivate As Base Beep Begin Call ChDir
                            syn keyword vbStatement ChDrive Close Const Date Declare DefBool DefByte
                            syn keyword vbStatement DefCur DefDate DefDbl DefDec DefInt DefLng DefObj
                            syn keyword vbStatement DefSng DefStr DefVar Deftype DeleteSetting Dim Do
                            syn keyword vbStatement Each ElseIf End Enum Erase Error Event Exit
                            syn keyword vbStatement Explicit FileCopy For ForEach Function Get GoSub
                            syn keyword vbStatement GoTo Gosub Implements Kill LSet Let Lib LineInput
                            syn keyword vbStatement Load Lock Loop Mid MkDir Name Next On OnError Open
                            syn keyword vbStatement Option Preserve Private Property Public Put RSet
                            syn keyword vbStatement RaiseEvent Randomize ReDim Redim Reset Resume
                            syn keyword vbStatement Return RmDir SavePicture SaveSetting Seek SendKeys
                            syn keyword vbStatement Sendkeys Set SetAttr Static Step Stop Sub Time
                            syn keyword vbStatement Type Unload Unlock Until Wend While Width With
                            syn keyword vbStatement Write
                            
                            syn keyword vbKeyword As Binary ByRef ByVal Date Empty Error Friend Get
                            syn keyword vbKeyword Input Is Len Lock Me Mid New Nothing Null On
                            syn keyword vbKeyword Option Optional ParamArray Print Private Property
                            syn keyword vbKeyword Public PublicNotCreateable OnNewProcessSingleUse
                            syn keyword vbKeyword InSameProcessMultiUse GlobalMultiUse Resume Seek
                            syn keyword vbKeyword Set Static Step String Time WithEvents
                            
                            syn keyword vbTodo contained	TODO
                            
                            "Datatypes
                            syn keyword vbTypes Boolean Byte Currency Date Decimal Double Empty
                            syn keyword vbTypes Integer Long Object Single String Variant
                            
                            "VB defined values
                            syn keyword vbDefine dbBigInt dbBinary dbBoolean dbByte dbChar
                            syn keyword vbDefine dbCurrency dbDate dbDecimal dbDouble dbFloat
                            syn keyword vbDefine dbGUID dbInteger dbLong dbLongBinary dbMemo
                            syn keyword vbDefine dbNumeric dbSingle dbText dbTime dbTimeStamp
                            syn keyword vbDefine dbVarBinary
                            
                            "VB defined values
                            syn keyword vbDefine vb3DDKShadow vb3DFace vb3DHighlight vb3DLight
                            syn keyword vbDefine vb3DShadow vbAbort vbAbortRetryIgnore
                            syn keyword vbDefine vbActiveBorder vbActiveTitleBar vbAlias
                            syn keyword vbDefine vbApplicationModal vbApplicationWorkspace
                            syn keyword vbDefine vbAppTaskManager vbAppWindows vbArchive vbArray
                            syn keyword vbDefine vbBack vbBinaryCompare vbBlack vbBlue vbBoolean
                            syn keyword vbDefine vbButtonFace vbButtonShadow vbButtonText vbByte
                            syn keyword vbDefine vbCalGreg vbCalHijri vbCancel vbCr vbCritical
                            syn keyword vbDefine vbCrLf vbCurrency vbCyan vbDatabaseCompare
                            syn keyword vbDefine vbDataObject vbDate vbDecimal vbDefaultButton1
                            syn keyword vbDefine vbDefaultButton2 vbDefaultButton3 vbDefaultButton4
                            syn keyword vbDefine vbDesktop vbDirectory vbDouble vbEmpty vbError
                            syn keyword vbDefine vbExclamation vbFirstFourDays vbFirstFullWeek
                            syn keyword vbDefine vbFirstJan1 vbFormCode vbFormControlMenu
                            syn keyword vbDefine vbFormFeed vbFormMDIForm vbFriday vbFromUnicode
                            syn keyword vbDefine vbGrayText vbGreen vbHidden vbHide vbHighlight
                            syn keyword vbDefine vbHighlightText vbHiragana vbIgnore vbIMEAlphaDbl
                            syn keyword vbDefine vbIMEAlphaSng vbIMEDisable vbIMEHiragana
                            syn keyword vbDefine vbIMEKatakanaDbl vbIMEKatakanaSng vbIMEModeAlpha
                            syn keyword vbDefine vbIMEModeAlphaFull vbIMEModeDisable
                            syn keyword vbDefine vbIMEModeHangul vbIMEModeHangulFull
                            syn keyword vbDefine vbIMEModeHiragana vbIMEModeKatakana
                            syn keyword vbDefine vbIMEModeKatakanaHalf vbIMEModeNoControl
                            syn keyword vbDefine vbIMEModeOff vbIMEModeOn vbIMENoOp vbIMEOff
                            syn keyword vbDefine vbIMEOn vbInactiveBorder vbInactiveCaptionText
                            syn keyword vbDefine vbInactiveTitleBar vbInfoBackground vbInformation
                            syn keyword vbDefine vbInfoText vbInteger vbKatakana vbKey0 vbKey1
                            syn keyword vbDefine vbKey2 vbKey3 vbKey4 vbKey5 vbKey6 vbKey7 vbKey8
                            syn keyword vbDefine vbKey9 vbKeyA vbKeyAdd vbKeyB vbKeyBack vbKeyC
                            syn keyword vbDefine vbKeyCancel vbKeyCapital vbKeyClear vbKeyControl
                            syn keyword vbDefine vbKeyD vbKeyDecimal vbKeyDelete vbKeyDivide
                            syn keyword vbDefine vbKeyDown vbKeyE vbKeyEnd vbKeyEscape vbKeyExecute
                            syn keyword vbDefine vbKeyF vbKeyF1 vbKeyF10 vbKeyF11 vbKeyF12 vbKeyF13
                            syn keyword vbDefine vbKeyF14 vbKeyF15 vbKeyF16 vbKeyF2 vbKeyF3 vbKeyF4
                            syn keyword vbDefine vbKeyF5 vbKeyF6 vbKeyF7 vbKeyF8 vbKeyF9 vbKeyG
                            syn keyword vbDefine vbKeyH vbKeyHelp vbKeyHome vbKeyI vbKeyInsert
                            syn keyword vbDefine vbKeyJ vbKeyK vbKeyL vbKeyLButton vbKeyLeft vbKeyM
                            syn keyword vbDefine vbKeyMButton vbKeyMenu vbKeyMultiply vbKeyN
                            syn keyword vbDefine vbKeyNumlock vbKeyNumpad0 vbKeyNumpad1
                            syn keyword vbDefine vbKeyNumpad2 vbKeyNumpad3 vbKeyNumpad4
                            syn keyword vbDefine vbKeyNumpad5 vbKeyNumpad6 vbKeyNumpad7
                            syn keyword vbDefine vbKeyNumpad8 vbKeyNumpad9 vbKeyO vbKeyP
                            syn keyword vbDefine vbKeyPageDown vbKeyPageUp vbKeyPause vbKeyPrint
                            syn keyword vbDefine vbKeyQ vbKeyR vbKeyRButton vbKeyReturn vbKeyRight
                            syn keyword vbDefine vbKeyS vbKeySelect vbKeySeparator vbKeyShift
                            syn keyword vbDefine vbKeySnapshot vbKeySpace vbKeySubtract vbKeyT
                            syn keyword vbDefine vbKeyTab vbKeyU vbKeyUp vbKeyV vbKeyW vbKeyX
                            syn keyword vbDefine vbKeyY vbKeyZ vbLf vbLong vbLowerCase vbMagenta
                            syn keyword vbDefine vbMaximizedFocus vbMenuBar vbMenuText
                            syn keyword vbDefine vbMinimizedFocus vbMinimizedNoFocus vbMonday
                            syn keyword vbDefine vbMsgBox vbMsgBoxHelpButton vbMsgBoxRight
                            syn keyword vbDefine vbMsgBoxRtlReading vbMsgBoxSetForeground
                            syn keyword vbDefine vbMsgBoxText vbNarrow vbNewLine vbNo vbNormal
                            syn keyword vbDefine vbNormalFocus vbNormalNoFocus vbNull vbNullChar
                            syn keyword vbDefine vbNullString vbObject vbObjectError vbOK
                            syn keyword vbDefine vbOKCancel vbOKOnly vbProperCase vbQuestion
                            syn keyword vbDefine vbReadOnly vbRed vbRetry vbRetryCancel vbSaturday
                            syn keyword vbDefine vbScrollBars vbSingle vbString vbSunday vbSystem
                            syn keyword vbDefine vbSystemModal vbTab vbTextCompare vbThursday
                            syn keyword vbDefine vbTitleBarText vbTuesday vbUnicode vbUpperCase
                            syn keyword vbDefine vbUseSystem vbUseSystemDayOfWeek vbVariant
                            syn keyword vbDefine vbVerticalTab vbVolume vbWednesday vbWhite vbWide
                            syn keyword vbDefine vbWindowBackground vbWindowFrame vbWindowText
                            syn keyword vbDefine vbYellow vbYes vbYesNo vbYesNoCancel
                            
                            "Numbers
                            "integer number, or floating point number without a dot.
                            syn match vbNumber "\<\d\+\>"
                            "floating point number, with dot
                            syn match vbNumber "\<\d\+\.\d*\>"
                            "floating point number, starting with a dot
                            syn match vbNumber "\.\d\+\>"
                            "syn match  vbNumber		"{[[:xdigit:]-]\+}\|&[hH][[:xdigit:]]\+&"
                            "syn match  vbNumber		":[[:xdigit:]]\+"
                            "syn match  vbNumber		"[-+]\=\<\d\+\>"
                            syn match  vbFloat		"[-+]\=\<\d\+[eE][\-+]\=\d\+"
                            syn match  vbFloat		"[-+]\=\<\d\+\.\d*\([eE][\-+]\=\d\+\)\="
                            syn match  vbFloat		"[-+]\=\<\.\d\+\([eE][\-+]\=\d\+\)\="
                            
                            " String and Character contstants
                            syn region  vbString		start=+"+  end=+"\|$+
                            syn region  vbComment		start="\(^\|\s\)REM\s" end="$" contains=vbTodo
                            syn region  vbComment		start="\(^\|\s\)\'"   end="$" contains=vbTodo
                            syn match   vbLineNumber	"^\d\+\(\s\|$\)"
                            syn match   vbTypeSpecifier  "[a-zA-Z0-9][\$%&!#]"ms=s+1
                            syn match   vbTypeSpecifier  "#[a-zA-Z0-9]"me=e-1
                            
                            " Define the default highlighting.
                            " Only when an item doesn't have highlighting yet
                            
                            hi def link vbBoolean		Boolean
                            hi def link vbLineNumber		Comment
                            hi def link vbComment		Comment
                            hi def link vbConditional	Conditional
                            hi def link vbConst			Constant
                            hi def link vbDefine			Constant
                            hi def link vbError			Error
                            hi def link vbFunction		Identifier
                            hi def link vbIdentifier		Identifier
                            hi def link vbNumber			Number
                            hi def link vbFloat			Float
                            hi def link vbMethods		PreProc
                            hi def link vbOperator		Operator
                            hi def link vbRepeat			Repeat
                            hi def link vbString			String
                            hi def link vbStatement		Statement
                            hi def link vbKeyword		Statement
                            hi def link vbEvents			Special
                            hi def link vbTodo			Todo
                            hi def link vbTypes			Type
                            hi def link vbTypeSpecifier	Type
                            
                            
                            let b:current_syntax = "vb"
                            
                            " vim: ts=8

SCRIPT  C:\Users\Lenovo\AppData\Local\nvim-data\plugged\vim-polyglot\syntax\css.vim
Sourced 1 time
Total time:   0.058465
 Self time:   0.058353

count  total (s)   self (s)
    1   0.000536   0.000424 if polyglot#init#is_disabled(expand('<sfile>:p'), 'css', 'syntax/css.vim')
                              finish
    1              0.000004 endif
                            
                            " Vim syntax file
                            " Language:     Cascading Style Sheets
                            " Previous Contributor List:
                            "               Jules Wang      <w.jq0722@gmail.com>
                            "               Claudio Fleiner <claudio@fleiner.com>
                            "               Yeti            (Add full CSS2, HTML4 support)
                            "               Nikolai Weibull (Add CSS2 support)
                            " URL:          https://github.com/vim-language-dept/css-syntax.vim
                            " Maintainer:   Jay Sitter <jay@jaysitter.com>
                            " Last Change:  2021 Oct 20
                            
                            " quit when a syntax file was already loaded
    1              0.000014 if !exists("main_syntax")
                              if exists("b:current_syntax")
                                finish
                              endif
                              let main_syntax = 'css'
    1              0.000015 elseif exists("b:current_syntax") && b:current_syntax == "css"
                              finish
    1              0.000003 endif
                            
    1              0.000025 let s:cpo_save = &cpo
    1              0.000031 set cpo&vim
                            
    1              0.000012 syn case ignore
                            " Add dash to allowed keyword characters.
    1              0.000036 syn iskeyword @,48-57,_,192-255,-
                            
                            " HTML4 tags
    1              0.000074 syn keyword cssTagName abbr address area a b base
    1              0.000018 syn keyword cssTagName bdo blockquote body br button
    1              0.000019 syn keyword cssTagName caption cite code col colgroup dd del
    1              0.000016 syn keyword cssTagName dfn div dl dt em fieldset form
    1              0.000016 syn keyword cssTagName h1 h2 h3 h4 h5 h6 head hr html img i
    1              0.000017 syn keyword cssTagName iframe input ins isindex kbd label legend li
    1              0.000016 syn keyword cssTagName link map menu meta noscript ol optgroup
    1              0.000018 syn keyword cssTagName option p param picture pre q s samp script small
    1              0.000014 syn keyword cssTagName span strong sub sup tbody td
    1              0.000016 syn keyword cssTagName textarea tfoot th thead title tr ul u var
    1              0.000009 syn keyword cssTagName object svg
    1              0.000045 syn match   cssTagName /\<select\>\|\<style\>\|\<table\>/
                            
                            " 34 HTML5 tags
    1              0.000022 syn keyword cssTagName article aside audio bdi canvas command data
    1              0.000017 syn keyword cssTagName datalist details dialog embed figcaption figure footer
    1              0.000015 syn keyword cssTagName header hgroup keygen main mark menuitem meter nav
    1              0.000013 syn keyword cssTagName output progress rt rp ruby section
    1              0.000013 syn keyword cssTagName source summary time track video wbr
                            
                            " Tags not supported in HTML5
                            " acronym applet basefont big center dir
                            " font frame frameset noframes strike tt
                            
    1              0.000012 syn match cssTagName "\*"
                            
                            " selectors
    1              0.000018 syn match cssSelectorOp "[,>+~]"
    1              0.000024 syn match cssSelectorOp2 "[~|^$*]\?=" contained
    1              0.000047 syn region cssAttributeSelector matchgroup=cssSelectorOp start="\[" end="]" contains=cssUnicodeEscape,cssSelectorOp2,cssStringQ,cssStringQQ
                            
                            " .class and #id
    1              0.000029 syn match cssClassName "\.-\=[A-Za-z_][A-Za-z0-9_-]*" contains=cssClassNameDot
    1              0.000010 syn match cssClassNameDot contained '\.'
                            
    1              0.000005 try
    1              0.000044 syn match cssIdentifier "#[A-Za-z\u00ac-\uffff_@][A-Za-z\u00ac-\uffff0-9_@-]*"
                            catch /^.*/
                            syn match cssIdentifier "#[A-Za-z_@][A-Za-z0-9_@-]*"
    1              0.000006 endtry
                            
                            " digits
    1              0.000047 syn match cssValueInteger contained "[-+]\=\d\+" contains=cssUnitDecorators
    1              0.000028 syn match cssValueNumber contained "[-+]\=\d\+\(\.\d*\)\=" contains=cssUnitDecorators
    1              0.000063 syn match cssValueLength contained "[-+]\=\d\+\(\.\d*\)\=\(mm\|cm\|in\|pt\|pc\|em\|ex\|px\|rem\|dpi\|dppx\|dpcm\|fr\|vw\|vh\|vmin\|vmax\|ch\)\>" contains=cssUnitDecorators
    1              0.000023 syn match cssValueLength contained "[-+]\=\d\+\(\.\d*\)\=%" contains=cssUnitDecorators
    1              0.000027 syn match cssValueAngle contained "[-+]\=\d\+\(\.\d*\)\=\(deg\|grad\|rad\)\>" contains=cssUnitDecorators
    1              0.000036 syn match cssValueTime contained "+\=\d\+\(\.\d*\)\=\(ms\|s\)\>" contains=cssUnitDecorators
    1              0.000030 syn match cssValueFrequency contained "+\=\d\+\(\.\d*\)\=\(Hz\|kHz\)\>" contains=cssUnitDecorators
                            
                            " The 16 basic color names
    1              0.000029 syn keyword cssColor contained aqua black blue fuchsia gray green lime maroon navy olive purple red silver teal yellow
                            
                            " 130 more color names
    1              0.000214 syn keyword cssColor contained aliceblue antiquewhite aquamarine azure
    1              0.000018 syn keyword cssColor contained beige bisque blanchedalmond blueviolet brown burlywood
    1              0.000021 syn keyword cssColor contained cadetblue chartreuse chocolate coral cornflowerblue cornsilk crimson cyan
    1              0.000036 syn match cssColor contained /\<dark\(blue\|cyan\|goldenrod\|gray\|green\|grey\|khaki\)\>/
    1              0.000080 syn match cssColor contained /\<dark\(magenta\|olivegreen\|orange\|orchid\|red\|salmon\|seagreen\)\>/
    1              0.000022 syn match cssColor contained /\<darkslate\(blue\|gray\|grey\)\>/
    1              0.000019 syn match cssColor contained /\<dark\(turquoise\|violet\)\>/
    1              0.000019 syn keyword cssColor contained deeppink deepskyblue dimgray dimgrey dodgerblue firebrick
    1              0.000015 syn keyword cssColor contained floralwhite forestgreen gainsboro ghostwhite gold
    1              0.000015 syn keyword cssColor contained goldenrod greenyellow grey honeydew hotpink
    1              0.000016 syn keyword cssColor contained indianred indigo ivory khaki lavender lavenderblush lawngreen
    1              0.000012 syn keyword cssColor contained lemonchiffon limegreen linen magenta
    1              0.000029 syn match cssColor contained /\<light\(blue\|coral\|cyan\|goldenrodyellow\|gray\|green\)\>/
    1              0.000028 syn match cssColor contained /\<light\(grey\|pink\|salmon\|seagreen\|skyblue\|yellow\)\>/
    1              0.000023 syn match cssColor contained /\<light\(slategray\|slategrey\|steelblue\)\>/
    1              0.000026 syn match cssColor contained /\<medium\(aquamarine\|blue\|orchid\|purple\|seagreen\)\>/
    1              0.000025 syn match cssColor contained /\<medium\(slateblue\|springgreen\|turquoise\|violetred\)\>/
    1              0.000014 syn keyword cssColor contained midnightblue mintcream mistyrose moccasin navajowhite
    1              0.000014 syn keyword cssColor contained oldlace olivedrab orange orangered orchid
    1              0.000026 syn match cssColor contained /\<pale\(goldenrod\|green\|turquoise\|violetred\)\>/
    1              0.000014 syn keyword cssColor contained papayawhip peachpuff peru pink plum powderblue
    1              0.000016 syn keyword cssColor contained rosybrown royalblue rebeccapurple saddlebrown salmon
    1              0.000015 syn keyword cssColor contained sandybrown seagreen seashell sienna skyblue slateblue
    1              0.000015 syn keyword cssColor contained slategray slategrey snow springgreen steelblue tan
    1              0.000013 syn keyword cssColor contained thistle tomato turquoise violet wheat
    1              0.000008 syn keyword cssColor contained whitesmoke yellowgreen
                            
                            " FIXME: These are actually case-insensitive too, but (a) specs recommend using
                            " mixed-case (b) it's hard to highlight the word `Background' correctly in
                            " all situations
    1              0.000016 syn case match
    1              0.000054 syn keyword cssColor contained ActiveBorder ActiveCaption AppWorkspace ButtonFace ButtonHighlight ButtonShadow ButtonText CaptionText GrayText Highlight HighlightText InactiveBorder InactiveCaption InactiveCaptionText InfoBackground InfoText Menu MenuText Scrollbar ThreeDDarkShadow ThreeDFace ThreeDHighlight ThreeDLightShadow ThreeDShadow Window WindowFrame WindowText Background
    1              0.000007 syn case ignore
                            
    1              0.000020 syn match cssImportant contained "!\s*important\>"
    1              0.000019 syn match cssCustomProp contained "\<--[a-zA-Z0-9-_]*\>"
                            
    1              0.000015 syn match cssColor contained "\<transparent\>"
    1              0.000027 syn match cssColor contained "\<currentColor\>"
    1              0.000015 syn match cssColor contained "\<white\>"
    1              0.000024 syn match cssColor contained "#\x\{3,4\}\>" contains=cssUnitDecorators
    1              0.000018 syn match cssColor contained "#\x\{6\}\>" contains=cssUnitDecorators
    1              0.000017 syn match cssColor contained "#\x\{8\}\>" contains=cssUnitDecorators
                            
    1              0.000051 syn region cssURL contained matchgroup=cssFunctionName start="\<\(uri\|url\|local\|format\)\s*(" end=")" contains=cssStringQ,cssStringQQ oneline
    1              0.003092 syn region cssMathGroup contained matchgroup=cssMathParens start="(" end=")" containedin=cssFunction,cssMathGroup contains=cssCustomProp,cssValue.*,cssFunction,cssColor,cssStringQ,cssStringQQ oneline
    1              0.003000 syn region cssFunction contained matchgroup=cssFunctionName start="\<\(var\|calc\)\s*(" end=")" contains=cssCustomProp,cssValue.*,cssFunction,cssColor,cssStringQ,cssStringQQ oneline
    1              0.000088 syn region cssFunction contained matchgroup=cssFunctionName start="\<\(rgb\|clip\|attr\|counter\|rect\|cubic-bezier\|steps\)\s*(" end=")" oneline  contains=cssValueInteger,cssValueNumber,cssValueLength,cssFunctionComma
    1              0.000059 syn region cssFunction contained matchgroup=cssFunctionName start="\<\(rgba\|hsl\|hsla\|color-stop\|from\|to\)\s*(" end=")" oneline  contains=cssColor,cssValueInteger,cssValueNumber,cssValueLength,cssFunctionComma,cssFunction
    1              0.000115 syn region cssFunction contained matchgroup=cssFunctionName start="\<\(linear-\|radial-\|conic-\)\=\gradient\s*(" end=")" oneline  contains=cssColor,cssValueInteger,cssValueNumber,cssValueLength,cssFunction,cssGradientAttr,cssFunctionComma
    1              0.000076 syn region cssFunction contained matchgroup=cssFunctionName start="\<\(matrix\(3d\)\=\|scale\(3d\|X\|Y\|Z\)\=\|translate\(3d\|X\|Y\|Z\)\=\|skew\(X\|Y\)\=\|rotate\(3d\|X\|Y\|Z\)\=\|perspective\)\s*(" end=")" oneline contains=cssValueInteger,cssValueNumber,cssValueLength,cssValueAngle,cssFunctionComma
    1              0.000069 syn region cssFunction contained matchgroup=cssFunctionName start="\<\(blur\|brightness\|contrast\|drop-shadow\|grayscale\|hue-rotate\|invert\|opacity\|saturate\|sepia\)\s*(" end=")" oneline contains=cssValueInteger,cssValueNumber,cssValueLength,cssValueAngle,cssFunctionComma
    1              0.000024 syn keyword cssGradientAttr contained top bottom left right cover center middle ellipse at
    1              0.000011 syn match cssFunctionComma contained ","
                            
                            " Common Prop and Attr
    1              0.000018 syn keyword cssCommonAttr contained auto none inherit all default normal
    1              0.000015 syn keyword cssCommonAttr contained top bottom center stretch hidden visible
    1              0.000035 syn match cssCommonAttr contained "\<\(max-\|min-\|fit-\)content\>"
                            "------------------------------------------------
                            " CSS Animations
                            " http://www.w3.org/TR/css3-animations/
    1              0.000058 syn match cssAnimationProp contained "\<animation\(-\(delay\|direction\|duration\|fill-mode\|name\|play-state\|timing-function\|iteration-count\)\)\=\>"
                            
                            " animation-direction attributes
    1              0.000012 syn keyword cssAnimationAttr contained alternate reverse
    1              0.000030 syn match cssAnimationAttr contained "\<alternate-reverse\>"
                            
                            " animation-fill-mode attributes
    1              0.000010 syn keyword cssAnimationAttr contained forwards backwards both
                            
                            " animation-play-state attributes
    1              0.000008 syn keyword cssAnimationAttr contained running paused
                            
                            " animation-iteration-count attributes
    1              0.000008 syn keyword cssAnimationAttr contained infinite
                            "------------------------------------------------
                            "  CSS Backgrounds and Borders Module Level 3
                            "  http://www.w3.org/TR/css3-background/
    1              0.000036 syn match cssBackgroundProp contained "\<background\(-\(attachment\|clip\|color\|image\|origin\|position\|repeat\|size\)\)\=\>"
                            " background-attachment attributes
    1              0.000012 syn keyword cssBackgroundAttr contained scroll fixed local
                            
                            " background-position attributes
    1              0.000025 syn keyword cssBackgroundAttr contained left center right top bottom
                            
                            " background-repeat attributes
    1              0.000016 syn match cssBackgroundAttr contained "\<no-repeat\>"
    1              0.000018 syn match cssBackgroundAttr contained "\<repeat\(-[xy]\)\=\>"
                            
                            " background-size attributes
    1              0.000009 syn keyword cssBackgroundAttr contained cover contain
                            
    1              0.000033 syn match cssBorderProp contained "\<border\(-\(top\|right\|bottom\|left\)\)\=\(-\(width\|color\|style\)\)\=\>"
    1              0.000027 syn match cssBorderProp contained "\<border\(-\(top\|bottom\)-\(left\|right\)\)\=-radius\>"
    1              0.000028 syn match cssBorderProp contained "\<border-image\(-\(outset\|repeat\|slice\|source\|width\)\)\=\>"
    1              0.000018 syn match cssBorderProp contained "\<box-decoration-break\>"
    1              0.000013 syn match cssBorderProp contained "\<box-shadow\>"
                            
                            " border-image attributes
    1              0.000012 syn keyword cssBorderAttr contained stretch round fill
                            
                            " border-style attributes
    1              0.000016 syn keyword cssBorderAttr contained dotted dashed solid double groove ridge inset outset
                            
                            " border-width attributes
    1              0.000008 syn keyword cssBorderAttr contained thin thick medium
                            
                            " box-decoration-break attributes
    1              0.000008 syn keyword cssBorderAttr contained clone slice
                            "------------------------------------------------
                            
    1              0.000026 syn match cssBoxProp contained "\<padding\(-\(top\|right\|bottom\|left\)\)\=\>"
    1              0.000026 syn match cssBoxProp contained "\<margin\(-\(top\|right\|bottom\|left\)\)\=\>"
    1              0.000032 syn match cssBoxProp contained "\<overflow\(-\(x\|y\|style\)\)\=\>"
    1              0.000016 syn match cssBoxProp contained "\<rotation\(-point\)\=\>"
    1              0.000014 syn keyword cssBoxAttr contained visible hidden scroll auto
    1              0.000022 syn match cssBoxAttr contained "\<no-\(display\|content\)\>"
                            
    1              0.000010 syn keyword cssCascadeProp contained all
    1              0.000011 syn keyword cssCascadeAttr contained initial unset revert
                            
    1              0.000009 syn keyword cssColorProp contained opacity
    1              0.000015 syn match cssColorProp contained "\<color-profile\>"
    1              0.000016 syn match cssColorProp contained "\<rendering-intent\>"
                            
                            
    1              0.000021 syn match cssDimensionProp contained "\<\(min\|max\)-\(width\|height\)\>"
    1              0.000008 syn keyword cssDimensionProp contained height
    1              0.000006 syn keyword cssDimensionProp contained width
                            
                            " CSS Flexible Box Layout Module Level 1
                            " http://www.w3.org/TR/css3-flexbox/
                            " CSS Box Alignment Module Level 3
                            " http://www.w3.org/TR/css-align-3/
    1              0.000033 syn match cssFlexibleBoxProp contained "\<flex\(-\(direction\|wrap\|flow\|grow\|shrink\|basis\)\)\=\>"
    1              0.000026 syn match cssFlexibleBoxProp contained "\<\(align\|justify\)\(-\(items\|self\|content\)\)\=\>"
    1              0.000008 syn keyword cssFlexibleBoxProp contained order
                            
    1              0.000023 syn match cssFlexibleBoxAttr contained "\<\(row\|column\|wrap\)\(-reverse\)\=\>"
    1              0.000013 syn keyword cssFlexibleBoxAttr contained nowrap stretch baseline center
    1              0.000019 syn match cssFlexibleBoxAttr contained "\<flex\(-\(start\|end\)\)\=\>"
    1              0.000021 syn match cssFlexibleBoxAttr contained "\<space\(-\(between\|around\|evenly\)\)\=\>"
                            
                            " CSS Fonts Module Level 3
                            " http://www.w3.org/TR/css-fonts-3/
    1              0.000074 syn match cssFontProp contained "\<font\(-\(family\|\|feature-settings\|kerning\|language-override\|size\(-adjust\)\=\|stretch\|style\|synthesis\|variant\(-\(alternates\|caps\|east-asian\|ligatures\|numeric\|position\)\)\=\|weight\)\)\=\>"
                            
                            " font attributes
    1              0.000012 syn keyword cssFontAttr contained icon menu caption
    1              0.000015 syn match cssFontAttr contained "\<message-box\>"
    1              0.000013 syn match cssFontAttr contained "\<status-bar\>"
    1              0.000009 syn keyword cssFontAttr contained larger smaller
    1              0.000025 syn match cssFontAttr contained "\<\(x\{1,2\}-\)\=\(large\|small\)\>"
    1              0.000017 syn match cssFontAttr contained "\<small-\(caps\|caption\)\>"
                            " font-family attributes
    1              0.000014 syn keyword cssFontAttr contained sans-serif serif cursive fantasy monospace
                            " font-feature-settings attributes
    1              0.000008 syn keyword cssFontAttr contained on off
                            " font-stretch attributes
    1              0.000067 syn match cssFontAttr contained "\<\(\(ultra\|extra\|semi\)-\)\=\(condensed\|expanded\)\>"
                            " font-style attributes
    1              0.000010 syn keyword cssFontAttr contained italic oblique
                            " font-synthesis attributes
    1              0.000008 syn keyword cssFontAttr contained weight style
                            " font-weight attributes
    1              0.000021 syn keyword cssFontAttr contained bold bolder lighter
                            " TODO: font-variant-* attributes
                            "------------------------------------------------
                            
                            " Webkit specific property/attributes
    1              0.000016 syn match cssFontProp contained "\<font-smooth\>"
    1              0.000031 syn match cssFontAttr contained "\<\(subpixel-\)\=\antialiased\>"
                            
                            
                            " CSS Multi-column Layout Module
                            " http://www.w3.org/TR/css3-multicol/
    1              0.000023 syn match cssMultiColumnProp contained "\<break-\(after\|before\|inside\)\>"
    1              0.000033 syn match cssMultiColumnProp contained "\<column-\(count\|fill\|gap\|rule\(-\(color\|style\|width\)\)\=\|span\|width\)\>"
    1              0.000008 syn keyword cssMultiColumnProp contained columns
    1              0.000010 syn keyword cssMultiColumnAttr contained balance medium
    1              0.000014 syn keyword cssMultiColumnAttr contained always left right page column
    1              0.000024 syn match cssMultiColumnAttr contained "\<avoid\(-\(page\|column\)\)\=\>"
                            
                            " http://www.w3.org/TR/css3-break/#page-break
    1              0.000023 syn match cssMultiColumnProp contained "\<page\(-break-\(before\|after\|inside\)\)\=\>"
                            
                            " http://www.w3.org/TR/SVG11/interact.html
    1              0.000017 syn match cssInteractProp contained "\<pointer-events\>"
    1              0.000022 syn match cssInteractAttr contained "\<\(visible\)\=\(Painted\|Fill\|Stroke\)\=\>"
                            
                            " TODO find following items in w3c docs.
    1              0.000012 syn keyword cssGeneratedContentProp contained quotes crop
    1              0.000019 syn match cssGeneratedContentProp contained "\<counter-\(reset\|increment\)\>"
    1              0.000014 syn match cssGeneratedContentProp contained "\<move-to\>"
    1              0.000014 syn match cssGeneratedContentProp contained "\<page-policy\>"
    1              0.000032 syn match cssGeneratedContentAttr contained "\<\(no-\)\=\(open\|close\)-quote\>"
                            
                            " https://www.w3.org/TR/css-grid-1/
    1              0.000015 syn match cssGridProp contained "\<grid\>"
    1              0.000036 syn match cssGridProp contained "\<grid-template\(-\(columns\|rows\|areas\)\)\=\>"
    1              0.000036 syn match cssGridProp contained "\<grid-\(column\|row\)\(-\(start\|end\|gap\)\)\=\>"
    1              0.000016 syn match cssGridProp contained "\<grid-\(area\|gap\)\>"
    1              0.000012 syn match cssGridProp contained "\<gap\>"
    1              0.000030 syn match cssGridProp contained "\<grid-auto-\(flow\|rows\|columns\)\>"
                            
    1              0.000019 syn match cssHyerlinkProp contained "\<target\(-\(name\|new\|position\)\)\=\>"
                            
    1              0.000023 syn match cssListProp contained "\<list-style\(-\(type\|position\|image\)\)\=\>"
    1              0.000027 syn match cssListAttr contained "\<\(lower\|upper\)-\(roman\|alpha\|greek\|latin\)\>"
    1              0.000021 syn match cssListAttr contained "\<\(hiragana\|katakana\)\(-iroha\)\=\>"
    1              0.000174 syn match cssListAttr contained "\<\(decimal\(-leading-zero\)\=\|cjk-ideographic\)\>"
    1              0.000094 syn keyword cssListAttr contained disc circle square hebrew armenian georgian
    1              0.000012 syn keyword cssListAttr contained inside outside
                            
                            " object-fit https://www.w3.org/TR/css-images-3/#the-object-fit
    1              0.000025 syn match cssObjectProp contained "\<object-\(fit\|position\)\>"
    1              0.000015 syn keyword cssObjectAttr contained fill contain cover scale-down
                            
    1              0.000016 syn keyword cssPositioningProp contained bottom clear clip display float left
    1              0.000013 syn keyword cssPositioningProp contained position right top visibility
    1              0.000023 syn match cssPositioningProp contained "\<z-index\>"
    1              0.000016 syn keyword cssPositioningAttr contained block compact grid
    1              0.000040 syn match cssPositioningAttr contained "\<table\(-\(row-group\|\(header\|footer\)-group\|row\|column\(-group\)\=\|cell\|caption\)\)\=\>"
    1              0.000010 syn keyword cssPositioningAttr contained left right both
    1              0.000015 syn match cssPositioningAttr contained "\<list-item\>"
    1              0.000023 syn match cssPositioningAttr contained "\<inline\(-\(block\|box\|table\|grid\|flex\)\)\=\>"
    1              0.000016 syn match cssPositioningAttr contained "\<flow\(-root\)\=\>"
    1              0.000014 syn keyword cssPositioningAttr contained static relative absolute fixed subgrid sticky
                            
    1              0.000019 syn keyword cssPrintAttr contained landscape portrait crop cross always
                            
    1              0.000095 syn match cssTableProp contained "\<\(caption-side\|table-layout\|border-collapse\|border-spacing\|empty-cells\)\>"
    1              0.000017 syn keyword cssTableAttr contained fixed collapse separate show hide once always
                            
                            
    1              0.000014 syn keyword cssTextProp contained color direction hyphens
    1              0.000077 syn match cssTextProp "\<\(\(word\|letter\)-spacing\|text\(-\(decoration\|transform\|align\|index\|shadow\)\)\=\|vertical-align\|unicode-bidi\|line-height\)\>"
    1              0.000041 syn match cssTextProp contained "\<text-\(justify\|outline\|warp\|align-last\|size-adjust\|rendering\|stroke\|indent\)\>"
    1              0.000041 syn match cssTextProp contained "\<\(word\|line\)-break\|\(overflow\|word\)-wrap\>"
    1              0.000015 syn match cssTextProp contained "\<white-space\>"
    1              0.000064 syn match cssTextProp contained "\<hanging-punctuation\>"
    1              0.000015 syn match cssTextProp contained "\<tab-size\>"
    1              0.000015 syn match cssTextProp contained "\<punctuation-trim\>"
    1              0.000015 syn match cssTextAttr contained "\<line-through\>"
    1              0.000022 syn match cssTextAttr contained "\<\(text-\)\=\(top\|bottom\)\>"
    1              0.000012 syn keyword cssTextAttr contained ltr rtl embed nowrap
    1              0.000015 syn keyword cssTextAttr contained underline overline blink sub super middle
    1              0.000011 syn keyword cssTextAttr contained capitalize uppercase lowercase
    1              0.000011 syn keyword cssTextAttr contained justify baseline sub super
    1              0.000015 syn keyword cssTextAttr contained optimizeLegibility optimizeSpeed geometricPrecision
    1              0.000018 syn match cssTextAttr contained "\<pre\(-\(line\|wrap\)\)\=\>"
    1              0.000016 syn match cssTextAttr contained "\<\(allow\|force\)-end\>"
    1              0.000012 syn keyword cssTextAttr contained start end adjacent
    1              0.000021 syn match cssTextAttr contained "\<inter-\(word\|ideographic\|cluster\)\>"
    1              0.000012 syn keyword cssTextAttr contained distribute kashida first last
    1              0.000012 syn keyword cssTextAttr contained clip ellipsis unrestricted suppress
    1              0.000015 syn match cssTextAttr contained "\<break-all\>"
    1              0.000013 syn match cssTextAttr contained "\<break-word\>"
    1              0.000007 syn keyword cssTextAttr contained manual
    1              0.000014 syn match cssTextAttr contained "\<bidi-override\>"
                            
    1              0.000023 syn match cssTransformProp contained "\<transform\(-\(origin\|style\)\)\=\>"
    1              0.000018 syn match cssTransformProp contained "\<perspective\(-origin\)\=\>"
    1              0.000020 syn match cssTransformProp contained "\<backface-visibility\>"
                            
                            " CSS Transitions
                            " http://www.w3.org/TR/css3-transitions/
    1              0.000029 syn match cssTransitionProp contained "\<transition\(-\(delay\|duration\|property\|timing-function\)\)\=\>"
                            
                            " transition-time-function attributes
    1              0.000019 syn match cssTransitionAttr contained "\<linear\(-gradient\)\@!\>"
    1              0.000041 syn match cssTransitionAttr contained "\<ease\(-\(in-out\|out\|in\)\)\=\>"
    1              0.000017 syn match cssTransitionAttr contained "\<step\(-start\|-end\)\=\>"
                            "------------------------------------------------
                            " CSS Basic User Interface Module Level 3 (CSS3 UI)
                            " http://www.w3.org/TR/css3-ui/
    1              0.000019 syn match cssUIProp contained "\<box-sizing\>"
    1              0.000022 syn match cssUIAttr contained "\<\(content\|padding\|border\)\(-box\)\=\>"
                            
    1              0.000008 syn keyword cssUIProp contained cursor
    1              0.000076 syn match cssUIAttr contained "\<\(\([ns]\=[ew]\=\)\|col\|row\|nesw\|nwse\)-resize\>"
    1              0.000016 syn keyword cssUIAttr contained crosshair help move pointer alias copy
    1              0.000012 syn keyword cssUIAttr contained progress wait text cell move
    1              0.000014 syn match cssUIAttr contained "\<context-menu\>"
    1              0.000014 syn match cssUIAttr contained "\<no-drop\>"
    1              0.000013 syn match cssUIAttr contained "\<not-allowed\>"
    1              0.000012 syn match cssUIAttr contained "\<all-scroll\>"
    1              0.000040 syn match cssUIAttr contained "\<\(vertical-\)\=text\>"
    1              0.000015 syn match cssUIAttr contained "\<zoom\(-in\|-out\)\=\>"
                            
    1              0.000014 syn match cssUIProp contained "\<ime-mode\>"
    1              0.000010 syn keyword cssUIAttr contained active inactive disabled
                            
    1              0.000022 syn match cssUIProp contained "\<nav-\(down\|index\|left\|right\|up\)\=\>"
    1              0.000022 syn match cssUIProp contained "\<outline\(-\(width\|style\|color\|offset\)\)\=\>"
    1              0.000006 syn keyword cssUIAttr contained invert
                            
    1              0.000008 syn keyword cssUIProp contained icon resize
    1              0.000009 syn keyword cssUIAttr contained both horizontal vertical
                            
    1              0.000014 syn match cssUIProp contained "\<text-overflow\>"
    1              0.000007 syn keyword cssUIAttr contained clip ellipsis
                            
    1              0.000014 syn match cssUIProp contained "\<image-rendering\>"
    1              0.000008 syn keyword cssUIAttr contained pixellated
    1              0.000012 syn match cssUIAttr contained "\<crisp-edges\>"
                            
                            "------------------------------------------------
                            " Webkit/iOS specific attributes
    1              0.000012 syn match cssUIAttr contained '\<preserve-3d\>'
                            " IE specific attributes
    1              0.000013 syn match cssIEUIAttr contained '\<bicubic\>'
                            
                            " Webkit/iOS specific properties
    1              0.000028 syn match cssUIProp contained '\<\(tap-highlight-color\|user-select\|touch-callout\)\>'
                            " IE specific properties
    1              0.000021 syn match cssIEUIProp contained '\<\(interpolation-mode\|zoom\|filter\)\>'
                            
                            " Webkit/Firebox specific properties/attributes
    1              0.000008 syn keyword cssUIProp contained appearance
    1              0.000012 syn keyword cssUIAttr contained window button field icon document menu
                            
                            
    1              0.000024 syn match cssAuralProp contained "\<\(pause\|cue\)\(-\(before\|after\)\)\=\>"
    1              0.000040 syn match cssAuralProp contained "\<\(play-during\|speech-rate\|voice-family\|pitch\(-range\)\=\|speak\(-\(punctuation\|numeral\|header\)\)\=\)\>"
    1              0.000016 syn keyword cssAuralProp contained volume during azimuth elevation stress richness
    1              0.000019 syn match cssAuralAttr contained "\<\(x-\)\=\(soft\|loud\)\>"
    1              0.000008 syn keyword cssAuralAttr contained silent
    1              0.000014 syn match cssAuralAttr contained "\<spell-out\>"
    1              0.000008 syn keyword cssAuralAttr contained non mix
    1              0.000022 syn match cssAuralAttr contained "\<\(left\|right\)-side\>"
    1              0.000021 syn match cssAuralAttr contained "\<\(far\|center\)-\(left\|center\|right\)\>"
    1              0.000011 syn keyword cssAuralAttr contained leftwards rightwards behind
    1              0.000012 syn keyword cssAuralAttr contained below level above lower higher
    1              0.000020 syn match cssAuralAttr contained "\<\(x-\)\=\(slow\|fast\|low\|high\)\>"
    1              0.000009 syn keyword cssAuralAttr contained faster slower
    1              0.000015 syn keyword cssAuralAttr contained male female child code digits continuous
                            
                            " mobile text
    1              0.000017 syn match cssMobileTextProp contained "\<text-size-adjust\>"
                            
    1              0.000014 syn keyword cssMediaProp contained width height orientation scan
    1              0.000014 syn keyword cssMediaProp contained any-hover any-pointer color-gamut grid hover
    1              0.000014 syn keyword cssMediaProp contained overflow-block overflow-inline pointer update
    1              0.000026 syn match cssMediaProp contained /\<\(\(max\|min\)-\)\=\(\(device\)-\)\=aspect-ratio\>/
    1              0.000022 syn match cssMediaProp contained /\<\(\(max\|min\)-\)\=device-pixel-ratio\>/
    1              0.000023 syn match cssMediaProp contained /\<\(\(max\|min\)-\)\=device-\(height\|width\)\>/
    1              0.000033 syn match cssMediaProp contained /\<\(\(max\|min\)-\)\=\(height\|width\|resolution\|monochrome\|color\(-index\)\=\)\>/
    1              0.000015 syn keyword cssMediaAttr contained portrait landscape progressive interlace
    1              0.000015 syn keyword cssMediaAttr contained coarse fast fine hover infinite p3 paged
    1              0.000012 syn keyword cssMediaAttr contained rec2020 scroll slow srgb
    1              0.000059 syn match cssKeyFrameProp contained /\(\d\+\(\.\d\+\)\?%\|\(\<from\|to\>\)\)/ nextgroup=cssDefinition
    1              0.000056 syn match cssPageMarginProp /@\(\(top\|left\|right\|bottom\)-\(left\|center\|right\|middle\|bottom\)\)\(-corner\)\=/ contained nextgroup=cssDefinition
    1              0.000012 syn keyword cssPageProp contained content size
    1              0.000010 syn keyword cssPageProp contained orphans widows
    1              0.000010 syn keyword cssFontDescriptorProp contained src
    1              0.000016 syn match cssFontDescriptorProp contained "\<unicode-range\>"
                            " unicode-range attributes
    1              0.000051 syn match cssFontDescriptorAttr contained "U+[0-9A-Fa-f?]\+"
    1              0.000015 syn match cssFontDescriptorAttr contained "U+\x\+-\x\+"
                            
    1              0.000014 syn match cssBraces contained "[{}]"
    1              0.000034 syn match cssError contained "{@<>"
    1              0.008913 syn region cssDefinition transparent matchgroup=cssBraces start='{' end='}' contains=cssTagName,cssAttributeSelector,cssClassName,cssIdentifier,cssAtRule,cssAttrRegion,css.*Prop,cssComment,cssValue.*,cssColor,cssURL,cssImportant,cssCustomProp,cssError,cssStringQ,cssStringQQ,cssFunction,cssUnicodeEscape,cssVendor,cssDefinition,cssHacks,cssNoise fold
    1              0.000044 syn match cssBraceError "}"
    1              0.000013 syn match cssAttrComma ","
                            
                            " Pseudo class
                            " https://www.w3.org/TR/selectors-4/
    1              0.000048 syn match cssPseudoClass ":[A-Za-z0-9_-]*" contains=cssNoise,cssPseudoClassId,cssUnicodeEscape,cssVendor,cssPseudoClassFn
    1              0.000025 syn keyword cssPseudoClassId contained link visited active hover before after left right
    1              0.000021 syn keyword cssPseudoClassId contained root empty target enabled disabled checked invalid
    1              0.000031 syn match cssPseudoClassId contained "\<first-\(line\|letter\)\>"
    1              0.000029 syn match cssPseudoClassId contained "\<\(first\|last\|only\)-\(of-type\|child\)\>"
    1              0.000026 syn match cssPseudoClassId contained  "\<focus\(-within\|-visible\)\=\>"
    1              0.000068 syn region cssPseudoClassFn contained matchgroup=cssFunctionName start="\<\(not\|is\|lang\|\(nth\|nth-last\)-\(of-type\|child\)\)(" end=")" contains=cssStringQ,cssStringQQ,cssTagName,cssAttributeSelector,cssClassName,cssIdentifier
                            " ------------------------------------
                            " Vendor specific properties
    1              0.000016 syn match cssPseudoClassId contained  "\<selection\>"
    1              0.000019 syn match cssPseudoClassId contained  "\<\(input-\)\=placeholder\>"
                            
                            " Misc highlight groups
    1              0.000063 syntax match cssUnitDecorators /\(#\|-\|+\|%\|mm\|cm\|in\|pt\|pc\|em\|ex\|px\|ch\|rem\|vh\|vw\|vmin\|vmax\|dpi\|dppx\|dpcm\|Hz\|kHz\|s\|ms\|deg\|grad\|rad\)/ contained
    1              0.000016 syntax match cssNoise contained /\(:\|;\|\/\)/
                            
                            " Comment
    1              0.000031 syn region cssComment start="/\*" end="\*/" contains=@Spell fold
                            
    1              0.000026 syn match cssUnicodeEscape "\\\x\{1,6}\s\?"
    1              0.000017 syn match cssSpecialCharQQ +\\\\\|\\"+ contained
    1              0.000028 syn match cssSpecialCharQ +\\\\\|\\'+ contained
    1              0.000035 syn region cssStringQQ start=+"+ skip=+\\\\\|\\"+ end=+"+ contains=cssUnicodeEscape,cssSpecialCharQQ
    1              0.000029 syn region cssStringQ start=+'+ skip=+\\\\\|\\'+ end=+'+ contains=cssUnicodeEscape,cssSpecialCharQ
                            
                            " Vendor Prefix
    1              0.000020 syn match cssVendor contained "-\(webkit\|moz\|o\|ms\)-"
                            
                            " Various CSS Hack characters
                            " In earlier versions of IE (6 and 7), one can prefix property names
                            " with a _ or * to isolate those definitions to particular versions of IE
                            " This is purely decorative and therefore we assign to the same highlight
                            " group to cssVendor, for more information:
                            " http://www.paulirish.com/2009/browser-specific-css-hacks/
    1              0.000010 syn match cssHacks contained /\(_\|*\)/
                            
                            " Attr Enhance
                            " Some keywords are both Prop and Attr, so we have to handle them
                            " cssPseudoClassId is hidden by cssAttrRegion, so we add it here. see #69
    1              0.011951 syn region cssAttrRegion start=/:/ end=/\ze\(;\|)\|}\|{\)/ contained contains=cssPseudoClassId,css.*Attr,cssColor,cssImportant,cssValue.*,cssFunction,cssString.*,cssURL,cssComment,cssUnicodeEscape,cssVendor,cssError,cssAttrComma,cssNoise
                            
                            " Hack for transition
                            " 'transition' has Props after ':'.
    1              0.014186 syn region cssAttrRegion start=/transition\s*:/ end=/\ze\(;\|)\|}\)/ contained contains=css.*Prop,css.*Attr,cssColor,cssImportant,cssValue.*,cssFunction,cssString.*,cssURL,cssComment,cssUnicodeEscape,cssVendor,cssError,cssAttrComma,cssNoise
                            
    1              0.000066 syn match cssAtKeyword /@\(font-face\|media\|keyframes\|import\|charset\|namespace\|page\|supports\)/
                            
    1              0.000022 syn keyword cssAtRuleLogical only not and contained
                            
                            " @media
                            " Reference: http://www.w3.org/TR/css3-mediaqueries/
    1              0.000084 syn region cssAtRule start=/@media\>/ end=/\ze{/ skipwhite skipnl matchgroup=cssAtKeyword contains=cssMediaProp,cssValueLength,cssAtRuleLogical,cssValueInteger,cssMediaAttr,cssVendor,cssMediaType,cssComment,cssCustomProp,cssFunctionName nextgroup=cssDefinition
    1              0.000030 syn keyword cssMediaType contained screen print aural braille embossed handheld projection tty tv speech all contained
                            
                            " @page
                            " http://www.w3.org/TR/css3-page/
    1              0.000050 syn region cssAtRule start=/@page\>/ end=/\ze{/ skipwhite skipnl matchgroup=cssAtKeyword contains=cssPagePseudo,cssComment nextgroup=cssDefinition
    1              0.000052 syn match cssPagePseudo /:\(left\|right\|first\|blank\)/ contained skipwhite skipnl
                            " @keyframe
                            " http://www.w3.org/TR/css3-animations/#keyframes
    1              0.000047 syn region cssAtRule start=/@\(-[a-z]\+-\)\=keyframes\>/ end=/\ze{/ skipwhite skipnl matchgroup=cssAtKeyword contains=cssVendor,cssComment nextgroup=cssDefinition
                            
    1              0.000097 syn region cssAtRule start=/@import\>/    end=/\ze;/ contains=cssStringQ,cssStringQQ,cssUnicodeEscape,cssComment,cssAtKeyword,cssURL,cssMediaProp,cssValueLength,cssAtRuleLogical,cssValueInteger,cssMediaAttr,cssMediaType
    1              0.000050 syn region cssAtRule start=/@charset\>/   end=/\ze;/ contains=cssStringQ,cssStringQQ,cssUnicodeEscape,cssComment,cssAtKeyword
    1              0.000180 syn region cssAtRule start=/@namespace\>/ end=/\ze;/ contains=cssStringQ,cssStringQQ,cssUnicodeEscape,cssComment,cssAtKeyword
                            
                            " @supports
                            " https://www.w3.org/TR/css3-conditional/#at-supports
    1              0.006754 syn region cssAtRule start=/@supports\>/ end=/\ze{/ skipwhite skipnl contains=cssAtRuleLogical,cssAttrRegion,css.*Prop,cssValue.*,cssVendor,cssAtKeyword,cssComment nextgroup=cssDefinition
                            
                            
    1              0.000026 if main_syntax == "css"
                              syn sync minlines=10
    1              0.000005 endif
                            
                            " Define the default highlighting.
                            " Only when an item doesn't have highlighting yet
                            
    1              0.000009 hi def link cssComment Comment
    1              0.000006 hi def link cssVendor Comment
    1              0.000006 hi def link cssHacks Comment
    1              0.000006 hi def link cssTagName Statement
    1              0.000008 hi def link cssDeprecated Error
    1              0.000006 hi def link cssSelectorOp Special
    1              0.000005 hi def link cssSelectorOp2 Special
    1              0.000005 hi def link cssAttrComma Special
                            
    1              0.000008 hi def link cssAnimationProp cssProp
    1              0.000006 hi def link cssBackgroundProp cssProp
    1              0.000006 hi def link cssBorderProp cssProp
    1              0.000005 hi def link cssBoxProp cssProp
    1              0.000005 hi def link cssCascadeProp cssProp
    1              0.000005 hi def link cssColorProp cssProp
    1              0.000008 hi def link cssContentForPagedMediaProp cssProp
    1              0.000005 hi def link cssDimensionProp cssProp
    1              0.000005 hi def link cssFlexibleBoxProp cssProp
    1              0.000005 hi def link cssFontProp cssProp
    1              0.000006 hi def link cssGeneratedContentProp cssProp
    1              0.000005 hi def link cssGridProp cssProp
    1              0.000005 hi def link cssHyerlinkProp cssProp
    1              0.000005 hi def link cssInteractProp cssProp
    1              0.000006 hi def link cssLineboxProp cssProp
    1              0.000005 hi def link cssListProp cssProp
    1              0.000005 hi def link cssMarqueeProp cssProp
    1              0.000006 hi def link cssMultiColumnProp cssProp
    1              0.000007 hi def link cssPagedMediaProp cssProp
    1              0.000015 hi def link cssPositioningProp cssProp
    1              0.000006 hi def link cssObjectProp cssProp
    1              0.000006 hi def link cssPrintProp cssProp
    1              0.000006 hi def link cssRubyProp cssProp
    1              0.000006 hi def link cssSpeechProp cssProp
    1              0.000004 hi def link cssTableProp cssProp
    1              0.000005 hi def link cssTextProp cssProp
    1              0.000005 hi def link cssTransformProp cssProp
    1              0.000005 hi def link cssTransitionProp cssProp
    1              0.000005 hi def link cssUIProp cssProp
    1              0.000005 hi def link cssIEUIProp cssProp
    1              0.000005 hi def link cssAuralProp cssProp
    1              0.000005 hi def link cssRenderProp cssProp
    1              0.000005 hi def link cssMobileTextProp cssProp
                            
    1              0.000006 hi def link cssAnimationAttr cssAttr
    1              0.000005 hi def link cssBackgroundAttr cssAttr
    1              0.000005 hi def link cssBorderAttr cssAttr
    1              0.000005 hi def link cssBoxAttr cssAttr
    1              0.000008 hi def link cssContentForPagedMediaAttr cssAttr
    1              0.000006 hi def link cssDimensionAttr cssAttr
    1              0.000005 hi def link cssFlexibleBoxAttr cssAttr
    1              0.000011 hi def link cssFontAttr cssAttr
    1              0.000005 hi def link cssGeneratedContentAttr cssAttr
    1              0.000006 hi def link cssGridAttr cssAttr
    1              0.000006 hi def link cssHyerlinkAttr cssAttr
    1              0.000010 hi def link cssInteractAttr cssAttr
    1              0.000007 hi def link cssLineboxAttr cssAttr
    1              0.000005 hi def link cssListAttr cssAttr
    1              0.000007 hi def link cssMarginAttr cssAttr
    1              0.000006 hi def link cssMarqueeAttr cssAttr
    1              0.000005 hi def link cssMultiColumnAttr cssAttr
    1              0.000005 hi def link cssPaddingAttr cssAttr
    1              0.000006 hi def link cssPagedMediaAttr cssAttr
    1              0.000006 hi def link cssPositioningAttr cssAttr
    1              0.000005 hi def link cssObjectAttr cssAttr
    1              0.000005 hi def link cssGradientAttr cssAttr
    1              0.000004 hi def link cssPrintAttr cssAttr
    1              0.000006 hi def link cssRubyAttr cssAttr
    1              0.000006 hi def link cssSpeechAttr cssAttr
    1              0.000004 hi def link cssTableAttr cssAttr
    1              0.000004 hi def link cssTextAttr cssAttr
    1              0.000007 hi def link cssTransformAttr cssAttr
    1              0.000005 hi def link cssTransitionAttr cssAttr
    1              0.000005 hi def link cssUIAttr cssAttr
    1              0.000004 hi def link cssIEUIAttr cssAttr
    1              0.000005 hi def link cssAuralAttr cssAttr
    1              0.000005 hi def link cssRenderAttr cssAttr
    1              0.000005 hi def link cssCascadeAttr cssAttr
    1              0.000004 hi def link cssCommonAttr cssAttr
                            
    1              0.000007 hi def link cssPseudoClassId PreProc
    1              0.000008 hi def link cssPseudoClassLang Constant
    1              0.000006 hi def link cssValueLength Number
    1              0.000005 hi def link cssValueInteger Number
    1              0.000005 hi def link cssValueNumber Number
    1              0.000005 hi def link cssValueAngle Number
    1              0.000005 hi def link cssValueTime Number
    1              0.000005 hi def link cssValueFrequency Number
    1              0.000005 hi def link cssFunction Constant
    1              0.000005 hi def link cssURL String
    1              0.000006 hi def link cssFunctionName Function
    1              0.000005 hi def link cssFunctionComma Function
    1              0.000005 hi def link cssColor Constant
    1              0.000005 hi def link cssIdentifier Function
    1              0.000005 hi def link cssAtRule Include
    1              0.000005 hi def link cssAtKeyword PreProc
    1              0.000005 hi def link cssImportant Special
    1              0.000005 hi def link cssCustomProp Special
    1              0.000005 hi def link cssBraces Function
    1              0.000005 hi def link cssBraceError Error
    1              0.000005 hi def link cssError Error
    1              0.000005 hi def link cssUnicodeEscape Special
    1              0.000005 hi def link cssStringQQ String
    1              0.000005 hi def link cssStringQ String
    1              0.000006 hi def link cssAttributeSelector String
    1              0.000004 hi def link cssMediaType Special
    1              0.000007 hi def link cssMediaComma Normal
    1              0.000011 hi def link cssAtRuleLogical Statement
    1              0.000005 hi def link cssMediaProp cssProp
    1              0.000005 hi def link cssMediaAttr cssAttr
    1              0.000005 hi def link cssPagePseudo PreProc
    1              0.000006 hi def link cssPageMarginProp cssAtKeyword
    1              0.000005 hi def link cssPageProp cssProp
    1              0.000005 hi def link cssKeyFrameProp Constant
    1              0.000006 hi def link cssFontDescriptor Special
    1              0.000006 hi def link cssFontDescriptorProp cssProp
    1              0.000006 hi def link cssFontDescriptorAttr cssAttr
    1              0.000007 hi def link cssUnicodeRange Constant
    1              0.000005 hi def link cssClassName Function
    1              0.000005 hi def link cssClassNameDot Function
    1              0.000005 hi def link cssProp StorageClass
    1              0.000005 hi def link cssAttr Constant
    1              0.000005 hi def link cssUnitDecorators Number
    1              0.000004 hi def link cssNoise Noise
                            
    1              0.000016 let b:current_syntax = "css"
                            
    1              0.000011 if main_syntax == 'css'
                              unlet main_syntax
    1              0.000003 endif
                            
    1              0.000039 let &cpo = s:cpo_save
    1              0.000008 unlet s:cpo_save
                            
                            " vim: ts=8

SCRIPT  C:\Users\Lenovo\scoop\apps\neovim\0.6.1\share\nvim\runtime\syntax\css.vim
Sourced 1 time
Total time:   0.000267
 Self time:   0.000267

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:     Cascading Style Sheets
                            " Previous Contributor List:
                            "               Jules Wang      <w.jq0722@gmail.com>
                            "               Claudio Fleiner <claudio@fleiner.com>
                            "               Yeti            (Add full CSS2, HTML4 support)
                            "               Nikolai Weibull (Add CSS2 support)
                            " URL:          https://github.com/vim-language-dept/css-syntax.vim
                            " Maintainer:   Jay Sitter <jay@jaysitter.com>
                            " Last Change:  2021 Oct 15
                            
                            " quit when a syntax file was already loaded
    1              0.000039 if !exists("main_syntax")
                              if exists("b:current_syntax")
                                finish
                              endif
                              let main_syntax = 'css'
    1              0.000033 elseif exists("b:current_syntax") && b:current_syntax == "css"
    1              0.000005   finish
                            endif
                            
                            let s:cpo_save = &cpo
                            set cpo&vim
                            
                            syn case ignore
                            " Add dash to allowed keyword characters.
                            syn iskeyword @,48-57,_,192-255,-
                            
                            " HTML4 tags
                            syn keyword cssTagName abbr address area a b base
                            syn keyword cssTagName bdo blockquote body br button
                            syn keyword cssTagName caption cite code col colgroup dd del
                            syn keyword cssTagName dfn div dl dt em fieldset form
                            syn keyword cssTagName h1 h2 h3 h4 h5 h6 head hr html img i
                            syn keyword cssTagName iframe input ins isindex kbd label legend li
                            syn keyword cssTagName link map menu meta noscript ol optgroup
                            syn keyword cssTagName option p param picture pre q s samp script small
                            syn keyword cssTagName span strong sub sup tbody td
                            syn keyword cssTagName textarea tfoot th thead title tr ul u var
                            syn keyword cssTagName object svg
                            syn match   cssTagName /\<select\>\|\<style\>\|\<table\>/
                            
                            " 34 HTML5 tags
                            syn keyword cssTagName article aside audio bdi canvas command data
                            syn keyword cssTagName datalist details dialog embed figcaption figure footer
                            syn keyword cssTagName header hgroup keygen main mark menuitem meter nav
                            syn keyword cssTagName output progress rt rp ruby section
                            syn keyword cssTagName source summary time track video wbr
                            
                            " Tags not supported in HTML5
                            " acronym applet basefont big center dir
                            " font frame frameset noframes strike tt
                            
                            syn match cssTagName "\*"
                            
                            " selectors
                            syn match cssSelectorOp "[,>+~]"
                            syn match cssSelectorOp2 "[~|^$*]\?=" contained
                            syn region cssAttributeSelector matchgroup=cssSelectorOp start="\[" end="]" contains=cssUnicodeEscape,cssSelectorOp2,cssStringQ,cssStringQQ
                            
                            " .class and #id
                            syn match cssClassName "\.-\=[A-Za-z_][A-Za-z0-9_-]*" contains=cssClassNameDot
                            syn match cssClassNameDot contained '\.'
                            
                            try
                            syn match cssIdentifier "#[A-Za-z-_@][A-Za-z-0-9_@-]*"
                            catch /^.*/
                            syn match cssIdentifier "#[A-Za-z_@][A-Za-z0-9_@-]*"
                            endtry
                            
                            " digits
                            syn match cssValueInteger contained "[-+]\=\d\+" contains=cssUnitDecorators
                            syn match cssValueNumber contained "[-+]\=\d\+\(\.\d*\)\=" contains=cssUnitDecorators
                            syn match cssValueLength contained "[-+]\=\d\+\(\.\d*\)\=\(mm\|cm\|in\|pt\|pc\|em\|ex\|px\|rem\|dpi\|dppx\|dpcm\|fr\|vw\|vh\|vmin\|vmax\|ch\)\>" contains=cssUnitDecorators
                            syn match cssValueLength contained "[-+]\=\d\+\(\.\d*\)\=%" contains=cssUnitDecorators
                            syn match cssValueAngle contained "[-+]\=\d\+\(\.\d*\)\=\(deg\|grad\|rad\)\>" contains=cssUnitDecorators
                            syn match cssValueTime contained "+\=\d\+\(\.\d*\)\=\(ms\|s\)\>" contains=cssUnitDecorators
                            syn match cssValueFrequency contained "+\=\d\+\(\.\d*\)\=\(Hz\|kHz\)\>" contains=cssUnitDecorators
                            
                            " The 16 basic color names
                            syn keyword cssColor contained aqua black blue fuchsia gray green lime maroon navy olive purple red silver teal yellow
                            
                            " 130 more color names
                            syn keyword cssColor contained aliceblue antiquewhite aquamarine azure
                            syn keyword cssColor contained beige bisque blanchedalmond blueviolet brown burlywood
                            syn keyword cssColor contained cadetblue chartreuse chocolate coral cornflowerblue cornsilk crimson cyan
                            syn match cssColor contained /\<dark\(blue\|cyan\|goldenrod\|gray\|green\|grey\|khaki\)\>/
                            syn match cssColor contained /\<dark\(magenta\|olivegreen\|orange\|orchid\|red\|salmon\|seagreen\)\>/
                            syn match cssColor contained /\<darkslate\(blue\|gray\|grey\)\>/
                            syn match cssColor contained /\<dark\(turquoise\|violet\)\>/
                            syn keyword cssColor contained deeppink deepskyblue dimgray dimgrey dodgerblue firebrick
                            syn keyword cssColor contained floralwhite forestgreen gainsboro ghostwhite gold
                            syn keyword cssColor contained goldenrod greenyellow grey honeydew hotpink
                            syn keyword cssColor contained indianred indigo ivory khaki lavender lavenderblush lawngreen
                            syn keyword cssColor contained lemonchiffon limegreen linen magenta
                            syn match cssColor contained /\<light\(blue\|coral\|cyan\|goldenrodyellow\|gray\|green\)\>/
                            syn match cssColor contained /\<light\(grey\|pink\|salmon\|seagreen\|skyblue\|yellow\)\>/
                            syn match cssColor contained /\<light\(slategray\|slategrey\|steelblue\)\>/
                            syn match cssColor contained /\<medium\(aquamarine\|blue\|orchid\|purple\|seagreen\)\>/
                            syn match cssColor contained /\<medium\(slateblue\|springgreen\|turquoise\|violetred\)\>/
                            syn keyword cssColor contained midnightblue mintcream mistyrose moccasin navajowhite
                            syn keyword cssColor contained oldlace olivedrab orange orangered orchid
                            syn match cssColor contained /\<pale\(goldenrod\|green\|turquoise\|violetred\)\>/
                            syn keyword cssColor contained papayawhip peachpuff peru pink plum powderblue
                            syn keyword cssColor contained rosybrown royalblue rebeccapurple saddlebrown salmon
                            syn keyword cssColor contained sandybrown seagreen seashell sienna skyblue slateblue
                            syn keyword cssColor contained slategray slategrey snow springgreen steelblue tan
                            syn keyword cssColor contained thistle tomato turquoise violet wheat
                            syn keyword cssColor contained whitesmoke yellowgreen
                            
                            " FIXME: These are actually case-insensitive too, but (a) specs recommend using
                            " mixed-case (b) it's hard to highlight the word `Background' correctly in
                            " all situations
                            syn case match
                            syn keyword cssColor contained ActiveBorder ActiveCaption AppWorkspace ButtonFace ButtonHighlight ButtonShadow ButtonText CaptionText GrayText Highlight HighlightText InactiveBorder InactiveCaption InactiveCaptionText InfoBackground InfoText Menu MenuText Scrollbar ThreeDDarkShadow ThreeDFace ThreeDHighlight ThreeDLightShadow ThreeDShadow Window WindowFrame WindowText Background
                            syn case ignore
                            
                            syn match cssImportant contained "!\s*important\>"
                            syn match cssCustomProp contained "--[a-zA-Z0-9-_]*"
                            
                            syn match cssColor contained "\<transparent\>"
                            syn match cssColor contained "\<currentColor\>"
                            syn match cssColor contained "\<white\>"
                            syn match cssColor contained "#\x\{3,4\}\>" contains=cssUnitDecorators
                            syn match cssColor contained "#\x\{6\}\>" contains=cssUnitDecorators
                            syn match cssColor contained "#\x\{8\}\>" contains=cssUnitDecorators
                            
                            syn region cssURL contained matchgroup=cssFunctionName start="\<\(uri\|url\|local\|format\)\s*(" end=")" contains=cssStringQ,cssStringQQ oneline
                            syn region cssFunction contained matchgroup=cssFunctionName start="\<\(var\|calc\)\s*(" end=")" contains=cssCustomProp,cssValue.*,cssFunction,cssColor,cssStringQ,cssStringQQ oneline
                            syn region cssFunction contained matchgroup=cssFunctionName start="\<\(rgb\|clip\|attr\|counter\|rect\|cubic-bezier\|steps\)\s*(" end=")" oneline  contains=cssValueInteger,cssValueNumber,cssValueLength,cssFunctionComma
                            syn region cssFunction contained matchgroup=cssFunctionName start="\<\(rgba\|hsl\|hsla\|color-stop\|from\|to\)\s*(" end=")" oneline  contains=cssColor,cssValueInteger,cssValueNumber,cssValueLength,cssFunctionComma,cssFunction
                            syn region cssFunction contained matchgroup=cssFunctionName start="\<\(linear-\|radial-\|conic-\)\=\gradient\s*(" end=")" oneline  contains=cssColor,cssValueInteger,cssValueNumber,cssValueLength,cssFunction,cssGradientAttr,cssFunctionComma
                            syn region cssFunction contained matchgroup=cssFunctionName start="\<\(matrix\(3d\)\=\|scale\(3d\|X\|Y\|Z\)\=\|translate\(3d\|X\|Y\|Z\)\=\|skew\(X\|Y\)\=\|rotate\(3d\|X\|Y\|Z\)\=\|perspective\)\s*(" end=")" oneline contains=cssValueInteger,cssValueNumber,cssValueLength,cssValueAngle,cssFunctionComma
                            syn region cssFunction contained matchgroup=cssFunctionName start="\<\(blur\|brightness\|contrast\|drop-shadow\|grayscale\|hue-rotate\|invert\|opacity\|saturate\|sepia\)\s*(" end=")" oneline contains=cssValueInteger,cssValueNumber,cssValueLength,cssValueAngle,cssFunctionComma
                            syn keyword cssGradientAttr contained top bottom left right cover center middle ellipse at
                            syn match cssFunctionComma contained ","
                            
                            " Common Prop and Attr
                            syn keyword cssCommonAttr contained auto none inherit all default normal
                            syn keyword cssCommonAttr contained top bottom center stretch hidden visible
                            syn match cssCommonAttr contained "\<\(max-\|min-\|fit-\)content\>"
                            "------------------------------------------------
                            " CSS Animations
                            " http://www.w3.org/TR/css3-animations/
                            syn match cssAnimationProp contained "\<animation\(-\(delay\|direction\|duration\|fill-mode\|name\|play-state\|timing-function\|iteration-count\)\)\=\>"
                            
                            " animation-direction attributes
                            syn keyword cssAnimationAttr contained alternate reverse
                            syn match cssAnimationAttr contained "\<alternate-reverse\>"
                            
                            " animation-fill-mode attributes
                            syn keyword cssAnimationAttr contained forwards backwards both
                            
                            " animation-play-state attributes
                            syn keyword cssAnimationAttr contained running paused
                            
                            " animation-iteration-count attributes
                            syn keyword cssAnimationAttr contained infinite
                            "------------------------------------------------
                            "  CSS Backgrounds and Borders Module Level 3
                            "  http://www.w3.org/TR/css3-background/
                            syn match cssBackgroundProp contained "\<background\(-\(attachment\|clip\|color\|image\|origin\|position\|repeat\|size\)\)\=\>"
                            " background-attachment attributes
                            syn keyword cssBackgroundAttr contained scroll fixed local
                            
                            " background-position attributes
                            syn keyword cssBackgroundAttr contained left center right top bottom
                            
                            " background-repeat attributes
                            syn match cssBackgroundAttr contained "\<no-repeat\>"
                            syn match cssBackgroundAttr contained "\<repeat\(-[xy]\)\=\>"
                            
                            " background-size attributes
                            syn keyword cssBackgroundAttr contained cover contain
                            
                            syn match cssBorderProp contained "\<border\(-\(top\|right\|bottom\|left\)\)\=\(-\(width\|color\|style\)\)\=\>"
                            syn match cssBorderProp contained "\<border\(-\(top\|bottom\)-\(left\|right\)\)\=-radius\>"
                            syn match cssBorderProp contained "\<border-image\(-\(outset\|repeat\|slice\|source\|width\)\)\=\>"
                            syn match cssBorderProp contained "\<box-decoration-break\>"
                            syn match cssBorderProp contained "\<box-shadow\>"
                            
                            " border-image attributes
                            syn keyword cssBorderAttr contained stretch round fill
                            
                            " border-style attributes
                            syn keyword cssBorderAttr contained dotted dashed solid double groove ridge inset outset
                            
                            " border-width attributes
                            syn keyword cssBorderAttr contained thin thick medium
                            
                            " box-decoration-break attributes
                            syn keyword cssBorderAttr contained clone slice
                            "------------------------------------------------
                            
                            syn match cssBoxProp contained "\<padding\(-\(top\|right\|bottom\|left\)\)\=\>"
                            syn match cssBoxProp contained "\<margin\(-\(top\|right\|bottom\|left\)\)\=\>"
                            syn match cssBoxProp contained "\<overflow\(-\(x\|y\|style\)\)\=\>"
                            syn match cssBoxProp contained "\<rotation\(-point\)\=\>"
                            syn keyword cssBoxAttr contained visible hidden scroll auto
                            syn match cssBoxAttr contained "\<no-\(display\|content\)\>"
                            
                            syn keyword cssCascadeProp contained all
                            syn keyword cssCascadeAttr contained initial unset revert
                            
                            syn keyword cssColorProp contained opacity
                            syn match cssColorProp contained "\<color-profile\>"
                            syn match cssColorProp contained "\<rendering-intent\>"
                            
                            
                            syn match cssDimensionProp contained "\<\(min\|max\)-\(width\|height\)\>"
                            syn keyword cssDimensionProp contained height
                            syn keyword cssDimensionProp contained width
                            
                            " CSS Flexible Box Layout Module Level 1
                            " http://www.w3.org/TR/css3-flexbox/
                            " CSS Box Alignment Module Level 3
                            " http://www.w3.org/TR/css-align-3/
                            syn match cssFlexibleBoxProp contained "\<flex\(-\(direction\|wrap\|flow\|grow\|shrink\|basis\)\)\=\>"
                            syn match cssFlexibleBoxProp contained "\<\(align\|justify\)\(-\(items\|self\|content\)\)\=\>"
                            syn keyword cssFlexibleBoxProp contained order
                            
                            syn match cssFlexibleBoxAttr contained "\<\(row\|column\|wrap\)\(-reverse\)\=\>"
                            syn keyword cssFlexibleBoxAttr contained nowrap stretch baseline center
                            syn match cssFlexibleBoxAttr contained "\<flex\(-\(start\|end\)\)\=\>"
                            syn match cssFlexibleBoxAttr contained "\<space\(-\(between\|around\|evenly\)\)\=\>"
                            
                            " CSS Fonts Module Level 3
                            " http://www.w3.org/TR/css-fonts-3/
                            syn match cssFontProp contained "\<font\(-\(family\|\|feature-settings\|kerning\|language-override\|size\(-adjust\)\=\|stretch\|style\|synthesis\|variant\(-\(alternates\|caps\|east-asian\|ligatures\|numeric\|position\)\)\=\|weight\)\)\=\>"
                            
                            " font attributes
                            syn keyword cssFontAttr contained icon menu caption
                            syn match cssFontAttr contained "\<message-box\>"
                            syn match cssFontAttr contained "\<status-bar\>"
                            syn keyword cssFontAttr contained larger smaller
                            syn match cssFontAttr contained "\<\(x\{1,2\}-\)\=\(large\|small\)\>"
                            syn match cssFontAttr contained "\<small-\(caps\|caption\)\>"
                            " font-family attributes
                            syn keyword cssFontAttr contained sans-serif serif cursive fantasy monospace
                            " font-feature-settings attributes
                            syn keyword cssFontAttr contained on off
                            " font-stretch attributes
                            syn match cssFontAttr contained "\<\(\(ultra\|extra\|semi\)-\)\=\(condensed\|expanded\)\>"
                            " font-style attributes
                            syn keyword cssFontAttr contained italic oblique
                            " font-synthesis attributes
                            syn keyword cssFontAttr contained weight style
                            " font-weight attributes
                            syn keyword cssFontAttr contained bold bolder lighter
                            " TODO: font-variant-* attributes
                            "------------------------------------------------
                            
                            " Webkit specific property/attributes
                            syn match cssFontProp contained "\<font-smooth\>"
                            syn match cssFontAttr contained "\<\(subpixel-\)\=\antialiased\>"
                            
                            
                            " CSS Multi-column Layout Module
                            " http://www.w3.org/TR/css3-multicol/
                            syn match cssMultiColumnProp contained "\<break-\(after\|before\|inside\)\>"
                            syn match cssMultiColumnProp contained "\<column-\(count\|fill\|gap\|rule\(-\(color\|style\|width\)\)\=\|span\|width\)\>"
                            syn keyword cssMultiColumnProp contained columns
                            syn keyword cssMultiColumnAttr contained balance medium
                            syn keyword cssMultiColumnAttr contained always left right page column
                            syn match cssMultiColumnAttr contained "\<avoid\(-\(page\|column\)\)\=\>"
                            
                            " http://www.w3.org/TR/css3-break/#page-break
                            syn match cssMultiColumnProp contained "\<page\(-break-\(before\|after\|inside\)\)\=\>"
                            
                            " http://www.w3.org/TR/SVG11/interact.html
                            syn match cssInteractProp contained "\<pointer-events\>"
                            syn match cssInteractAttr contained "\<\(visible\)\=\(Painted\|Fill\|Stroke\)\=\>"
                            
                            " TODO find following items in w3c docs.
                            syn keyword cssGeneratedContentProp contained quotes crop
                            syn match cssGeneratedContentProp contained "\<counter-\(reset\|increment\)\>"
                            syn match cssGeneratedContentProp contained "\<move-to\>"
                            syn match cssGeneratedContentProp contained "\<page-policy\>"
                            syn match cssGeneratedContentAttr contained "\<\(no-\)\=\(open\|close\)-quote\>"
                            
                            " https://www.w3.org/TR/css-grid-1/
                            syn match cssGridProp contained "\<grid\>"
                            syn match cssGridProp contained "\<grid-template\(-\(columns\|rows\|areas\)\)\=\>"
                            syn match cssGridProp contained "\<grid-\(column\|row\)\(-\(start\|end\|gap\)\)\=\>"
                            syn match cssGridProp contained "\<grid-\(area\|gap\)\>"
                            syn match cssGridProp contained "\<gap\>"
                            syn match cssGridProp contained "\<grid-auto-\(flow\|rows\|columns\)\>"
                            
                            syn match cssHyerlinkProp contained "\<target\(-\(name\|new\|position\)\)\=\>"
                            
                            syn match cssListProp contained "\<list-style\(-\(type\|position\|image\)\)\=\>"
                            syn match cssListAttr contained "\<\(lower\|upper\)-\(roman\|alpha\|greek\|latin\)\>"
                            syn match cssListAttr contained "\<\(hiragana\|katakana\)\(-iroha\)\=\>"
                            syn match cssListAttr contained "\<\(decimal\(-leading-zero\)\=\|cjk-ideographic\)\>"
                            syn keyword cssListAttr contained disc circle square hebrew armenian georgian
                            syn keyword cssListAttr contained inside outside
                            
                            " object-fit https://www.w3.org/TR/css-images-3/#the-object-fit
                            syn match cssObjectProp contained "\<object-\(fit\|position\)\>"
                            syn keyword cssObjectAttr contained fill contain cover scale-down
                            
                            syn keyword cssPositioningProp contained bottom clear clip display float left
                            syn keyword cssPositioningProp contained position right top visibility
                            syn match cssPositioningProp contained "\<z-index\>"
                            syn keyword cssPositioningAttr contained block compact grid
                            syn match cssPositioningAttr contained "\<table\(-\(row-group\|\(header\|footer\)-group\|row\|column\(-group\)\=\|cell\|caption\)\)\=\>"
                            syn keyword cssPositioningAttr contained left right both
                            syn match cssPositioningAttr contained "\<list-item\>"
                            syn match cssPositioningAttr contained "\<inline\(-\(block\|box\|table\|grid\|flex\)\)\=\>"
                            syn match cssPositioningAttr contained "\<flow\(-root\)\=\>"
                            syn keyword cssPositioningAttr contained static relative absolute fixed subgrid sticky
                            
                            syn keyword cssPrintAttr contained landscape portrait crop cross always
                            
                            syn match cssTableProp contained "\<\(caption-side\|table-layout\|border-collapse\|border-spacing\|empty-cells\)\>"
                            syn keyword cssTableAttr contained fixed collapse separate show hide once always
                            
                            
                            syn keyword cssTextProp contained color direction hyphens
                            syn match cssTextProp "\<\(\(word\|letter\)-spacing\|text\(-\(decoration\|transform\|align\|index\|shadow\)\)\=\|vertical-align\|unicode-bidi\|line-height\)\>"
                            syn match cssTextProp contained "\<text-\(justify\|outline\|warp\|align-last\|size-adjust\|rendering\|stroke\|indent\)\>"
                            syn match cssTextProp contained "\<\(word\|line\)-break\|\(overflow\|word\)-wrap\>"
                            syn match cssTextProp contained "\<white-space\>"
                            syn match cssTextProp contained "\<hanging-punctuation\>"
                            syn match cssTextProp contained "\<tab-size\>"
                            syn match cssTextProp contained "\<punctuation-trim\>"
                            syn match cssTextAttr contained "\<line-through\>"
                            syn match cssTextAttr contained "\<\(text-\)\=\(top\|bottom\)\>"
                            syn keyword cssTextAttr contained ltr rtl embed nowrap
                            syn keyword cssTextAttr contained underline overline blink sub super middle
                            syn keyword cssTextAttr contained capitalize uppercase lowercase
                            syn keyword cssTextAttr contained justify baseline sub super
                            syn keyword cssTextAttr contained optimizeLegibility optimizeSpeed geometricPrecision
                            syn match cssTextAttr contained "\<pre\(-\(line\|wrap\)\)\=\>"
                            syn match cssTextAttr contained "\<\(allow\|force\)-end\>"
                            syn keyword cssTextAttr contained start end adjacent
                            syn match cssTextAttr contained "\<inter-\(word\|ideographic\|cluster\)\>"
                            syn keyword cssTextAttr contained distribute kashida first last
                            syn keyword cssTextAttr contained clip ellipsis unrestricted suppress
                            syn match cssTextAttr contained "\<break-all\>"
                            syn match cssTextAttr contained "\<break-word\>"
                            syn keyword cssTextAttr contained manual
                            syn match cssTextAttr contained "\<bidi-override\>"
                            
                            syn match cssTransformProp contained "\<transform\(-\(origin\|style\)\)\=\>"
                            syn match cssTransformProp contained "\<perspective\(-origin\)\=\>"
                            syn match cssTransformProp contained "\<backface-visibility\>"
                            
                            " CSS Transitions
                            " http://www.w3.org/TR/css3-transitions/
                            syn match cssTransitionProp contained "\<transition\(-\(delay\|duration\|property\|timing-function\)\)\=\>"
                            
                            " transition-time-function attributes
                            syn match cssTransitionAttr contained "\<linear\(-gradient\)\@!\>"
                            syn match cssTransitionAttr contained "\<ease\(-\(in-out\|out\|in\)\)\=\>"
                            syn match cssTransitionAttr contained "\<step\(-start\|-end\)\=\>"
                            "------------------------------------------------
                            " CSS Basic User Interface Module Level 3 (CSS3 UI)
                            " http://www.w3.org/TR/css3-ui/
                            syn match cssUIProp contained "\<box-sizing\>"
                            syn match cssUIAttr contained "\<\(content\|padding\|border\)\(-box\)\=\>"
                            
                            syn keyword cssUIProp contained cursor
                            syn match cssUIAttr contained "\<\(\([ns]\=[ew]\=\)\|col\|row\|nesw\|nwse\)-resize\>"
                            syn keyword cssUIAttr contained crosshair help move pointer alias copy
                            syn keyword cssUIAttr contained progress wait text cell move
                            syn match cssUIAttr contained "\<context-menu\>"
                            syn match cssUIAttr contained "\<no-drop\>"
                            syn match cssUIAttr contained "\<not-allowed\>"
                            syn match cssUIAttr contained "\<all-scroll\>"
                            syn match cssUIAttr contained "\<\(vertical-\)\=text\>"
                            syn match cssUIAttr contained "\<zoom\(-in\|-out\)\=\>"
                            
                            syn match cssUIProp contained "\<ime-mode\>"
                            syn keyword cssUIAttr contained active inactive disabled
                            
                            syn match cssUIProp contained "\<nav-\(down\|index\|left\|right\|up\)\=\>"
                            syn match cssUIProp contained "\<outline\(-\(width\|style\|color\|offset\)\)\=\>"
                            syn keyword cssUIAttr contained invert
                            
                            syn keyword cssUIProp contained icon resize
                            syn keyword cssUIAttr contained both horizontal vertical
                            
                            syn match cssUIProp contained "\<text-overflow\>"
                            syn keyword cssUIAttr contained clip ellipsis
                            
                            syn match cssUIProp contained "\<image-rendering\>"
                            syn keyword cssUIAttr contained pixellated
                            syn match cssUIAttr contained "\<crisp-edges\>"
                            
                            "------------------------------------------------
                            " Webkit/iOS specific attributes
                            syn match cssUIAttr contained '\<preserve-3d\>'
                            " IE specific attributes
                            syn match cssIEUIAttr contained '\<bicubic\>'
                            
                            " Webkit/iOS specific properties
                            syn match cssUIProp contained '\<tap-highlight-color\|user-select\|touch-callout\>'
                            " IE specific properties
                            syn match cssIEUIProp contained '\<interpolation-mode\|zoom\|filter\>'
                            
                            " Webkit/Firebox specific properties/attributes
                            syn keyword cssUIProp contained appearance
                            syn keyword cssUIAttr contained window button field icon document menu
                            
                            
                            syn match cssAuralProp contained "\<\(pause\|cue\)\(-\(before\|after\)\)\=\>"
                            syn match cssAuralProp contained "\<\(play-during\|speech-rate\|voice-family\|pitch\(-range\)\=\|speak\(-\(punctuation\|numeral\|header\)\)\=\)\>"
                            syn keyword cssAuralProp contained volume during azimuth elevation stress richness
                            syn match cssAuralAttr contained "\<\(x-\)\=\(soft\|loud\)\>"
                            syn keyword cssAuralAttr contained silent
                            syn match cssAuralAttr contained "\<spell-out\>"
                            syn keyword cssAuralAttr contained non mix
                            syn match cssAuralAttr contained "\<\(left\|right\)-side\>"
                            syn match cssAuralAttr contained "\<\(far\|center\)-\(left\|center\|right\)\>"
                            syn keyword cssAuralAttr contained leftwards rightwards behind
                            syn keyword cssAuralAttr contained below level above lower higher
                            syn match cssAuralAttr contained "\<\(x-\)\=\(slow\|fast\|low\|high\)\>"
                            syn keyword cssAuralAttr contained faster slower
                            syn keyword cssAuralAttr contained male female child code digits continuous
                            
                            " mobile text
                            syn match cssMobileTextProp contained "\<text-size-adjust\>"
                            
                            syn keyword cssMediaProp contained width height orientation scan
                            syn match cssMediaProp contained /\(\(max\|min\)-\)\=\(\(device\)-\)\=aspect-ratio/
                            syn match cssMediaProp contained /\(\(max\|min\)-\)\=device-pixel-ratio/
                            syn match cssMediaProp contained /\(\(max\|min\)-\)\=device-\(height\|width\)/
                            syn match cssMediaProp contained /\(\(max\|min\)-\)\=\(height\|width\|resolution\|monochrome\|color\(-index\)\=\)/
                            syn keyword cssMediaAttr contained portrait landscape progressive interlace
                            syn match cssKeyFrameProp contained /\(\d\+\(\.\d\+\)\?%\|\(\<from\|to\>\)\)/ nextgroup=cssDefinition
                            syn match cssPageMarginProp /@\(\(top\|left\|right\|bottom\)-\(left\|center\|right\|middle\|bottom\)\)\(-corner\)\=/ contained nextgroup=cssDefinition
                            syn keyword cssPageProp contained content size
                            syn keyword cssPageProp contained orphans widows
                            syn keyword cssFontDescriptorProp contained src
                            syn match cssFontDescriptorProp contained "\<unicode-range\>"
                            " unicode-range attributes
                            syn match cssFontDescriptorAttr contained "U+[0-9A-Fa-f?]\+"
                            syn match cssFontDescriptorAttr contained "U+\x\+-\x\+"
                            
                            syn match cssBraces contained "[{}]"
                            syn match cssError contained "{@<>"
                            syn region cssDefinition transparent matchgroup=cssBraces start='{' end='}' contains=cssTagName,cssAttributeSelector,cssClassName,cssIdentifier,cssAtRule,cssAttrRegion,css.*Prop,cssComment,cssValue.*,cssColor,cssURL,cssImportant,cssCustomProp,cssError,cssStringQ,cssStringQQ,cssFunction,cssUnicodeEscape,cssVendor,cssDefinition,cssHacks,cssNoise fold
                            syn match cssBraceError "}"
                            syn match cssAttrComma ","
                            
                            " Pseudo class
                            " http://www.w3.org/TR/css3-selectors/
                            syn match cssPseudoClass ":[A-Za-z0-9_-]*" contains=cssNoise,cssPseudoClassId,cssUnicodeEscape,cssVendor,cssPseudoClassFn
                            syn keyword cssPseudoClassId contained link visited active hover before after left right
                            syn keyword cssPseudoClassId contained root empty target enable disabled checked invalid
                            syn match cssPseudoClassId contained "\<first-\(line\|letter\)\>"
                            syn match cssPseudoClassId contained "\<\(first\|last\|only\)-\(of-type\|child\)\>"
                            syn region cssPseudoClassFn contained matchgroup=cssFunctionName start="\<\(not\|lang\|\(nth\|nth-last\)-\(of-type\|child\)\)(" end=")" contains=cssStringQ,cssStringQQ
                            " ------------------------------------
                            " Vendor specific properties
                            syn match cssPseudoClassId contained  "\<selection\>"
                            syn match cssPseudoClassId contained  "\<focus\(-inner\)\=\>"
                            syn match cssPseudoClassId contained  "\<\(input-\)\=placeholder\>"
                            
                            " Misc highlight groups
                            syntax match cssUnitDecorators /\(#\|-\|+\|%\|mm\|cm\|in\|pt\|pc\|em\|ex\|px\|ch\|rem\|vh\|vw\|vmin\|vmax\|dpi\|dppx\|dpcm\|Hz\|kHz\|s\|ms\|deg\|grad\|rad\)/ contained
                            syntax match cssNoise contained /\(:\|;\|\/\)/
                            
                            " Comment
                            syn region cssComment start="/\*" end="\*/" contains=@Spell fold
                            
                            syn match cssUnicodeEscape "\\\x\{1,6}\s\?"
                            syn match cssSpecialCharQQ +\\\\\|\\"+ contained
                            syn match cssSpecialCharQ +\\\\\|\\'+ contained
                            syn region cssStringQQ start=+"+ skip=+\\\\\|\\"+ end=+"+ contains=cssUnicodeEscape,cssSpecialCharQQ
                            syn region cssStringQ start=+'+ skip=+\\\\\|\\'+ end=+'+ contains=cssUnicodeEscape,cssSpecialCharQ
                            
                            " Vendor Prefix
                            syn match cssVendor contained "-\(webkit\|moz\|o\|ms\)-"
                            
                            " Various CSS Hack characters
                            " In earlier versions of IE (6 and 7), one can prefix property names
                            " with a _ or * to isolate those definitions to particular versions of IE
                            " This is purely decorative and therefore we assign to the same highlight
                            " group to cssVendor, for more information:
                            " http://www.paulirish.com/2009/browser-specific-css-hacks/
                            syn match cssHacks contained /\(_\|*\)/
                            
                            " Attr Enhance
                            " Some keywords are both Prop and Attr, so we have to handle them
                            " cssPseudoClassId is hidden by cssAttrRegion, so we add it here. see #69
                            syn region cssAttrRegion start=/:/ end=/\ze\(;\|)\|}\|{\)/ contained contains=cssPseudoClassId,css.*Attr,cssColor,cssImportant,cssValue.*,cssFunction,cssString.*,cssURL,cssComment,cssUnicodeEscape,cssVendor,cssError,cssAttrComma,cssNoise
                            
                            " Hack for transition
                            " 'transition' has Props after ':'.
                            syn region cssAttrRegion start=/transition\s*:/ end=/\ze\(;\|)\|}\)/ contained contains=css.*Prop,css.*Attr,cssColor,cssImportant,cssValue.*,cssFunction,cssString.*,cssURL,cssComment,cssUnicodeEscape,cssVendor,cssError,cssAttrComma,cssNoise
                            
                            syn match cssAtKeyword /@\(font-face\|media\|keyframes\|import\|charset\|namespace\|page\|supports\)/
                            
                            syn keyword cssAtRuleLogical only not and contained
                            
                            " @media
                            " Reference: http://www.w3.org/TR/css3-mediaqueries/
                            syn region cssAtRule start=/@media\>/ end=/\ze{/ skipwhite skipnl matchgroup=cssAtKeyword contains=cssMediaProp,cssValueLength,cssAtRuleLogical,cssValueInteger,cssMediaAttr,cssVendor,cssMediaType,cssComment,cssCustomProp,cssFunctionName nextgroup=cssDefinition
                            syn keyword cssMediaType contained screen print aural braille embossed handheld projection tty tv speech all contained
                            
                            " @page
                            " http://www.w3.org/TR/css3-page/
                            syn region cssAtRule start=/@page\>/ end=/\ze{/ skipwhite skipnl matchgroup=cssAtKeyword contains=cssPagePseudo,cssComment nextgroup=cssDefinition
                            syn match cssPagePseudo /:\(left\|right\|first\|blank\)/ contained skipwhite skipnl
                            " @keyframe
                            " http://www.w3.org/TR/css3-animations/#keyframes
                            syn region cssAtRule start=/@\(-[a-z]\+-\)\=keyframes\>/ end=/\ze{/ skipwhite skipnl matchgroup=cssAtKeyword contains=cssVendor,cssComment nextgroup=cssDefinition
                            
                            syn region cssAtRule start=/@import\>/    end=/\ze;/ contains=cssStringQ,cssStringQQ,cssUnicodeEscape,cssComment,cssAtKeyword,cssURL,cssMediaProp,cssValueLength,cssAtRuleLogical,cssValueInteger,cssMediaAttr,cssMediaType
                            syn region cssAtRule start=/@charset\>/   end=/\ze;/ contains=cssStringQ,cssStringQQ,cssUnicodeEscape,cssComment,cssAtKeyword
                            syn region cssAtRule start=/@namespace\>/ end=/\ze;/ contains=cssStringQ,cssStringQQ,cssUnicodeEscape,cssComment,cssAtKeyword
                            
                            " @supports
                            " https://www.w3.org/TR/css3-conditional/#at-supports
                            syn region cssAtRule start=/@supports\>/ end=/\ze{/ skipwhite skipnl contains=cssAtRuleLogical,cssAttrRegion,css.*Prop,cssValue.*,cssVendor,cssAtKeyword,cssComment nextgroup=cssDefinition
                            
                            
                            if main_syntax == "css"
                              syn sync minlines=10
                            endif
                            
                            " Define the default highlighting.
                            " Only when an item doesn't have highlighting yet
                            
                            hi def link cssComment Comment
                            hi def link cssVendor Comment
                            hi def link cssHacks Comment
                            hi def link cssTagName Statement
                            hi def link cssDeprecated Error
                            hi def link cssSelectorOp Special
                            hi def link cssSelectorOp2 Special
                            hi def link cssAttrComma Special
                            
                            hi def link cssAnimationProp cssProp
                            hi def link cssBackgroundProp cssProp
                            hi def link cssBorderProp cssProp
                            hi def link cssBoxProp cssProp
                            hi def link cssCascadeProp cssProp
                            hi def link cssColorProp cssProp
                            hi def link cssContentForPagedMediaProp cssProp
                            hi def link cssDimensionProp cssProp
                            hi def link cssFlexibleBoxProp cssProp
                            hi def link cssFontProp cssProp
                            hi def link cssGeneratedContentProp cssProp
                            hi def link cssGridProp cssProp
                            hi def link cssHyerlinkProp cssProp
                            hi def link cssInteractProp cssProp
                            hi def link cssLineboxProp cssProp
                            hi def link cssListProp cssProp
                            hi def link cssMarqueeProp cssProp
                            hi def link cssMultiColumnProp cssProp
                            hi def link cssPagedMediaProp cssProp
                            hi def link cssPositioningProp cssProp
                            hi def link cssObjectProp cssProp
                            hi def link cssPrintProp cssProp
                            hi def link cssRubyProp cssProp
                            hi def link cssSpeechProp cssProp
                            hi def link cssTableProp cssProp
                            hi def link cssTextProp cssProp
                            hi def link cssTransformProp cssProp
                            hi def link cssTransitionProp cssProp
                            hi def link cssUIProp cssProp
                            hi def link cssIEUIProp cssProp
                            hi def link cssAuralProp cssProp
                            hi def link cssRenderProp cssProp
                            hi def link cssMobileTextProp cssProp
                            
                            hi def link cssAnimationAttr cssAttr
                            hi def link cssBackgroundAttr cssAttr
                            hi def link cssBorderAttr cssAttr
                            hi def link cssBoxAttr cssAttr
                            hi def link cssContentForPagedMediaAttr cssAttr
                            hi def link cssDimensionAttr cssAttr
                            hi def link cssFlexibleBoxAttr cssAttr
                            hi def link cssFontAttr cssAttr
                            hi def link cssGeneratedContentAttr cssAttr
                            hi def link cssGridAttr cssAttr
                            hi def link cssHyerlinkAttr cssAttr
                            hi def link cssInteractAttr cssAttr
                            hi def link cssLineboxAttr cssAttr
                            hi def link cssListAttr cssAttr
                            hi def link cssMarginAttr cssAttr
                            hi def link cssMarqueeAttr cssAttr
                            hi def link cssMultiColumnAttr cssAttr
                            hi def link cssPaddingAttr cssAttr
                            hi def link cssPagedMediaAttr cssAttr
                            hi def link cssPositioningAttr cssAttr
                            hi def link cssObjectAttr cssAttr
                            hi def link cssGradientAttr cssAttr
                            hi def link cssPrintAttr cssAttr
                            hi def link cssRubyAttr cssAttr
                            hi def link cssSpeechAttr cssAttr
                            hi def link cssTableAttr cssAttr
                            hi def link cssTextAttr cssAttr
                            hi def link cssTransformAttr cssAttr
                            hi def link cssTransitionAttr cssAttr
                            hi def link cssUIAttr cssAttr
                            hi def link cssIEUIAttr cssAttr
                            hi def link cssAuralAttr cssAttr
                            hi def link cssRenderAttr cssAttr
                            hi def link cssCascadeAttr cssAttr
                            hi def link cssCommonAttr cssAttr
                            
                            hi def link cssPseudoClassId PreProc
                            hi def link cssPseudoClassLang Constant
                            hi def link cssValueLength Number
                            hi def link cssValueInteger Number
                            hi def link cssValueNumber Number
                            hi def link cssValueAngle Number
                            hi def link cssValueTime Number
                            hi def link cssValueFrequency Number
                            hi def link cssFunction Constant
                            hi def link cssURL String
                            hi def link cssFunctionName Function
                            hi def link cssFunctionComma Function
                            hi def link cssColor Constant
                            hi def link cssIdentifier Function
                            hi def link cssAtRule Include
                            hi def link cssAtKeyword PreProc
                            hi def link cssImportant Special
                            hi def link cssCustomProp Special
                            hi def link cssBraces Function
                            hi def link cssBraceError Error
                            hi def link cssError Error
                            hi def link cssUnicodeEscape Special
                            hi def link cssStringQQ String
                            hi def link cssStringQ String
                            hi def link cssAttributeSelector String
                            hi def link cssMediaType Special
                            hi def link cssMediaComma Normal
                            hi def link cssAtRuleLogical Statement
                            hi def link cssMediaProp cssProp
                            hi def link cssMediaAttr cssAttr
                            hi def link cssPagePseudo PreProc
                            hi def link cssPageMarginProp cssAtKeyword
                            hi def link cssPageProp cssProp
                            hi def link cssKeyFrameProp Constant
                            hi def link cssFontDescriptor Special
                            hi def link cssFontDescriptorProp cssProp
                            hi def link cssFontDescriptorAttr cssAttr
                            hi def link cssUnicodeRange Constant
                            hi def link cssClassName Function
                            hi def link cssClassNameDot Function
                            hi def link cssProp StorageClass
                            hi def link cssAttr Constant
                            hi def link cssUnitDecorators Number
                            hi def link cssNoise Noise
                            
                            let b:current_syntax = "css"
                            
                            if main_syntax == 'css'
                              unlet main_syntax
                            endif
                            
                            let &cpo = s:cpo_save
                            unlet s:cpo_save
                            
                            " vim: ts=8

SCRIPT  C:\Users\Lenovo\AppData\Local\nvim-data\plugged\vim-polyglot\after\syntax\html.vim
Sourced 1 time
Total time:   0.000840
 Self time:   0.000727

count  total (s)   self (s)
    1   0.000467   0.000354 if polyglot#init#is_disabled(expand('<sfile>:p'), 'html5', 'after/syntax/html.vim')
                              finish
    1              0.000004 endif
                            
                            " Vim syntax file
                            " Language:     HTML (version 5.1)
                            " Last Change:  2017 Feb 15
                            " License:      Public domain
                            "               (but let me know if you like :) )
                            "
                            " Maintainer:   Kao, Wei-Ko(othree) ( othree AT gmail DOT com )
                            
                            " Comment
                            " https://github.com/w3c/html/issues/694
    1              0.000053 syntax region htmlComment start=+<!--+ end=+-->+ contains=@Spell
    1              0.000138 syntax region htmlComment start=+<!DOCTYPE+ keepend end=+>+

SCRIPT  C:\Users\Lenovo\scoop\apps\neovim\0.6.1\share\nvim\runtime\syntax\markdown.vim
Sourced 1 time
Total time:   0.000197
 Self time:   0.000197

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:     Markdown
                            " Maintainer:   Tim Pope <vimNOSPAM@tpope.org>
                            " Filenames:    *.markdown
                            " Last Change:  2020 Jan 14
                            
    1              0.000039 if exists("b:current_syntax")
    1              0.000008   finish
                            endif
                            
                            if !exists('main_syntax')
                              let main_syntax = 'markdown'
                            endif
                            
                            runtime! syntax/html.vim
                            unlet! b:current_syntax
                            
                            if !exists('g:markdown_fenced_languages')
                              let g:markdown_fenced_languages = []
                            endif
                            let s:done_include = {}
                            for s:type in map(copy(g:markdown_fenced_languages),'matchstr(v:val,"[^=]*$")')
                              if has_key(s:done_include, matchstr(s:type,'[^.]*'))
                                continue
                              endif
                              if s:type =~ '\.'
                                let b:{matchstr(s:type,'[^.]*')}_subtype = matchstr(s:type,'\.\zs.*')
                              endif
                              exe 'syn include @markdownHighlight'.substitute(s:type,'\.','','g').' syntax/'.matchstr(s:type,'[^.]*').'.vim'
                              unlet! b:current_syntax
                              let s:done_include[matchstr(s:type,'[^.]*')] = 1
                            endfor
                            unlet! s:type
                            unlet! s:done_include
                            
                            if !exists('g:markdown_minlines')
                              let g:markdown_minlines = 50
                            endif
                            execute 'syn sync minlines=' . g:markdown_minlines
                            syn case ignore
                            
                            syn match markdownValid '[<>]\c[a-z/$!]\@!' transparent contains=NONE
                            syn match markdownValid '&\%(#\=\w*;\)\@!' transparent contains=NONE
                            
                            syn match markdownLineStart "^[<@]\@!" nextgroup=@markdownBlock,htmlSpecialChar
                            
                            syn cluster markdownBlock contains=markdownH1,markdownH2,markdownH3,markdownH4,markdownH5,markdownH6,markdownBlockquote,markdownListMarker,markdownOrderedListMarker,markdownCodeBlock,markdownRule
                            syn cluster markdownInline contains=markdownLineBreak,markdownLinkText,markdownItalic,markdownBold,markdownCode,markdownEscape,@htmlTop,markdownError,markdownValid
                            
                            syn match markdownH1 "^.\+\n=\+$" contained contains=@markdownInline,markdownHeadingRule,markdownAutomaticLink
                            syn match markdownH2 "^.\+\n-\+$" contained contains=@markdownInline,markdownHeadingRule,markdownAutomaticLink
                            
                            syn match markdownHeadingRule "^[=-]\+$" contained
                            
                            syn region markdownH1 matchgroup=markdownH1Delimiter start="##\@!"      end="#*\s*$" keepend oneline contains=@markdownInline,markdownAutomaticLink contained
                            syn region markdownH2 matchgroup=markdownH2Delimiter start="###\@!"     end="#*\s*$" keepend oneline contains=@markdownInline,markdownAutomaticLink contained
                            syn region markdownH3 matchgroup=markdownH3Delimiter start="####\@!"    end="#*\s*$" keepend oneline contains=@markdownInline,markdownAutomaticLink contained
                            syn region markdownH4 matchgroup=markdownH4Delimiter start="#####\@!"   end="#*\s*$" keepend oneline contains=@markdownInline,markdownAutomaticLink contained
                            syn region markdownH5 matchgroup=markdownH5Delimiter start="######\@!"  end="#*\s*$" keepend oneline contains=@markdownInline,markdownAutomaticLink contained
                            syn region markdownH6 matchgroup=markdownH6Delimiter start="#######\@!" end="#*\s*$" keepend oneline contains=@markdownInline,markdownAutomaticLink contained
                            
                            syn match markdownBlockquote ">\%(\s\|$\)" contained nextgroup=@markdownBlock
                            
                            syn region markdownCodeBlock start="    \|\t" end="$" contained
                            
                            " TODO: real nesting
                            syn match markdownListMarker "\%(\t\| \{0,4\}\)[-*+]\%(\s\+\S\)\@=" contained
                            syn match markdownOrderedListMarker "\%(\t\| \{0,4}\)\<\d\+\.\%(\s\+\S\)\@=" contained
                            
                            syn match markdownRule "\* *\* *\*[ *]*$" contained
                            syn match markdownRule "- *- *-[ -]*$" contained
                            
                            syn match markdownLineBreak " \{2,\}$"
                            
                            syn region markdownIdDeclaration matchgroup=markdownLinkDelimiter start="^ \{0,3\}!\=\[" end="\]:" oneline keepend nextgroup=markdownUrl skipwhite
                            syn match markdownUrl "\S\+" nextgroup=markdownUrlTitle skipwhite contained
                            syn region markdownUrl matchgroup=markdownUrlDelimiter start="<" end=">" oneline keepend nextgroup=markdownUrlTitle skipwhite contained
                            syn region markdownUrlTitle matchgroup=markdownUrlTitleDelimiter start=+"+ end=+"+ keepend contained
                            syn region markdownUrlTitle matchgroup=markdownUrlTitleDelimiter start=+'+ end=+'+ keepend contained
                            syn region markdownUrlTitle matchgroup=markdownUrlTitleDelimiter start=+(+ end=+)+ keepend contained
                            
                            syn region markdownLinkText matchgroup=markdownLinkTextDelimiter start="!\=\[\%(\%(\_[^][]\|\[\_[^][]*\]\)*]\%( \=[[(]\)\)\@=" end="\]\%( \=[[(]\)\@=" nextgroup=markdownLink,markdownId skipwhite contains=@markdownInline,markdownLineStart
                            syn region markdownLink matchgroup=markdownLinkDelimiter start="(" end=")" contains=markdownUrl keepend contained
                            syn region markdownId matchgroup=markdownIdDelimiter start="\[" end="\]" keepend contained
                            syn region markdownAutomaticLink matchgroup=markdownUrlDelimiter start="<\%(\w\+:\|[[:alnum:]_+-]\+@\)\@=" end=">" keepend oneline
                            
                            let s:concealends = ''
                            if has('conceal') && get(g:, 'markdown_syntax_conceal', 1) == 1
                              let s:concealends = ' concealends'
                            endif
                            exe 'syn region markdownItalic matchgroup=markdownItalicDelimiter start="\S\@<=\*\|\*\S\@=" end="\S\@<=\*\|\*\S\@=" skip="\\\*" contains=markdownLineStart,@Spell' . s:concealends
                            exe 'syn region markdownItalic matchgroup=markdownItalicDelimiter start="\w\@<!_\S\@=" end="\S\@<=_\w\@!" skip="\\_" contains=markdownLineStart,@Spell' . s:concealends
                            exe 'syn region markdownBold matchgroup=markdownBoldDelimiter start="\S\@<=\*\*\|\*\*\S\@=" end="\S\@<=\*\*\|\*\*\S\@=" skip="\\\*" contains=markdownLineStart,markdownItalic,@Spell' . s:concealends
                            exe 'syn region markdownBold matchgroup=markdownBoldDelimiter start="\w\@<!__\S\@=" end="\S\@<=__\w\@!" skip="\\_" contains=markdownLineStart,markdownItalic,@Spell' . s:concealends
                            exe 'syn region markdownBoldItalic matchgroup=markdownBoldItalicDelimiter start="\S\@<=\*\*\*\|\*\*\*\S\@=" end="\S\@<=\*\*\*\|\*\*\*\S\@=" skip="\\\*" contains=markdownLineStart,@Spell' . s:concealends
                            exe 'syn region markdownBoldItalic matchgroup=markdownBoldItalicDelimiter start="\w\@<!___\S\@=" end="\S\@<=___\w\@!" skip="\\_" contains=markdownLineStart,@Spell' . s:concealends
                            
                            syn region markdownCode matchgroup=markdownCodeDelimiter start="`" end="`" keepend contains=markdownLineStart
                            syn region markdownCode matchgroup=markdownCodeDelimiter start="`` \=" end=" \=``" keepend contains=markdownLineStart
                            syn region markdownCode matchgroup=markdownCodeDelimiter start="^\s*````*.*$" end="^\s*````*\ze\s*$" keepend
                            
                            syn match markdownFootnote "\[^[^\]]\+\]"
                            syn match markdownFootnoteDefinition "^\[^[^\]]\+\]:"
                            
                            if main_syntax ==# 'markdown'
                              let s:done_include = {}
                              for s:type in g:markdown_fenced_languages
                                if has_key(s:done_include, matchstr(s:type,'[^.]*'))
                                  continue
                                endif
                                exe 'syn region markdownHighlight'.substitute(matchstr(s:type,'[^=]*$'),'\..*','','').' matchgroup=markdownCodeDelimiter start="^\s*````*\s*\%({.\{-}\.\)\='.matchstr(s:type,'[^=]*').'}\=\S\@!.*$" end="^\s*````*\ze\s*$" keepend contains=@markdownHighlight'.substitute(matchstr(s:type,'[^=]*$'),'\.','','g') . s:concealends
                                let s:done_include[matchstr(s:type,'[^.]*')] = 1
                              endfor
                              unlet! s:type
                              unlet! s:done_include
                            endif
                            
                            syn match markdownEscape "\\[][\\`*_{}()<>#+.!-]"
                            syn match markdownError "\w\@<=_\w\@="
                            
                            hi def link markdownH1                    htmlH1
                            hi def link markdownH2                    htmlH2
                            hi def link markdownH3                    htmlH3
                            hi def link markdownH4                    htmlH4
                            hi def link markdownH5                    htmlH5
                            hi def link markdownH6                    htmlH6
                            hi def link markdownHeadingRule           markdownRule
                            hi def link markdownH1Delimiter           markdownHeadingDelimiter
                            hi def link markdownH2Delimiter           markdownHeadingDelimiter
                            hi def link markdownH3Delimiter           markdownHeadingDelimiter
                            hi def link markdownH4Delimiter           markdownHeadingDelimiter
                            hi def link markdownH5Delimiter           markdownHeadingDelimiter
                            hi def link markdownH6Delimiter           markdownHeadingDelimiter
                            hi def link markdownHeadingDelimiter      Delimiter
                            hi def link markdownOrderedListMarker     markdownListMarker
                            hi def link markdownListMarker            htmlTagName
                            hi def link markdownBlockquote            Comment
                            hi def link markdownRule                  PreProc
                            
                            hi def link markdownFootnote              Typedef
                            hi def link markdownFootnoteDefinition    Typedef
                            
                            hi def link markdownLinkText              htmlLink
                            hi def link markdownIdDeclaration         Typedef
                            hi def link markdownId                    Type
                            hi def link markdownAutomaticLink         markdownUrl
                            hi def link markdownUrl                   Float
                            hi def link markdownUrlTitle              String
                            hi def link markdownIdDelimiter           markdownLinkDelimiter
                            hi def link markdownUrlDelimiter          htmlTag
                            hi def link markdownUrlTitleDelimiter     Delimiter
                            
                            hi def link markdownItalic                htmlItalic
                            hi def link markdownItalicDelimiter       markdownItalic
                            hi def link markdownBold                  htmlBold
                            hi def link markdownBoldDelimiter         markdownBold
                            hi def link markdownBoldItalic            htmlBoldItalic
                            hi def link markdownBoldItalicDelimiter   markdownBoldItalic
                            hi def link markdownCodeDelimiter         Delimiter
                            
                            hi def link markdownEscape                Special
                            hi def link markdownError                 Error
                            
                            let b:current_syntax = "markdown"
                            if main_syntax ==# 'markdown'
                              unlet main_syntax
                            endif
                            
                            " vim:set sw=2:

SCRIPT  C:\Users\Lenovo\AppData\Local\nvim-data\plugged\neoterm\autoload\neoterm.vim
Sourced 1 time
Total time:   0.001789
 Self time:   0.001789

count  total (s)   self (s)
    1              0.000024 function! neoterm#new(...) abort
                              if exists('*g:neoterm_callbacks.before_new')
                                call g:neoterm_callbacks.before_new()
                              end
                            
                              let l:instance = neoterm#term#new(get(a:, 1, {}))
                            
                              if !l:instance.from_session
                                call s:create_window(l:instance)
                              end
                            
                              let l:instance.buffer_id = bufnr('')
                              let l:instance.id = g:neoterm.next_id()
                              let l:instance.name = printf('neoterm-%s', l:instance.id)
                              let t:neoterm_id = l:instance.id
                            
                              if !l:instance.from_session
                                let l:instance.termid = l:instance.new(l:instance)
                              end
                            
                              call s:after_open(l:instance)
                            
                              let g:neoterm.instances[l:instance.id] = l:instance
                            
                              call s:update_last_active(l:instance)
                            
                              return l:instance
                            endfunction
                            
    1              0.000009 function! neoterm#load_session() abort
                              let l:id = neoterm#term#current_id()
                            
                              if get(g:, 'SessionLoad', 0) && index(g:neoterm.ids(), l:id) < 0
                                call neoterm#new({'from_session': 1, 'id': l:id, 'termid': l:id})
                              end
                            endfunction
                            
    1              0.000007 function! neoterm#open(...) abort
                              let l:opts = extend(a:1, { 'mod': '', 'target': 0 }, 'keep')
                              let l:instance = neoterm#target#get(l:opts)
                            
                              if empty(l:instance)
                                call neoterm#new(l:opts)
                              elseif bufwinnr(l:instance.buffer_id) == -1
                                let l:instance.origin = neoterm#origin#new()
                                call s:update_last_active(l:instance)
                                call s:create_window(l:instance)
                                call s:after_open(l:instance)
                            
                                let g:neoterm.last_active = l:instance.id
                                if g:neoterm_autoscroll
                                  call l:instance.normal('G')
                                end
                              end
                            endfunction
                            
    1              0.000007 function! neoterm#close(...) abort
                              let l:opts = extend(a:1, { 'target': 0, 'force': 0 }, 'keep')
                              let l:instance = neoterm#target#get(l:opts)
                            
                              if !empty(l:instance)
                                let l:instance.origin = neoterm#origin#new()
                            
                                try
                                  if l:opts.force || !g:neoterm_keep_term_open
                                    exec printf('%sbdelete!', l:instance.buffer_id)
                                  else
                                    exec printf('%shide', bufwinnr(l:instance.buffer_id))
                                  end
                            
                                  call neoterm#origin#return(l:instance.origin)
                                catch /.*E444/
                                  throw 'Error: neoterm is the only opened window. To close it use `:Tclose!`'
                                endtry
                              end
                            endfunction
                            
    1              0.000007 function! neoterm#closeAll(...) abort
                              for l:instance in values(g:neoterm.instances)
                                call neoterm#close(extend(a:1, { 'target': l:instance.id }))
                              endfor
                            endfunction
                            
    1              0.000013 function! s:after_open(instance) abort
                              let b:neoterm_id = a:instance.id
                              let b:term_title = a:instance.name
                              setf neoterm
                              setlocal nonumber norelativenumber signcolumn=auto
                            
                              if g:neoterm_fixedsize
                                setlocal winfixheight winfixwidth
                              end
                            
                              if g:neoterm_keep_term_open
                                setlocal bufhidden=hide
                              end
                            
                              if g:neoterm_autoinsert
                                startinsert
                              elseif !g:neoterm_autojump
                                call neoterm#origin#return(a:instance.origin)
                              end
                            endfunction
                            
    1              0.000007 function! neoterm#toggle(...) abort
                              let l:opts = extend(a:1, { 'mod': '', 'target': 0 }, 'keep')
                              let l:instance = neoterm#target#get(l:opts)
                            
                              if empty(l:instance)
                                call neoterm#new(l:opts)
                              else
                                if bufwinnr(l:instance.buffer_id) > 0
                                  try
                                    call neoterm#close(l:opts)
                                  catch
                                    echoe v:exception
                                  endtry
                                else
                                  call neoterm#open(l:opts)
                                end
                              end
                            endfunction
                            
    1              0.000006 function! neoterm#toggleAll() abort
                              for l:id in keys(g:neoterm.instances)
                                call neoterm#toggle({ 'target': l:id })
                              endfor
                            endfunction
                            
    1              0.000015 function! neoterm#do(opts) abort
                              let l:opts = extend(a:opts, { 'mod': '', 'target': 0 }, 'keep')
                              let l:opts.cmd = [l:opts.cmd, g:neoterm_eof]
                            
                              let g:neoterm.last_command = l:opts
                            
                              call neoterm#exec(l:opts)
                            endfunction
                            
    1              0.000010 function neoterm#redo() abort
                              if type(g:neoterm.last_command) != type(v:null)
                                call neoterm#exec(g:neoterm.last_command)
                              end
                            endfunction
                            
    1              0.000044 function! neoterm#exec(opts) abort
                              if exists('*g:neoterm_callbacks.before_exec')
                                call g:neoterm_callbacks.before_exec()
                              end
                            
                              let l:command = map(copy(a:opts.cmd), { i, cmd -> s:expand(cmd) })
                              let l:instance = neoterm#target#get({ 'target': get(a:opts, 'target', 0) })
                            
                              if s:requires_new_instance(l:instance)
                                let l:instance = neoterm#new(a:opts)
                              end
                            
                              if !empty(l:instance)
                                call s:update_last_active(l:instance)
                                call l:instance.exec(l:command)
                            
                                if get(a:opts, 'force_clear', 0)
                                  let l:bufname = bufname(l:instance.buffer_id)
                                  let l:scrollback = getbufvar(l:bufname, '&scrollback')
                            
                                  call setbufvar(l:bufname, '&scrollback', 1)
                                  sleep 100m
                                  call setbufvar(l:bufname, '&scrollback', l:scrollback)
                                end
                              end
                            endfunction
                            
    1              0.000016 function! s:requires_new_instance(instance) abort
                              return
                                    \ (
                                    \   empty(a:instance) &&
                                    \   g:neoterm_term_per_tab &&
                                    \   !has_key(t:, 'neoterm_id')
                                    \ ) || (
                                    \   empty(a:instance) &&
                                    \   !g:neoterm.has_any()
                                    \ )
                            endfunction
                            
    1              0.000006 function! neoterm#map_for(...) abort
                              let g:neoterm.map_options = extend(a:1, {
                                    \ 'target': 0,
                                    \ 'update_last_active': v:false
                                    \ }, 'keep')
                            endfunction
                            
    1              0.000006 function! neoterm#map_do() abort
                              call neoterm#do(copy(g:neoterm.map_options))
                            endfunction
                            
    1              0.000005 function! neoterm#clear(...) abort
                              call neoterm#exec(extend(a:1, {
                                    \ 'cmd': g:neoterm_clear_cmd,
                                    \ 'force_clear': 0
                                    \ }, 'keep'))
                            endfunction
                            
    1              0.000006 function! neoterm#kill(...) abort
                              call neoterm#exec(extend(a:1, { 'cmd': ["\<c-c>"] }))
                            endfunction
                            
    1              0.000007 function! neoterm#normal(cmd) abort
                              silent call g:neoterm.last().normal(a:cmd)
                            endfunction
                            
    1              0.000008 function! neoterm#vim_exec(cmd) abort
                              silent call g:neoterm.last().vim_exec(a:cmd)
                            endfunction
                            
    1              0.000015 function! neoterm#list(arg_lead, cmd_line, cursor_pos) abort
                              return filter(keys(g:neoterm.instances), 'v:val =~? "'. a:arg_lead. '"')
                            endfunction
                            
    1              0.000008 function! neoterm#next() abort
                              function! s:next(ids, index) abort
                                let l:next_index = a:index +1
                                return l:next_index > (len(a:ids) - 1) ? 0 : l:next_index
                              endfunction
                            
                              call s:navigate_with(function('s:next'))
                            endfunction
                            
    1              0.000010 function! neoterm#previous() abort
                              call s:navigate_with({ _, i -> i - 1 })
                            endfunction
                            
    1              0.000013 function! neoterm#destroy(instance) abort
                              if has_key(g:neoterm, 'repl') && get(g:neoterm.repl, 'instance_id') ==# a:instance.id
                                call remove(g:neoterm.repl, 'instance_id')
                              end
                            
                              if has_key(g:neoterm.instances, a:instance.id)
                                if bufexists(a:instance.buffer_id)
                                  silent! exec printf('%sbdelete!', a:instance.buffer_id)
                                end
                                call remove(g:neoterm.instances, a:instance.id)
                              end
                            
                              if has_key(t:, 'neoterm_id')
                                unlet! t:neoterm_id
                              end
                            
                              if g:neoterm.last_active == a:instance.id
                                let g:neoterm.last_active = 0
                              end
                            endfunction
                            
    1              0.000008 function! neoterm#list_ids() abort
                              echom 'Open neoterm ids:'
                              for id in keys(g:neoterm.instances)
                                echom printf('ID: %s | name: %s | bufnr: %s',
                                      \ id,
                                      \ g:neoterm.instances[id].name,
                                      \ g:neoterm.instances[id].buffer_id)
                              endfor
                            endfunction
                            
    1              0.000016 function! s:create_window(instance) abort
                              let l:instance = a:instance
                            
                              if empty(l:instance.mod)
                                let l:instance.mod = g:neoterm_default_mod
                              end
                            
                              if exists('*g:neoterm_callbacks.before_create_window')
                                call g:neoterm_callbacks.before_create_window(l:instance)
                              end
                            
                              let l:instance.size = neoterm#args#size(get(l:instance, 'args', ''), g:neoterm_size)
                            
                              if l:instance.mod !=# ''
                                let l:hidden=&hidden
                                let &hidden=0
                            
                                let l:cmd = printf('%s %snew', l:instance.mod, l:instance.size)
                                if l:instance.buffer_id > 0
                                  let l:cmd .= printf(' +buffer%s', l:instance.buffer_id)
                                end
                            
                                exec l:cmd
                            
                                let &hidden=l:hidden
                              elseif get(l:instance, 'buffer_id', 0) > 0 && bufnr('') != l:instance.buffer_id
                                exec printf('buffer %s', l:instance.buffer_id)
                              else
                                enew
                              end
                            endfunction
                            
    1              0.000012 function! s:navigate_with(callback) abort
                              if &buftype ==? 'terminal'
                                if len(g:neoterm.instances) > 1
                                  let l:ids = keys(g:neoterm.instances)
                                  let l:current_index = index(l:ids, string(b:neoterm_id))
                                  let l:id = l:ids[a:callback(l:ids, l:current_index)]
                                  let g:neoterm.last_active = l:id
                            
                                  let l:hidden = &hidden
                                  set hidden
                                  exec printf('%sbuffer', g:neoterm.instances[l:id].buffer_id)
                                  let &hidden = l:hidden
                                else
                                  echo 'You do not have other terminals'
                                end
                              else
                                echo 'You must be in a terminal to use this command'
                              end
                            endfunction
                            
    1              0.000010 function! s:expand(command) abort
                              let l:command = substitute(a:command, '[^\\]\zs%\(:[phtre]\)\+', '\=expand(submatch(0))', 'g')
                              let l:command = substitute(l:command, '\c\\<cr>', g:neoterm_eof, 'g')
                              let l:path = g:neoterm_use_relative_path ? expand('%') : expand('%:p')
                            
                              let l:command = substitute(l:command, '[^\\]\zs%', l:path, 'g')
                              let l:command = substitute(l:command, '\\%', '%', 'g')
                            
                              return l:command
                            endfunction
                            
    1              0.000008 function! s:update_last_active(instance) abort
                              let g:neoterm.last_active = a:instance.id
                            endfunction
                            
                            " Calculates the next neoterm's ID.
                            " Returns the minimum next available id, an id not related
                            " to an neoterm instance.
    1              0.000008 function! neoterm#next_id(ids, last_id)
                              let l:ids = map(a:ids, {_, v -> str2nr(v) })
                            
                              for i in range(1, max(l:ids) + 1)
                                if index(l:ids, i) < 0
                                  let l:last_id = i
                                  return l:last_id
                                end
                              endfor
                            
                              return a:last_id + 1
                            endfunction

SCRIPT  C:\Users\Lenovo\AppData\Local\nvim-data\plugged\neoterm\autoload\neoterm\target.vim
Sourced 1 time
Total time:   0.000420
 Self time:   0.000420

count  total (s)   self (s)
    1              0.000032 let s:not_found_msg = 'neoterm-%s not found (probably already closed)'
                            
    1              0.000014 function! neoterm#target#get(opts) abort
                              let l:instance = s:get(a:opts)
                            
                              return s:set_instance_opts(l:instance, a:opts)
                            endfunction
                            
    1              0.000012 function! s:get(opts) abort
                              if a:opts.target > 0
                                return s:given_target(a:opts.target)
                              elseif g:neoterm_term_per_tab
                                return s:target_per_tab()
                              elseif g:neoterm.has_any()
                                return s:ensure_instance(g:neoterm.last())
                              else
                                return {}
                              end
                            endfunction
                            
    1              0.000009 function! s:given_target(target) abort
                              if has_key(g:neoterm.instances, a:target)
                                return s:ensure_instance(g:neoterm.instances[a:target])
                              else
                                echo printf(s:not_found_msg, a:target)
                                return {}
                              end
                            endfunction
                            
    1              0.000008 function! s:target_per_tab() abort
                              if has_key(t:, 'neoterm_id') && has_key(g:neoterm.instances, t:neoterm_id)
                                return s:ensure_instance(g:neoterm.instances[t:neoterm_id])
                              elseif !has_key(t:, 'neoterm_id')
                                return {}
                              else
                                echo printf(s:not_found_msg, t:neoterm_id)
                                return {}
                              end
                            endfunction
                            
    1              0.000008 function! s:ensure_instance(instance) abort
                              if bufexists(a:instance.buffer_id)
                                return a:instance
                              else
                                echo printf(s:not_found_msg, a:instance.id)
                                call neoterm#destroy(a:instance)
                                return {}
                              end
                            endfunction
                            
    1              0.000009 function! s:set_instance_opts(instance, opts)
                              if empty(a:instance)
                                return a:instance
                              end
                            
                              for [key, value] in items(a:opts)
                                if !empty(value)
                                  let a:instance[key] = value
                                end
                              endfor
                            
                              return a:instance
                            endfunction

SCRIPT  C:\Users\Lenovo\AppData\Local\nvim-data\plugged\neoterm\autoload\neoterm\term.vim
Sourced 1 time
Total time:   0.000516
 Self time:   0.000516

count  total (s)   self (s)
    1              0.000024 function! neoterm#term#new(opts) abort
                              return extend(
                                    \   extend(copy(s:term), copy(s:adapter()), 'error'),
                                    \   neoterm#default#opts(a:opts)
                                    \ )
                            endfunction
                            
    1              0.000009 function! neoterm#term#current_id()
                              return s:adapter().get_current_termid()
                            endfunction
                            
    1              0.000011 function! s:adapter()
                              return get(g:neoterm, 'adapter', s:set_adapter())
                            endfunction
                            
    1              0.000007 function! s:set_adapter()
                              if !has_key(g:neoterm, 'adapter')
                                if has('nvim')
                                  let g:neoterm.adapter = neoterm#term#neovim#()
                                elseif has('terminal')
                                  let g:neoterm.adapter = neoterm#term#vim#()
                                else
                                  throw 'neoterm does not support your vim/neovim version'
                                end
                              end
                            
                              return g:neoterm.adapter
                            endfunction
                            
    1              0.000015 let s:term = {}
                            
    1              0.000009 function! s:term.vim_exec(cmd) abort
                              let l:winnr = bufwinnr(l:self.buffer_id)
                              if l:winnr > 0
                                let l:win_id = exists('*win_getid') ? win_getid() : 0
                                exec printf('%swincmd w', l:winnr)
                                call execute(a:cmd)
                                call win_gotoid(l:win_id)
                              end
                            endfunction
                            
    1              0.000007 function! s:term.normal(cmd) abort
                              call l:self.vim_exec(printf('normal! %s', a:cmd))
                            endfunction
                            
    1              0.000007 function! s:term.exec(command) abort
                              if !empty(g:neoterm_command_prefix)
                                call l:self.termsend(l:self.termid, [g:neoterm_command_prefix . a:command[0]] + a:command[1:])
                              else
                                call l:self.termsend(l:self.termid, a:command)
                              end
                              if g:neoterm_autoscroll
                                call l:self.normal('G')
                              end
                            endfunction
                            
    1              0.000008 function! s:term.on_stdout(...) abort
                              if has_key(l:self.handlers, 'on_stdout')
                                call l:self.handlers['on_stdout'](a:)
                              end
                            endfunction
                            
    1              0.000005 function! s:term.on_stderr(...) abort
                              if has_key(l:self.handlers, 'on_stderr')
                                call l:self.handlers['on_stderr'](a:)
                              end
                            endfunction
                            
    1              0.000005 function! s:term.on_exit(...) abort
                              if has_key(l:self.handlers, 'on_exit')
                                call l:self.handlers['on_exit'](a:)
                              end
                              call neoterm#destroy(l:self)
                            endfunction

SCRIPT  C:\Users\Lenovo\AppData\Local\nvim-data\plugged\neoterm\autoload\neoterm\term\neovim.vim
Sourced 1 time
Total time:   0.000308
 Self time:   0.000308

count  total (s)   self (s)
    1              0.000048 function! neoterm#term#neovim#() abort
                              return s:neovim
                            endfunction
                            
    1              0.000014 let s:neovim = {}
                            
    1              0.000010 function! s:neovim.new(opts) abort
                              return termopen(s:shell(a:opts), a:opts)
                            endfunction
                            
    1              0.000008 function! s:neovim.termsend(termid, command) abort
                              return chansend(a:termid, a:command)
                            endfunction
                            
    1              0.000006 function! s:neovim.get_current_termid() abort
                              return b:terminal_job_id
                            endfunction
                            
    1              0.000008 function! s:shell(opts)
                              if g:neoterm_marker ==# ''
                                return a:opts.shell
                              else
                                return printf('%s%s-%s', a:opts.shell, g:neoterm_marker, a:opts.id)
                              end
                            endfunction

SCRIPT  C:\Users\Lenovo\AppData\Local\nvim-data\plugged\neoterm\autoload\neoterm\default.vim
Sourced 1 time
Total time:   0.000204
 Self time:   0.000204

count  total (s)   self (s)
    1              0.000026 function! neoterm#default#opts(opts) abort
                              let l:default_opts = {
                                    \ 'handlers': {},
                                    \ 'mod': '',
                                    \ 'buffer_id': 0,
                                    \ 'from_session': v:false,
                                    \ 'origin': neoterm#origin#new(),
                                    \ 'size': g:neoterm_size,
                                    \ 'shell': g:neoterm_shell
                                    \ }
                              return extend(copy(a:opts), l:default_opts, 'keep')
                            endfunction

SCRIPT  C:\Users\Lenovo\AppData\Local\nvim-data\plugged\neoterm\autoload\neoterm\origin.vim
Sourced 1 time
Total time:   0.000237
 Self time:   0.000237

count  total (s)   self (s)
    1              0.000025 function! neoterm#origin#new() abort
                              return {
                                    \ 'win_id': exists('*win_getid') ? win_getid() : 0,
                                    \ 'last_buffer_id': bufnr('#')
                                    \ }
                            endfunction
                            
    1              0.000011 function! neoterm#origin#return(origin, ...) abort
                              if get(a:, 1, '') ==# 'buffer'
                                exec printf('buffer %s', a:origin.last_buffer_id)
                              elseif a:origin.win_id
                                call win_gotoid(a:origin.win_id)
                              else
                                wincmd p
                              end
                            endfunction

SCRIPT  C:\Users\Lenovo\AppData\Local\nvim-data\plugged\neoterm\autoload\neoterm\args.vim
Sourced 1 time
Total time:   0.000205
 Self time:   0.000205

count  total (s)   self (s)
    1              0.000030 function! neoterm#args#size(args, default) abort
                              let l:size = str2nr(matchstr(a:args, 'resize=\zs\d\+'))
                              let l:size = l:size > 0 ? l:size : a:default
                            
                              return str2nr(l:size) == 0 ? '' : l:size
                            endfunction

FUNCTION  <SNR>53_dopopd()
    Defined: ~\.fzf\plugin\fzf.vim:592
Called 29 times
Total time:   0.000560
 Self time:   0.000560

count  total (s)   self (s)
   29              0.000347   if !exists('w:fzf_pushd')
   29              0.000103     return
                              endif
                            
                              " FIXME: We temporarily change the working directory to 'dir' entry
                              " of options dictionary (set to the current working directory if not given)
                              " before running fzf.
                              "
                              " e.g. call fzf#run({'dir': '/tmp', 'source': 'ls', 'sink': 'e'})
                              "
                              " After processing the sink function, we have to restore the current working
                              " directory. But doing so may not be desirable if the function changed the
                              " working directory on purpose.
                              "
                              " So how can we tell if we should do it or not? A simple heuristic we use
                              " here is that we change directory only if the current working directory
                              " matches 'dir' entry. However, it is possible that the sink function did
                              " change the directory to 'dir'. In that case, the user will have an
                              " unexpected result.
                              if s:fzf_getcwd() ==# w:fzf_pushd.dir && (!&autochdir || w:fzf_pushd.bufname ==# bufname(''))
                                execute w:fzf_pushd.command s:escape(w:fzf_pushd.origin)
                              endif
                              unlet! w:fzf_pushd

FUNCTION  <SNR>122_find_opening_paren()
    Defined: ~\AppData\Local\nvim-data\plugged\vim-polyglot\indent\python.vim:117
Called 2 times
Total time:   0.136239
 Self time:   0.024420

count  total (s)   self (s)
                                " Return if cursor is in a comment.
    2              0.000465     if synIDattr(synID(a:lnum, a:col, 0), 'name') =~? 'comment'
                                    return [0, 0]
    2              0.000004     endif
                            
    2              0.000031     call cursor(a:lnum, a:col)
                            
    2              0.000019     let nearest = [0, 0]
    2              0.000022     let timeout = g:python_pep8_indent_searchpair_timeout
    2              0.000019     let skip_special_chars = 's:_skip_special_chars(line("."), col("."))'
    8              0.000100     for [p, maxoff] in items(s:paren_pairs)
    6              0.000153         let stopline = max([0, line('.') - maxoff, nearest[0]])
    6   0.134975   0.023155         let next = searchpairpos( '\V'.p[0], '', '\V'.p[1], 'bnW', skip_special_chars, stopline, timeout)
    6              0.000170         if next[0] && (next[0] > nearest[0] || (next[0] == nearest[0] && next[1] > nearest[1]))
                                        let nearest = next
    6              0.000023         endif
    8              0.000030     endfor
    2              0.000013     return nearest

FUNCTION  <SNR>143_add_snr()
    Defined: ~\AppData\Local\nvim-data\plugged\tagbar\autoload\tagbar\prototypes\normaltag.vim:173
Called 2715 times
Total time:   0.069554
 Self time:   0.069554

count  total (s)   self (s)
 2715              0.019373     if !exists('s:snr')
    1              0.000069         let s:snr = matchstr(expand('<sfile>'), '<SNR>\d\+_\zeget_snr$')
 2715              0.004093     endif
 2715              0.014215     return s:snr . a:funcname

FUNCTION  leaderf#LfPy()
    Defined: ~\AppData\Local\nvim-data\plugged\LeaderF\autoload\leaderf.vim:349
Called 1 time
Total time:   0.005806
 Self time:   0.005806

count  total (s)   self (s)
    1              0.005800     exec g:Lf_py . a:cmd

FUNCTION  dist#ft#FTnroff()
    Defined: ~\scoop\apps\neovim\0.6.1\share\nvim\runtime\autoload\dist\ft.vim:359
Called 1 time
Total time:   0.000107
 Self time:   0.000107

count  total (s)   self (s)
    1              0.000081   if getline(1)[0] . getline(2)[0] . getline(3)[0] . getline(4)[0] . getline(5)[0] =~ '\.'
                                setf nroff
                                return 1
    1              0.000003   endif
    1              0.000004   return 0

FUNCTION  lfMru#record()
    Defined: ~\AppData\Local\nvim-data\plugged\LeaderF\autoload\lfMru.vim:30
Called 70 times
Total time:   0.091376
 Self time:   0.091376

count  total (s)   self (s)
   70              0.022762     if a:name == '' || !filereadable(a:name) || strpart(a:name, 0, 2) == '\\'
   16              0.000074         return
   54              0.000160     endif
   54              0.032345     let file_list = readfile(g:Lf_MruCacheFileName)
   54              0.000880     if empty(file_list)
                                    call writefile([a:name], g:Lf_MruCacheFileName)
   54              0.000778     elseif a:name != file_list[0]
   22              0.001925         call filter(file_list, 'v:val != a:name')
   22              0.025503         call writefile([a:name] + file_list, g:Lf_MruCacheFileName)
   54              0.000274     endif

FUNCTION  1()
    Defined: ~\AppData\Local\nvim-data\plugged\neoterm\plugin\neoterm.vim:16
Called 1 time
Total time:   0.000331
 Self time:   0.000068

count  total (s)   self (s)
    1   0.000315   0.000052   let l:self.last_id = neoterm#next_id( l:self.ids(), l:self.last_id )
                            
    1              0.000009   return l:self.last_id

FUNCTION  2()
    Defined: ~\AppData\Local\nvim-data\plugged\neoterm\plugin\neoterm.vim:25
Called 1 time
Total time:   0.000041
 Self time:   0.000041

count  total (s)   self (s)
    1              0.000039   return map(keys(self.instances), {_, v -> str2nr(v) })

FUNCTION  3()
    Defined: ~\AppData\Local\nvim-data\plugged\neoterm\plugin\neoterm.vim:29
Called 12 times
Total time:   0.000196
 Self time:   0.000196

count  total (s)   self (s)
   12              0.000162   return !empty(l:self.instances)

FUNCTION  4()
    Defined: ~\AppData\Local\nvim-data\plugged\neoterm\plugin\neoterm.vim:33
Called 5 times
Total time:   0.000376
 Self time:   0.000302

count  total (s)   self (s)
    5   0.000201   0.000127   if l:self.has_any()
    5              0.000085     if has_key(l:self.instances, l:self.last_active)
    5              0.000061       return l:self.instances[l:self.last_active]
                                else
                                  let l:keys = keys(g:neoterm.instances)
                                  return l:self.instances[l:keys[-1]]
                                end
                              end

FUNCTION  remote#host#Require()
    Defined: ~\scoop\apps\neovim\0.6.1\share\nvim\runtime\autoload\remote\host.vim:33
Called 1 time
Total time:   0.000152
 Self time:   0.000152

count  total (s)   self (s)
    1              0.000024   if !has_key(s:hosts, a:name)
                                throw 'No host named "'.a:name.'" is registered'
    1              0.000005   endif
    1              0.000019   let host = s:hosts[a:name]
    1              0.000013   if !host.channel && !host.initialized
                                let host_info = { 'name': a:name, 'orig_name': get(host, 'orig_name', a:name) }
                                let host.channel = call(host.factory, [host_info])
                                let host.initialized = 1
    1              0.000003   endif
    1              0.000010   return host.channel

FUNCTION  AutoPairsSpace()
    Defined: ~\AppData\Local\nvim-data\plugged\auto-pairs\plugin\auto-pairs.vim:423
Called 16 times
Total time:   0.016868
 Self time:   0.011767

count  total (s)   self (s)
   16              0.000329   if !b:autopairs_enabled
                                return "\<SPACE>"
   16              0.000055   end
                            
   16   0.006095   0.000995   let [before, after, ig] = s:getline()
                            
  164              0.001525   for [open, close, opt] in b:AutoPairsList
  148              0.000795     if close == ''
    4              0.000015       continue
  144              0.000244     end
  144              0.003286     if before =~ '\V'.open.'\v$' && after =~ '^\V'.close
                                  if close =~ '\v^[''"`]$'
                                    return "\<SPACE>"
                                  else
                                    return "\<SPACE>\<SPACE>".s:Left
                                  end
  144              0.000280     end
  160              0.000388   endfor
   16              0.000179   return "\<SPACE>"

FUNCTION  <SNR>21_right()
    Defined: ~\AppData\Local\nvim-data\plugged\auto-pairs\plugin\auto-pairs.vim:127
Called 10 times
Total time:   0.000902
 Self time:   0.000386

count  total (s)   self (s)
   10   0.000874   0.000359   return repeat(s:Right, s:ulen(a:s))

FUNCTION  <SNR>9_guess()
    Defined: ~\AppData\Local\nvim-data\plugged\vim-polyglot\autoload\polyglot\init.vim:2771
Called 46 times
Total time:   1.511663
 Self time:   1.457607

count  total (s)   self (s)
   46              0.000548     let options = {}
   46              0.000256     let ccomment = 0
   46              0.000221     let podcomment = 0
   46              0.000224     let triplequote = 0
   46              0.000183     let backtick = 0
   46              0.000233     let xmlcomment = 0
   46              0.000221     let heredoc = ''
   46              0.000216     let minindent = 10
   46              0.000288     let spaces_minus_tabs = 0
   46              0.000191     let lineno = 0
   46              0.000311     let stack = [0]
   46              0.000873     let indents = { '2': 0, '3': 0, '4': 0, '6': 0, '8': 0 }
                            
 4103              0.017459     for line in a:lines
 4057              0.018392       let lineno += 1
                            
 4057              0.057037       if line =~# '^\s*$'
  503              0.001340         continue
 3554              0.005599       endif
                            
 3554              0.051059       if line =~# '^\s*/\*'
                                    let ccomment = 1
 3554              0.005753       endif
 3554              0.011637       if ccomment
                                    if line =~# '\*/'
                                      let ccomment = 0
                                    endif
                                    continue
 3554              0.005307       endif
                            
 3554              0.037226       if line =~# '^=\w'
                                    let podcomment = 1
 3554              0.005674       endif
 3554              0.015034       if podcomment
                                    if line =~# '^=\%(end\|cut\)\>'
                                      let podcomment = 0
                                    endif
                                    continue
 3554              0.005068       endif
                            
 3554              0.012290       if triplequote
  129              0.003031         if line =~# '^[^"]*"""[^"]*$'
   39              0.000184           let triplequote = 0
  129              0.000210         endif
  129              0.000278         continue
 3425              0.088333       elseif line =~# '^[^"]*"""[^"]*$'
   39              0.000198         let triplequote = 1
 3425              0.005396       endif
                            
 3425              0.011138       if backtick
                                    if line =~# '^[^`]*`[^`]*$'
                                      let backtick = 0
                                    endif
                                    continue
 3425              0.028441       elseif &filetype ==# 'go' && line =~# '^[^`]*`[^`]*$'
                                    let backtick = 1
 3425              0.005312       endif
                            
 3425              0.050292       if line =~# '^\s*<\!--'
                                    let xmlcomment = 1
 3425              0.005437       endif
 3425              0.010793       if xmlcomment
                                    if line =~# '-->'
                                      let xmlcomment = 0
                                    endif
                                    continue
 3425              0.005007       endif
                            
                                  " This is correct order because both "<<EOF" and "EOF" matches end
 3425              0.017057       if heredoc != ''
                                    if line =~# heredoc
                                      let heredoc = ''
                                    endif
                                    continue
 3425              0.004980       endif
 3425              0.092888       let herematch = matchlist(line, '\C<<\W*\([A-Z]\+\)\s*$')
 3425              0.026266       if len(herematch) > 0
                                    let heredoc = herematch[1] . '$'
 3425              0.005893       endif
                            
 3425              0.022343       if line[0] == "\t"
                                    let spaces_minus_tabs -= 1
 3425              0.006632       else
 3425              0.025215         if line[0] == " "
 2087              0.012788           let spaces_minus_tabs += 1
 3425              0.006035         endif
 3425              0.079073         let indent = len(matchstr(line, '^ *'))
 3867              0.026998         while stack[-1] > indent
  442              0.004232           call remove(stack, -1)
 3867              0.009391         endwhile
                            
 3425              0.027571         let indent_inc = indent - stack[-1]
                            
 3425              0.031464         if indent_inc == 0 && len(stack) > 1
 1626              0.011684           let indent_inc = indent - stack[-2]
 3425              0.005866         endif
                            
 3425              0.038729         if has_key(indents, indent_inc)
 2076              0.016600           let indents[indent_inc] += 1
 2076              0.011550           let prev_indent = indent
 3425              0.005743         endif
                            
 3425              0.020726         if stack[-1] != indent
  461              0.004417           call add(stack, indent)
 3425              0.005796         endif
 3425              0.005543       endif
 3471              0.008546     endfor
                            
   46              0.000322     if spaces_minus_tabs < 0
                                  setlocal noexpandtab
                                  let &l:shiftwidth=&tabstop
                                  return 1
   46              0.000083     endif
                            
   46   0.056517   0.002461     let shiftwidth = s:get_shiftwidth(indents)
                            
   46              0.000260     if shiftwidth > 0
   36              0.000851       setlocal expandtab
   36              0.000780       let &l:shiftwidth=shiftwidth
   36              0.000105       try
                                    " Sunchronize tabstop with shiftwidth
   36              0.000496         let &l:softtabstop = -1
                                  catch /^Vim\%((\a\+)\)\=:E487/
                                    " -1 was not supported before Vim 7.4
                                    let &l:softtabstop = a:num_spaces
   36              0.000109       endtry
   36              0.000144       return 1
   10              0.000019     endif
                            
   10              0.000031     return 0

FUNCTION  <SNR>74_AddEval()
    Defined: ~\scoop\apps\neovim\0.6.1\share\nvim\runtime\autoload\remote\define.vim:274
Called 1 time
Total time:   0.000088
 Self time:   0.000088

count  total (s)   self (s)
    1              0.000018   if has_key(a:opts, 'eval')
                                if type(a:opts.eval) != type('') || a:opts.eval == ''
                                  throw "Eval option must be a non-empty string"
                                endif
                                " evaluate an expression and pass as argument
                                call add(a:rpcargs, 'eval("'.escape(a:opts.eval, '"').'")')
    1              0.000003   endif

FUNCTION  <SNR>108_EnableByDefault()
    Defined: ~\AppData\Local\nvim-data\plugged\vim-polyglot\syntax\python.vim:20
Called 2 times
Total time:   0.000051
 Self time:   0.000051

count  total (s)   self (s)
    2              0.000029     if !exists(a:name)
                                    let {a:name} = 1
    2              0.000004     endif

FUNCTION  <SNR>138_RenderKeepView()
    Defined: ~\AppData\Local\nvim-data\plugged\tagbar\autoload\tagbar.vim:2213
Called 1 time
Total time:   0.055399
 Self time:   0.043639

count  total (s)   self (s)
    1              0.000004     if a:0 == 1
                                    let line = a:1
    1              0.000002     else
    1              0.000008         let line = line('.')
    1              0.000002     endif
                            
    1              0.000008     let curcol  = col('.')
    1              0.000008     let topline = line('w0')
                            
    1   0.011782   0.000025     call s:RenderContent()
                            
    1              0.000008     let scrolloff_save = &scrolloff
    1   0.000016   0.000014     setlocal scrolloff=0
                            
    1              0.000007     call cursor(topline, 1)
    1              0.000022     normal! zt
    1              0.000007     call cursor(line, curcol)
                            
    1   0.000018   0.000016     let &l:scrolloff = scrolloff_save
                            
    1              0.043489     redraw

FUNCTION  <SNR>122_is_python_string()
    Defined: ~\AppData\Local\nvim-data\plugged\vim-polyglot\indent\python.vim:364
Called 2 times
Total time:   0.000818
 Self time:   0.000818

count  total (s)   self (s)
    2              0.000024     let line = getline(a:lnum)
    2              0.000008     if a:0
    2              0.000036       let cols = type(a:1) != type([]) ? [a:1] : a:1
                                else
                                  let cols = range(1, max([1, len(line)]))
    2              0.000005     endif
    3              0.000022     for cnum in cols
    2              0.000612         if match(map(synstack(a:lnum, cnum), "synIDattr(v:val, 'name')"), 'python\S*String') == -1
    1              0.000006             return 0
    1              0.000003         end
    2              0.000008     endfor
    1              0.000004     return 1

FUNCTION  tagbar#prototypes#typeinfo#new()
    Defined: ~\AppData\Local\nvim-data\plugged\tagbar\autoload\tagbar\prototypes\typeinfo.vim:1
Called 46 times
Total time:   0.008249
 Self time:   0.005421

count  total (s)   self (s)
   46              0.000345     let newobj = {}
                            
   46              0.000274     let newobj.kinddict = {}
                            
   46              0.000226     if a:0 > 0
    1              0.000151         call extend(newobj, a:1)
   46              0.000086     endif
                            
   46   0.003276   0.001745     let newobj.getKind = function(s:add_snr('s:getKind'))
   46   0.002934   0.001637     let newobj.createKinddict = function(s:add_snr('s:createKinddict'))
                            
   46              0.000161     return newobj

FUNCTION  <SNR>122_is_dedented_already()
    Defined: ~\AppData\Local\nvim-data\plugged\vim-polyglot\indent\python.vim:358
Called 1 time
Total time:   0.000041
 Self time:   0.000041

count  total (s)   self (s)
    1              0.000022     let dedent_size = a:current - a:base
    1              0.000016     return (dedent_size < 0 && a:current % s:sw() == 0) ? 1 : 0

FUNCTION  <SNR>145_isFolded()
    Defined: ~\AppData\Local\nvim-data\plugged\tagbar\autoload\tagbar\prototypes\kindheadertag.vim:32
Called 20 times
Total time:   0.000308
 Self time:   0.000308

count  total (s)   self (s)
   20              0.000258     return self.fileinfo.kindfolds[self.short]

FUNCTION  tagbar#prototypes#kindheadertag#new()
    Defined: ~\AppData\Local\nvim-data\plugged\tagbar\autoload\tagbar\prototypes\kindheadertag.vim:1
Called 59 times
Total time:   0.100803
 Self time:   0.016332

count  total (s)   self (s)
   59   0.076454   0.002017     let newobj = tagbar#prototypes#basetag#new(a:name)
                            
   59   0.003606   0.002074     let newobj.isKindheader = function(s:add_snr('s:isKindheader'))
   59   0.003272   0.001862     let newobj.getPrototype = function(s:add_snr('s:getPrototype'))
   59   0.003362   0.001944     let newobj.isFoldable = function(s:add_snr('s:isFoldable'))
   59   0.003385   0.001941     let newobj.isFolded = function(s:add_snr('s:isFolded'))
   59   0.003160   0.001755     let newobj.openFold = function(s:add_snr('s:openFold'))
   59   0.003378   0.001980     let newobj.closeFold = function(s:add_snr('s:closeFold'))
   59   0.003277   0.001850     let newobj.toggleFold = function(s:add_snr('s:toggleFold'))
                            
   59              0.000210     return newobj

FUNCTION  SemshiTextChanged()
    Defined: ~\scoop\apps\neovim\0.6.1\share\nvim\runtime\autoload\remote\define.vim:169
Called 379 times
Total time:   0.070834
 Self time:   0.021942

count  total (s)   self (s)
  379   0.069083   0.020191 return remote#define#notify(5, "C:/Users/Lenovo/AppData/Local/nvim-data/plugged/semshi/rplugin/python3/semshi:function:SemshiTextChanged", a:000)

FUNCTION  <SNR>142_add_snr()
    Defined: ~\AppData\Local\nvim-data\plugged\tagbar\autoload\tagbar\prototypes\fileinfo.vim:148
Called 54 times
Total time:   0.001312
 Self time:   0.001312

count  total (s)   self (s)
   54              0.000329     if !exists('s:snr')
    1              0.000081         let s:snr = matchstr(expand('<sfile>'), '<SNR>\d\+_\zeget_snr$')
   54              0.000075     endif
   54              0.000277     return s:snr . a:funcname

FUNCTION  <SNR>138_AutoUpdate()
    Defined: ~\AppData\Local\nvim-data\plugged\tagbar\autoload\tagbar.vim:2829
Called 390 times
Total time:  10.648982
 Self time:   0.931825

count  total (s)   self (s)
  390   0.035109   0.018733     call tagbar#debug#log('AutoUpdate called [' . a:fname . ']')
                            
                                " Whether we want to skip actually displaying the tags in Tagbar and only
                                " update the fileinfo
  390              0.005964     let no_display = a:0 > 0 ? a:1 : 0
                            
                                " This file is being loaded due to a quickfix command like vimgrep, so
                                " don't process it
  390              0.004440     if exists('s:tagbar_qf_active')
                                    return
  390              0.004002     elseif exists('s:window_opening')
                                    " This can happen if another plugin causes the active window to change
                                    " with an autocmd during the initial Tagbar window creation. In that
                                    " case InitWindow() hasn't had a chance to run yet and things can
                                    " break. MiniBufExplorer does this, for example. Completely disabling
                                    " autocmds at that point is also not ideal since for example
                                    " statusline plugins won't be able to update.
    1   0.000050   0.000024         call tagbar#debug#log('Still opening window, stopping processing')
    1              0.000003         return
  389              0.000725     endif
                            
                                " Get the filetype of the file we're about to process
  389              0.146087     let bufnr = bufnr(a:fname)
  389              0.009569     let ftype = getbufvar(bufnr, '&filetype')
                            
                                " Don't do anything if we're in the tagbar window
  389              0.003012     if ftype ==# 'tagbar'
    9   0.000502   0.000255         call tagbar#debug#log('In Tagbar window, stopping processing')
    9              0.000025         return
  380              0.000839     endif
                            
                                " Only consider the main filetype in cases like 'python.django'
  380              0.013180     let sftype = get(split(ftype, '\.'), 0, '')
  380   0.033505   0.019702     call tagbar#debug#log("Vim filetype: '" . ftype . "', " . "sanitized filetype: '" . sftype . "'")
                            
                                " Don't do anything if the file isn't supported
  380   0.475602   0.014256     if !s:IsValidFile(a:fname, sftype)
   12   0.000704   0.000367         call tagbar#debug#log('Not a valid file, stopping processing')
   12              0.000125         let s:nearby_disabled = 1
   12              0.000039         return
  368              0.000610     endif
                            
  368              0.002416     let updated = 0
                            
                                " Process the file if it's unknown or the information is outdated.
                                " Testing the mtime of the file is necessary in case it got changed
                                " outside of Vim, for example by checking out a different version from a
                                " VCS.
  368   0.020195   0.013379     if s:known_files.has(a:fname)
  362   0.016803   0.009298         let curfile = s:known_files.get(a:fname)
                                    " if a:force || getbufvar(curfile.bufnr, '&modified') ||
  362              0.179651         if a:force || empty(curfile) || curfile.ftype != sftype || (filereadable(a:fname) && getftime(a:fname) > curfile.mtime)
   21   0.001970   0.001077             call tagbar#debug#log('File data outdated, updating [' . a:fname . ']')
   21   6.128634   0.002509             call s:ProcessFile(a:fname, sftype)
   21              0.000140             let updated = 1
  341              0.001027         else
  341   0.026475   0.014741             call tagbar#debug#log('File data seems up to date [' . a:fname . ']')
  362              0.000788         endif
    6   0.000174   0.000105     elseif !s:known_files.has(a:fname)
    6   0.000286   0.000145         call tagbar#debug#log('New file, processing [' . a:fname . ']')
    6   1.739734   0.000640         call s:ProcessFile(a:fname, sftype)
    6              0.000029         let updated = 1
  368              0.000686     endif
                            
  368              0.001698     if no_display
    1              0.000003         return
  367              0.000567     endif
                            
  367   0.017074   0.010481     let fileinfo = s:known_files.get(a:fname)
                            
                                " If we don't have an entry for the file by now something must have gone
                                " wrong, so don't change the tagbar content
  367              0.003193     if empty(fileinfo)
                                    call tagbar#debug#log('fileinfo empty after processing [' . a:fname . ']')
                                    return
  367              0.000566     endif
                            
                                " Display the tagbar content if the tags have been updated or a different
                                " file is being displayed
  367   0.284393   0.250416     if bufwinnr(s:TagbarBufName()) != -1 && !s:paused && (s:new_window || updated || (!empty(tagbar#state#get_current_file(0)) && a:fname != tagbar#state#get_current_file(0).fpath))
    4   0.053531   0.000218         call s:RenderContent(fileinfo)
  367              0.000855     endif
                            
                                " Call setCurrent after rendering so RenderContent can check whether the
                                " same file is being redisplayed
  367              0.003243     if !empty(fileinfo)
  367   0.026254   0.013841         call tagbar#debug#log('Setting current file [' . a:fname . ']')
  367   0.082383   0.048128         call tagbar#state#set_current_file(fileinfo)
  367              0.003020         let s:nearby_disabled = 0
  367              0.000910     endif
                            
  367   0.806693   0.011100     call s:HighlightTag(0)
  367   0.396470   0.011388     call s:SetStatusLine()
  367   0.022475   0.011056     call tagbar#debug#log('AutoUpdate finished successfully')

FUNCTION  <SNR>138_HighlightTag()
    Defined: ~\AppData\Local\nvim-data\plugged\tagbar\autoload\tagbar.vim:2239
Called 368 times
Total time:   0.868436
 Self time:   0.123358

count  total (s)   self (s)
                            
  368              0.002367     if g:tagbar_no_autocmds
                                    " If no autocmds are enabled, then it doesn't make sense to highlight
                                    " anything as the cursor can move around and any highlighting would be
                                    " inaccurate
                                    return
  368              0.000619     endif
                            
  368              0.002225     let tagline = 0
                            
  368              0.003727     let force = a:0 > 0 ? a:1 : 0
                            
  368              0.001636     if a:0 > 1
    1   0.001251   0.000032         let tag = s:GetNearbyTag(g:tagbar_highlight_method, 0, a:2)
  367              0.000894     else
  367   0.700876   0.013667         let tag = s:GetNearbyTag(g:tagbar_highlight_method, 0)
  368              0.000967     endif
  368              0.002799     if !empty(tag)
  256              0.001710         let tagline = tag.tline
  368              0.000714     endif
                            
                                " Don't highlight the tag again if it's the same one as last time.
                                " This prevents the Tagbar window from jumping back after scrolling with
                                " the mouse.
  368              0.004008     if !force && tagline ==# s:last_highlight_tline
  344              0.000995         return
   24              0.000049     else
   24              0.000186         let s:last_highlight_tline = tagline
   24              0.000054     endif
                            
   24   0.015342   0.014470     let tagbarwinnr = bufwinnr(s:TagbarBufName())
   24              0.000227     if tagbarwinnr == -1
   22              0.000071         return
    2              0.000003     endif
                            
    2              0.000015     if tagbarwinnr == winnr()
    2              0.000010         let in_tagbar = 1
                                else
                                    let in_tagbar = 0
                                    let prevwinnr = winnr()
                                    call s:goto_win('p', 1)
                                    let pprevwinnr = winnr()
                                    call s:goto_win(tagbarwinnr, 1)
    2              0.000003     endif
                            
    2              0.000005     try
    2              0.000012         match none
                            
                                    " No tag above cursor position so don't do anything
    2              0.000009         if tagline == 0
    1              0.000003             return
    1              0.000002         endif
                            
    1              0.000007         if g:tagbar_autoshowtag == 1 || a:openfolds
    1   0.055563   0.000030             call s:OpenParents(tag)
    1              0.000002         endif
                            
                                    " Check whether the tag is inside a closed fold and highlight the parent
                                    " instead in that case
    1   0.000281   0.000068         let tagline = tag.getClosedParentTline()
                            
                                    " Parent tag line number is invalid, better don't do anything
    1              0.000009         if tagline <= 0
                                        return
    1              0.000003         endif
                            
                                    " Go to the line containing the tag
    1              0.000026         execute tagline
                            
                                    " Make sure the tag is visible in the window
    1              0.000020         call winline()
                            
    1              0.000026         let foldpat = '[' . g:tagbar#icon_open . g:tagbar#icon_closed . ' ]'
                            
                                    " If printing the line number of the tag to the left, and the tag is
                                    " visible (I.E. parent isn't folded)
    1              0.000019         let identifier = '\zs\V' . escape(tag.name, '/\') . '\m\ze'
    1              0.000011         if g:tagbar_show_tag_linenumbers == 2 && tagline == tag.tline
                                        let pattern = '/^\%' . tagline . 'l\s*' . foldpat . '[-+# ]\[[0-9]\+\] \?' . identifier . '/'
    1              0.000002         else
    1              0.000021             let pattern = '/^\%' . tagline . 'l\s*' . foldpat . '[-+# ]\?' . identifier . '/'
    1              0.000002         endif
    1   0.000081   0.000048         call tagbar#debug#log("Highlight pattern: '" . pattern . "'")
    1              0.000011         if hlexists('TagbarHighlight') " Safeguard in case syntax highlighting is disabled
    1              0.000050             execute 'match TagbarHighlight ' . pattern
                                    else
                                        execute 'match Search ' . pattern
    1              0.000002         endif
    2              0.000007     finally
    2              0.000008         if !in_tagbar
                                        call s:goto_win(pprevwinnr, 1)
                                        call s:goto_win(prevwinnr, 1)
    2              0.000003         endif
    2              0.053119         redraw
    2              0.000023     endtry

FUNCTION  SemshiBufWipeout()
    Defined: ~\scoop\apps\neovim\0.6.1\share\nvim\runtime\autoload\remote\define.vim:169
Called 29 times
Total time:   0.033908
 Self time:   0.001766

count  total (s)   self (s)
   29   0.033744   0.001602 return remote#define#request(5, "C:/Users/Lenovo/AppData/Local/nvim-data/plugged/semshi/rplugin/python3/semshi:function:SemshiBufWipeout", a:000)

FUNCTION  CloseSidePanelIfLonely()
    Defined: ~\AppData\Local\nvim\myPlugins\SidePannel.vim:31
Called 29 times
Total time:   0.000958
 Self time:   0.000958

count  total (s)   self (s)
   29              0.000609     if winnr('$') == 1 && exists("b:CloseThisWindowIfItsLonely") && b:CloseThisWindowIfItsLonely == 1
    1              0.000087         quit
   29              0.000055     endif

FUNCTION  <SNR>165_update_last_active()
    Defined: ~\AppData\Local\nvim-data\plugged\neoterm\autoload\neoterm.vim:325
Called 7 times
Total time:   0.000138
 Self time:   0.000138

count  total (s)   self (s)
    7              0.000108   let g:neoterm.last_active = a:instance.id

FUNCTION  <SNR>168_shell()
    Defined: ~\AppData\Local\nvim-data\plugged\neoterm\autoload\neoterm\term\neovim.vim:19
Called 1 time
Total time:   0.000076
 Self time:   0.000076

count  total (s)   self (s)
    1              0.000008   if g:neoterm_marker ==# ''
                                return a:opts.shell
    1              0.000003   else
    1              0.000021     return printf('%s%s-%s', a:opts.shell, g:neoterm_marker, a:opts.id)
                              end

FUNCTION  <SNR>142_reset()
    Defined: ~\AppData\Local\nvim-data\plugged\tagbar\autoload\tagbar\prototypes\fileinfo.vim:106
Called 21 times
Total time:   0.023503
 Self time:   0.023503

count  total (s)   self (s)
   21              0.004695     let self.mtime = getftime(self.fpath)
   21              0.000553     let self._taglist = []
   21              0.000639     let self._tagdict = {}
   21              0.011714     let self.fline = {}
   21              0.002701     let self.tline = {}
                            
   21              0.000280     let self._tagfolds_old = self.tagfolds
   21              0.000116     let self.tagfolds = {}
                            
  147              0.000744     for kind in self.typeinfo.kinds
  126              0.001169         let self.tagfolds[kind.short] = {}
  147              0.000387     endfor

FUNCTION  neoterm#exec()
    Defined: ~\AppData\Local\nvim-data\plugged\neoterm\autoload\neoterm.vim:145
Called 6 times
Total time:   0.156634
 Self time:   0.004768

count  total (s)   self (s)
    6              0.000108   if exists('*g:neoterm_callbacks.before_exec')
                                call g:neoterm_callbacks.before_exec()
    6              0.000019   end
                            
    6   0.006050   0.000596   let l:command = map(copy(a:opts.cmd), { i, cmd -> s:expand(cmd) })
    6   0.006435   0.002461   let l:instance = neoterm#target#get({ 'target': get(a:opts, 'target', 0) })
                            
    6   0.000647   0.000315   if s:requires_new_instance(l:instance)
    1   0.139309   0.000040     let l:instance = neoterm#new(a:opts)
    6              0.000016   end
                            
    6              0.000057   if !empty(l:instance)
    6   0.000374   0.000258     call s:update_last_active(l:instance)
    6   0.002885   0.000164     call l:instance.exec(l:command)
                            
    6              0.000090     if get(a:opts, 'force_clear', 0)
                                  let l:bufname = bufname(l:instance.buffer_id)
                                  let l:scrollback = getbufvar(l:bufname, '&scrollback')
                            
                                  call setbufvar(l:bufname, '&scrollback', 1)
                                  sleep 100m
                                  call setbufvar(l:bufname, '&scrollback', l:scrollback)
    6              0.000016     end
    6              0.000020   end

FUNCTION  <SNR>147_get()
    Defined: ~\AppData\Local\nvim-data\plugged\tagbar\autoload\tagbar\state.vim:13
Called 1563 times
Total time:   0.057159
 Self time:   0.057125

count  total (s)   self (s)
 1563              0.022185     if !exists('t:tagbar_state')
    2   0.000077   0.000043         let t:tagbar_state = s:State.New()
 1563              0.003593     endif
                            
 1563              0.008658     return t:tagbar_state

FUNCTION  lfMru#recordBuffer()
    Defined: ~\AppData\Local\nvim-data\plugged\LeaderF\autoload\lfMru.vim:43
Called 70 times
Total time:   0.001360
 Self time:   0.001360

count  total (s)   self (s)
   70              0.001135     call add(g:Lf_MruBufnrs, a:bufNum)

FUNCTION  leaderf#colorscheme#setStatusline()
    Defined: ~\AppData\Local\nvim-data\plugged\LeaderF\autoload\leaderf\colorscheme.vim:180
Called 34 times
Total time:   0.004163
 Self time:   0.004163

count  total (s)   self (s)
   96              0.001346     for n in range(1, winnr('$'))
   62              0.000788         if winbufnr(n) == a:bufnr
                                        call setwinvar(n, '&statusline', a:stl)
   62              0.000183         endif
   96              0.000304     endfor

FUNCTION  tagbar#debug#log_ctags_output()
    Defined: ~\AppData\Local\nvim-data\plugged\tagbar\autoload\tagbar\debug.vim:38
Called 27 times
Total time:   0.000858
 Self time:   0.000858

count  total (s)   self (s)
   27              0.000226     if s:debug_enabled
                                    exe 'redir! > ' . s:debug_file . '.ctags_out'
                                    silent echon a:output
                                    redir END
   27              0.000053     endif

FUNCTION  tagbar#sorting#sort()
    Defined: ~\AppData\Local\nvim-data\plugged\tagbar\autoload\tagbar\sorting.vim:5
Called 28 times
Total time:   0.084135
 Self time:   0.063724

count  total (s)   self (s)
   28              0.000292     let s:compare_typeinfo = a:compare_typeinfo
                            
   28              0.000428     let comparemethod = a:compareby ==# 'kind' ? 's:compare_by_kind' : 's:compare_by_line'
                            
   28   0.055511   0.038283     call sort(a:tags, comparemethod)
                            
  571              0.001740     for tag in a:tags
  543   0.016557   0.013326         if !empty(tag.getChildren())
    1   0.000019   0.000017             call tagbar#sorting#sort(tag.getChildren(), a:compareby, a:compare_typeinfo)
  543              0.000862         endif
  571              0.001028     endfor

FUNCTION  <SNR>122__skip_special_chars()
    Defined: ~\AppData\Local\nvim-data\plugged\vim-polyglot\indent\python.vim:82
Called 175 times
Total time:   0.113242
 Self time:   0.113242

count  total (s)   self (s)
  175              0.112695         return synIDattr(synID(a:line, a:col, 0), 'name') =~? s:special_chars_syn_pattern

FUNCTION  <SNR>138_PrintKinds()
    Defined: ~\AppData\Local\nvim-data\plugged\tagbar\autoload\tagbar.vim:2019
Called 5 times
Total time:   0.046026
 Self time:   0.019253

count  total (s)   self (s)
    5   0.000342   0.000160     call tagbar#debug#log('PrintKinds called')
                            
                                " If the short or long help is being displayed then the line numbers don't
                                " match up with the length of the output list
    5              0.000100     let offset = g:tagbar_compact && s:short_help ? 0 : line('.')
    5              0.000038     let output = []
                            
   35              0.000209     for kind in a:typeinfo.kinds
   30   0.004622   0.004392         let curtags = filter(copy(a:fileinfo.getTags()), 'v:val.fields.kind ==# kind.short')
   30   0.002304   0.001374         call tagbar#debug#log('Printing kind: ' . kind.short . ', number of (top-level) tags: ' . len(curtags))
                            
   30              0.000224         if empty(curtags)
   15              0.000078             continue
   15              0.000029         endif
                            
   15              0.000342         if has_key(get(a:typeinfo, 'kind2scope', {}), kind.short)
                                        " Scoped tags
   20              0.000099             for tag in curtags
   15   0.012564   0.000570                 call s:PrintTag(tag, 0, output, a:fileinfo, a:typeinfo)
                            
   15              0.000097                 if g:tagbar_compact != 1
   15              0.000148                     call add(output, '')
   15              0.000033                 endif
   20              0.000063             endfor
   10              0.000025         else
                                        " Non-scoped tags
   10              0.000116             let kindtag = curtags[0].parent
                            
   10   0.000440   0.000292             if kindtag.isFolded()
    5              0.000050                 let foldmarker = g:tagbar#icon_closed
    5              0.000014             else
    5              0.000054                 let foldmarker = g:tagbar#icon_open
   10              0.000022             endif
                            
   10              0.000116             let padding = g:tagbar_show_visibility ? ' ' : ''
   10              0.000066             if g:tagbar_show_tag_count
                                            let tag_count = ' (' . len(curtags) . ')'
                                            call add(output, foldmarker . padding . kind.long . tag_count)
   10              0.000030             else
   10              0.000257                 call add(output, foldmarker . padding . kind.long)
   10              0.000028             endif
                            
   10              0.000152             let curline                   = len(output) + offset
   10              0.000090             let kindtag.tline             = curline
   10              0.000160             let a:fileinfo.tline[curline] = kindtag
                            
   10   0.000467   0.000307             if !kindtag.isFolded()
   50              0.000199                 for tag in curtags
   45   0.014349   0.001221                     let str = tag.strfmt()
   45              0.000798                     call add(output, repeat(' ', g:tagbar_indent) . str)
                            
                                                " Save the current tagbar line in the tag for easy
                                                " highlighting access
   45              0.000461                     let curline                   = len(output) + offset
   45              0.000289                     let tag.tline                 = curline
   45              0.000462                     let a:fileinfo.tline[curline] = tag
   50              0.000134                 endfor
   10              0.000019             endif
                            
   10              0.000065             if g:tagbar_compact != 1
   10              0.000095                 call add(output, '')
   10              0.000018             endif
   15              0.000026         endif
   20              0.000133     endfor
                            
    5              0.000145     let outstr = join(output, "\n")
    5              0.000044     if g:tagbar_compact && !g:tagbar_help_visibility && s:short_help
                                    silent 0put =outstr
    5              0.000009     else
    5              0.001046         silent  put =outstr
    5              0.000021     endif

FUNCTION  <SNR>144_isPseudoTag()
    Defined: ~\AppData\Local\nvim-data\plugged\tagbar\autoload\tagbar\prototypes\basetag.vim:59
Called 7 times
Total time:   0.000033
 Self time:   0.000033

count  total (s)   self (s)
    7              0.000021     return 0

FUNCTION  <SNR>21_getline()
    Defined: ~\AppData\Local\nvim-data\plugged\auto-pairs\plugin\auto-pairs.vim:139
Called 141 times
Total time:   0.043536
 Self time:   0.043536

count  total (s)   self (s)
  141              0.002991   let line = getline('.')
  141              0.001847   let pos = col('.') - 1
  141              0.002292   let before = strpart(line, 0, pos)
  141              0.001710   let after = strpart(line, pos)
  141              0.001072   let afterline = after
  141              0.001059   if g:AutoPairsMultilineClose
  141              0.005558     let n = line('$')
  141              0.001485     let i = line('.')+1
  259              0.002001     while i <= n
  259              0.003000       let line = getline(i)
  259              0.003043       let after = after.' '.line
  259              0.007383       if !(line =~ '\v^\s*$')
  141              0.000557         break
  118              0.000286       end
  118              0.000801       let i = i+1
  259              0.001228     endwhile
  141              0.000391   end
  141              0.002411   return [before, after, afterline]

FUNCTION  provider#python3#Call()
    Defined: ~\scoop\apps\neovim\0.6.1\share\nvim\runtime\autoload\provider\python3.vim:26
Called 20 times
Total time:   0.080398
 Self time:   0.080398

count  total (s)   self (s)
   20              0.000255   if s:err != ''
                                return
   20              0.000061   endif
   20              0.000282   if !exists('s:host')
                                let s:rpcrequest = function('rpcrequest')
                            
                                " Ensure that we can load the Python3 host before bootstrapping
                                try
                                  let s:host = remote#host#Require('legacy-python3-provider')
                                catch
                                  let s:err = v:exception
                                  echohl WarningMsg
                                  echomsg v:exception
                                  echohl None
                                  return
                                endtry
   20              0.000048   endif
   20              0.078232   return call(s:rpcrequest, insert(insert(a:args, 'python_'.a:method), s:host))

FUNCTION  leaderf#Gtags#updateGtags()
    Defined: ~\AppData\Local\nvim-data\plugged\LeaderF\autoload\leaderf\Gtags.vim:97
Called 19 times
Total time:   0.076439
 Self time:   0.076439

count  total (s)   self (s)
   19              0.000426 exec g:Lf_py "<< EOF"
                            gtagsExplManager.updateGtags(lfDecode(vim.eval("a:filename")), True if int(vim.eval("a:single_update")) else False)
                            EOF

FUNCTION  SidePanelToggleManagement()
    Defined: ~\AppData\Local\nvim\myPlugins\SidePannel.vim:83
Called 2 times
Total time:   2.080089
 Self time:   0.053367

count  total (s)   self (s)
                            
    2              0.000062     let l:nr_open = t:SidePanelInUse + t:NerdTreeInUse + t:TagBarInUse
                            
    2              0.000023     if t:SidePanelInUse == 1
    1   0.033119   0.000110         exec "winc h"
    1   0.128188   0.000196         exec "winc q"
    1              0.000010         let t:SidePanelInUse = 0
    1              0.000013     elseif t:SidePanelInUse==0 && a:Toggle=='SidePanel'
    1              0.000007         let t:SidePanelInUse = 1
    2              0.000006     endif
    2              0.000011     if t:NerdTreeInUse == 1
                                    exec "winc h"
                                    exec "winc q"
                                    let t:NerdTreeInUse = 0
    2              0.000004     endif
    2              0.000009     if t:TagBarInUse == 1
                                    exec "winc h"
                                    exec "winc q"
                                    let t:TagBarInUse = 0
    2              0.000003     endif
                            
                            
    2              0.000017     if a:Toggle == 'SidePanel'
    1   0.129230   0.000148         call CreateSidePanel()
    1              0.000006     elseif a:Toggle == 'NerdTree'
                                    NERDTreeToggle
                                    exec "10 winc h"
                                    let b:CloseThisWindowIfItsLonely = 1    " re-label this variable to be named after your plugin
                                    exec "50winc|"
                                    exec "1 winc l"
                                    let t:NerdTreeInUse  = 1
    1              0.000006     elseif a:Toggle == 'Tagbar'
    1   1.766604   0.052462         TagbarToggle
    1   0.006630   0.000023         exec "10 winc h"
    1              0.000008         exec "50winc|"
    1   0.015902   0.000014         exec "1 winc l"
    1              0.000002         let t:TagBarInUse = 1
    2              0.000003     endif
                            

FUNCTION  <SNR>138_CheckExCtagsVersion()
    Defined: ~\AppData\Local\nvim-data\plugged\tagbar\autoload\tagbar.vim:743
Called 1 time
Total time:   0.000340
 Self time:   0.000288

count  total (s)   self (s)
    1   0.000053   0.000026     call tagbar#debug#log('Checking Exuberant Ctags version')
                            
    1              0.000025     if a:output =~? 'Universal Ctags'
                                    call tagbar#debug#log('Found Universal Ctags, assuming compatibility')
                                    let s:ctags_is_uctags = 1
                                    return 1
    1              0.000001     endif
                            
    1              0.000034     if a:output =~? 'Exuberant Ctags compatiable PHP enhancement'
                                    call tagbar#debug#log('Found phpctags, assuming compatibility')
                                    return 1
    1              0.000001     endif
                            
    1              0.000024     if a:output =~? 'Exuberant Ctags Development'
                                    call tagbar#debug#log('Found development version, assuming compatibility')
                                    return 1
    1              0.000001     endif
                            
    1              0.000052     let matchlist = matchlist(a:output, '\vExuberant Ctags (\d+)\.(\d+)')
    1              0.000012     let major     = matchlist[1]
    1              0.000006     let minor     = matchlist[2]
                            
    1   0.000061   0.000035     call tagbar#debug#log("Ctags version: major='" . major . "', minor='" . minor . "'")
                            
    1              0.000014     return major >= 6 || (major == 5 && minor >= 5)

FUNCTION  <SNR>108_Enabled()
    Defined: ~\AppData\Local\nvim-data\plugged\vim-polyglot\syntax\python.vim:27
Called 31 times
Total time:   0.000853
 Self time:   0.000853

count  total (s)   self (s)
   31              0.000786     return exists(a:name) && {a:name}

FUNCTION  Open_Init_Vim()
    Defined: ~\AppData\Local\nvim\init.vim:366
Called 1 time
Total time:   0.447265
 Self time:   0.002321

count  total (s)   self (s)
    1   0.447192   0.002298     execute "tabnew C:/Users/Lenovo/AppData/Local/nvim/init.vim"
    1   0.000068   0.000018     execute "call CreateSidePanel()"
                                "execute "Tagbar"

FUNCTION  <SNR>138_SetStatusLine()
    Defined: ~\AppData\Local\nvim-data\plugged\tagbar\autoload\tagbar.vim:3447
Called 374 times
Total time:   0.390973
 Self time:   0.273794

count  total (s)   self (s)
  374   0.233196   0.219814     let tagbarwinnr = bufwinnr(s:TagbarBufName())
  374              0.005815     if tagbarwinnr == -1 || exists('g:tagbar_no_status_line')
  282              0.000989         return
   92              0.000171     endif
                            
                                " Make sure we're actually in the Tagbar window
   92              0.000785     if tagbarwinnr != winnr()
   84              0.000576         let in_tagbar = 0
   84              0.000642         let prevwinnr = winnr()
   84   0.027523   0.003142         call s:goto_win('p', 1)
   84              0.000866         let pprevwinnr = winnr()
   84   0.022394   0.002638         call s:goto_win(tagbarwinnr, 1)
    8              0.000015     else
    8              0.000037         let in_tagbar = 1
   92              0.000165     endif
                            
   92   0.013401   0.003181     if !empty(tagbar#state#get_current_file(0))
   92   0.011710   0.002687         let fileinfo = tagbar#state#get_current_file(0)
   92              0.001830         let fname = fnamemodify(fileinfo.fpath, ':t')
   92              0.001524         let sorted = get(fileinfo.typeinfo, 'sort', g:tagbar_sort)
                                else
                                    let fname = ''
                                    let sorted = g:tagbar_sort
   92              0.000136     endif
   92              0.000754     let sortstr = sorted ? 'Name' : 'Order'
                            
   92              0.000513     let flags = []
   92              0.001835     let flags += exists('w:autoclose') && w:autoclose ? ['c'] : []
   92              0.000856     let flags += g:tagbar_autoclose ? ['C'] : []
   92              0.001132     let flags += (sorted && g:tagbar_case_insensitive) ? ['i'] : []
   92              0.000806     let flags += g:tagbar_hide_nonpublic ? ['v'] : []
                            
   92              0.000859     if exists('g:tagbar_status_func')
                                    let args = [in_tagbar, sortstr, fname, flags]
                                    let &l:statusline = call(g:tagbar_status_func, args)
   92              0.000192     else
   92              0.000941         let colour = in_tagbar ? '%#StatusLine#' : '%#StatusLineNC#'
   92              0.001136         let flagstr = join(flags, '')
   92              0.000628         if flagstr !=# ''
                                        let flagstr = '[' . flagstr . '] '
   92              0.000174         endif
   92              0.001748         let text = colour . '[' . sortstr . '] ' . flagstr . fname
   92   0.002098   0.002087         let &l:statusline = text
   92              0.000208     endif
                            
   92              0.000407     if !in_tagbar
   84   0.023316   0.002793         call s:goto_win(pprevwinnr, 1)
   84   0.022244   0.002363         call s:goto_win(prevwinnr, 1)
   92              0.000170     endif

FUNCTION  <SNR>138_TransformUserTypeDef()
    Defined: ~\AppData\Local\nvim-data\plugged\tagbar\autoload\tagbar.vim:409
Called 1 time
Total time:   0.000482
 Self time:   0.000482

count  total (s)   self (s)
    1              0.000014     let newdef = copy(a:def)
                            
    1              0.000009     if has_key(a:def, 'kinds')
    1              0.000006         let newdef.kinds = []
    1              0.000007         let kinds = a:def.kinds
    5              0.000020         for kind in kinds
    4              0.000062             let kindlist = split(kind, ':')
    4              0.000102             let kinddict = {'short' : kindlist[0], 'long' : kindlist[1]}
    4              0.000039             let kinddict.fold = get(kindlist, 2, 0)
    4              0.000039             let kinddict.stl  = get(kindlist, 3, 1)
    4              0.000034             call add(newdef.kinds, kinddict)
    5              0.000013         endfor
    1              0.000002     endif
                            
                                " If the user only specified one of kind2scope and scope2kind then use it
                                " to generate the respective other
    1              0.000014     if has_key(a:def, 'kind2scope') && !has_key(a:def, 'scope2kind')
                                    let newdef.scope2kind = {}
                                    for [key, value] in items(a:def.kind2scope)
                                        let newdef.scope2kind[value] = key
                                    endfor
    1              0.000012     elseif has_key(a:def, 'scope2kind') && !has_key(a:def, 'kind2scope')
                                    let newdef.kind2scope = {}
                                    for [key, value] in items(a:def.scope2kind)
                                        let newdef.kind2scope[value] = key
                                    endfor
    1              0.000002     endif
                            
    1              0.000005     return newdef

FUNCTION  <SNR>22_simplify_markup_extra()
    Defined: ~\AppData\Local\nvim-data\plugged\semshi\plugin\semshi.vim:31
Called 2 times
Total time:   0.000125
 Self time:   0.000125

count  total (s)   self (s)
    2              0.000009     hi link pythonConditional pythonStatement
    2              0.000008     hi link pythonImport pythonStatement
    2              0.000006     hi link pythonInclude pythonStatement
    2              0.000008     hi link pythonRaiseFromStatement pythonStatement
    2              0.000007     hi link pythonDecorator pythonStatement
    2              0.000007     hi link pythonException pythonStatement
    2              0.000061     hi link pythonConditional pythonStatement
    2              0.000008     hi link pythonRepeat pythonStatement

FUNCTION  <SNR>141_getKind()
    Defined: ~\AppData\Local\nvim-data\plugged\tagbar\autoload\tagbar\prototypes\typeinfo.vim:17
Called 1593 times
Total time:   0.053756
 Self time:   0.053756

count  total (s)   self (s)
                                "let idx = self.kinddict[a:kind]
 1593              0.033583     let idx = has_key(self.kinddict, a:kind) ? self.kinddict[a:kind] : -1
 1593              0.012563     return self.kinds[idx]

FUNCTION  <SNR>138_ShowPrototype()
    Defined: ~\AppData\Local\nvim-data\plugged\tagbar\autoload\tagbar.vim:2544
Called 5 times
Total time:   0.005214
 Self time:   0.000628

count  total (s)   self (s)
    5   0.004173   0.000232     let taginfo = s:GetTagInfo(line('.'), 1)
                            
    5              0.000030     if empty(taginfo)
    1              0.000003         return ''
    4              0.000006     endif
                            
    4   0.000950   0.000305     echo taginfo.getPrototype(a:short)

FUNCTION  <SNR>69_Highlight_Matching_Pair()
    Defined: ~\scoop\apps\neovim\0.6.1\share\nvim\runtime\plugin\matchparen.vim:40
Called 1364 times
Total time:   1.266189
 Self time:   1.179830

count  total (s)   self (s)
                              " Remove any previous match.
 1364   0.139247   0.052888   call s:Remove_Matches()
                            
                              " Avoid that we remove the popup menu.
                              " Return when there are no colors (looks like the cursor jumps).
 1364              0.029966   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
                                return
 1364              0.002966   endif
                            
                              " Get the character under the cursor and check if it's in 'matchpairs'.
 1364              0.018641   let c_lnum = line('.')
 1364              0.013787   let c_col = col('.')
 1364              0.007485   let before = 0
                            
 1364              0.017736   let text = getline(c_lnum)
 1364              0.101265   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
 1364              0.014279   if empty(matches)
                                let [c_before, c] = ['', '']
 1364              0.003953   else
 1364              0.026284     let [c_before, c] = matches[1:2]
 1364              0.003644   endif
 1364              0.077262   let plist = split(&matchpairs, '.\zs[:,]')
 1364              0.020139   let i = index(plist, c)
 1364              0.007250   if i < 0
                                " not found, in Insert mode try character before the cursor
 1198              0.023831     if c_col > 1 && (mode() == 'i' || mode() == 'R')
  612              0.007442       let before = strlen(c_before)
  612              0.003864       let c = c_before
  612              0.006262       let i = index(plist, c)
 1198              0.002996     endif
 1198              0.005068     if i < 0
                                  " not found, nothing to do
 1183              0.004760       return
   15              0.000032     endif
  181              0.000356   endif
                            
                              " Figure out the arguments for searchpairpos().
  181              0.001123   if i % 2 == 0
    7              0.000048     let s_flags = 'nW'
    7              0.000082     let c2 = plist[i + 1]
  174              0.000400   else
  174              0.001164     let s_flags = 'nbW'
  174              0.001107     let c2 = c
  174              0.001806     let c = plist[i - 1]
  181              0.000398   endif
  181              0.001199   if c == '['
    8              0.000037     let c = '\['
    8              0.000038     let c2 = '\]'
  181              0.000308   endif
                            
                              " Find the match.  When it was just before the cursor move it there for a
                              " moment.
  181              0.000888   if before > 0
   15              0.000272     let has_getcurpos = exists("*getcurpos")
   15              0.000072     if has_getcurpos
                                  " getcurpos() is more efficient but doesn't exist before 7.4.313.
   15              0.000568       let save_cursor = getcurpos()
                                else
                                  let save_cursor = winsaveview()
   15              0.000029     endif
   15              0.000229     call cursor(c_lnum, c_col - before)
  181              0.000332   endif
                            
  181              0.011336   if !has("syntax") || !exists("g:syntax_on")
                                let s_skip = "0"
  181              0.000364   else
                                " Build an expression that detects whether the current cursor position is
                                " in certain syntax types (string, comment, etc.), for use as
                                " searchpairpos()'s skip argument.
                                " We match "escape" for special items, such as lispEscapeSpecial, and
                                " match "symbol" for lispBarSymbol.
  181              0.003869     let s_skip = '!empty(filter(map(synstack(line("."), col(".")), ''synIDattr(v:val, "name")''), ' . '''v:val =~? "string\\|character\\|singlequote\\|escape\\|symbol\\|comment"''))'
                                " If executing the expression determines that the cursor is currently in
                                " one of the syntax types, then we want searchpairpos() to find the pair
                                " within those syntax types (i.e., not skip).  Otherwise, the cursor is
                                " outside of the syntax types and s_skip should keep its value so we skip
                                " any matching pair inside the syntax types.
                                " Catch if this throws E363: pattern uses more memory than 'maxmempattern'.
  181              0.000756     try
  181              0.173394       execute 'if ' . s_skip . ' | let s_skip = "0" | endif'
                                catch /^Vim\%((\a\+)\)\=:E363/
                                  " We won't find anything, so skip searching, should keep Vim responsive.
                                  return
  181              0.000675     endtry
  181              0.000376   endif
                            
                              " Limit the search to lines visible in the window.
  181              0.003018   let stoplinebottom = line('w$')
  181              0.001929   let stoplinetop = line('w0')
  181              0.001393   if i % 2 == 0
    7              0.000061     let stopline = stoplinebottom
  174              0.000364   else
  174              0.001720     let stopline = stoplinetop
  181              0.000331   endif
                            
                              " Limit the search time to 300 msec to avoid a hang on very long lines.
                              " This fails when a timeout is not supported.
  181              0.002535   if mode() == 'i' || mode() == 'R'
  164              0.004125     let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
   17              0.000032   else
   17              0.000334     let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
  181              0.000371   endif
  181              0.000519   try
  181              0.315694     let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
                              catch /E118/
                                " Can't use the timeout, restrict the stopline a bit more to avoid taking
                                " a long time on closed folds and long lines.
                                " The "viewable" variables give a range in which we can scroll while
                                " keeping the cursor at the same position.
                                " adjustedScrolloff accounts for very large numbers of scrolloff.
                                let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
                                let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
                                let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
                                " one of these stoplines will be adjusted below, but the current values are
                                " minimal boundaries within the current window
                                if i % 2 == 0
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
                            	let stopline = min([bottom_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = min([bottom_viewable, c_lnum + 100])
                                  endif
                                  let stoplinebottom = stopline
                                else
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
                            	let stopline = max([top_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = max([top_viewable, c_lnum - 100])
                                  endif
                                  let stoplinetop = stopline
                                endif
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
  181              0.000642   endtry
                            
  181              0.001148   if before > 0
   15              0.000070     if has_getcurpos
   15              0.000227       call setpos('.', save_cursor)
                                else
                                  call winrestview(save_cursor)
   15              0.000028     endif
  181              0.000340   endif
                            
                              " If a match is found setup match highlighting.
  181              0.002793   if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
  177              0.002182     if exists('*matchaddpos')
  177              0.006399       call matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10, 3)
                                else
                                  exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
  177              0.000372     endif
  177              0.001554     let w:paren_hl_on = 1
  181              0.000367   endif

FUNCTION  nerdtree#checkForBrowse()
    Defined: ~\AppData\Local\nvim-data\plugged\nerdtree\autoload\nerdtree.vim:61
Called 45 times
Total time:   0.012454
 Self time:   0.012454

count  total (s)   self (s)
   45              0.011874     if !isdirectory(a:dir)
   45              0.000282         return
                                endif
                            
                                if s:reuseWin(a:dir)
                                    return
                                endif
                            
                                call g:NERDTreeCreator.CreateWindowTree(a:dir)

FUNCTION  <SNR>138_CheckForExCtags()
    Defined: ~\AppData\Local\nvim-data\plugged\tagbar\autoload\tagbar.vim:624
Called 1 time
Total time:   0.171438
 Self time:   0.001599

count  total (s)   self (s)
    1   0.000105   0.000051     call tagbar#debug#log('Checking for Exuberant Ctags')
                            
    1              0.000021     if !exists('g:tagbar_ctags_bin')
                                    let ctagsbins  = []
                                    let ctagsbins += ['ctags-exuberant'] " Debian
                                    let ctagsbins += ['exuberant-ctags']
                                    let ctagsbins += ['exctags'] " FreeBSD, NetBSD
                                    let ctagsbins += ['/usr/local/bin/ctags'] " Homebrew
                                    let ctagsbins += ['/opt/local/bin/ctags'] " Macports
                                    let ctagsbins += ['ectags'] " OpenBSD
                                    let ctagsbins += ['ctags']
                                    let ctagsbins += ['ctags.exe']
                                    let ctagsbins += ['tags']
                                    let ctagsbins += ['universal-ctags']
                                    for ctags in ctagsbins
                                        if executable(ctags)
                                            let g:tagbar_ctags_bin = ctags
                                            break
                                        endif
                                    endfor
                                    if !exists('g:tagbar_ctags_bin')
                                        let l:errmsg = 'Tagbar: Exuberant ctags not found!'
                                        let l:infomsg = 'Please download Exuberant Ctags from' . ' ctags.sourceforge.net and install it in a' . ' directory in your $PATH or set g:tagbar_ctags_bin.'
                                        call s:CtagsErrMsg(l:errmsg, l:infomsg, a:silent)
                                        let s:checked_ctags = 2
                                        return 0
                                    endif
    1              0.000003     else
                                    " reset 'wildignore' temporarily in case *.exe is included in it
    1              0.000019         let wildignore_save = &wildignore
    1   0.000073   0.000064         set wildignore&
                            
    1              0.000330         let g:tagbar_ctags_bin = expand(g:tagbar_ctags_bin)
                            
    1   0.000033   0.000029         let &wildignore = wildignore_save
                            
    1              0.000319         if !executable(g:tagbar_ctags_bin)
                                        let l:errmsg = 'Tagbar: Exuberant ctags not found at ' . "'" . g:tagbar_ctags_bin . "'!"
                                        let l:infomsg = 'Please check your g:tagbar_ctags_bin setting.'
                                        call s:CtagsErrMsg(l:errmsg, l:infomsg, a:silent)
                                        let s:checked_ctags = 2
                                        return 0
    1              0.000003         endif
    1              0.000002     endif
                            
    1   0.001622   0.000092     let ctags_cmd = s:EscapeCtagsCmd(g:tagbar_ctags_bin, '--version')
    1              0.000005     if ctags_cmd ==# ''
                                    let s:checked_ctags = 2
                                    return 0
    1              0.000001     endif
                            
    1   0.167879   0.000040     let ctags_output = s:ExecuteCtags(ctags_cmd)
                            
    1   0.000087   0.000049     call tagbar#debug#log("Command output:\n" . ctags_output)
    1   0.000054   0.000029     call tagbar#debug#log('Exit code: ' . v:shell_error)
                            
    1              0.000054     if v:shell_error || ctags_output !~# '\(Exuberant\|Universal\) Ctags'
                                    let l:errmsg = 'Tagbar: Ctags doesn''t seem to be Exuberant Ctags!'
                                    let l:infomsg = 'BSD ctags will NOT WORK.' . ' Please download Exuberant Ctags from ctags.sourceforge.net' . ' and install it in a directory in your $PATH' . ' or set g:tagbar_ctags_bin.'
                                    call s:CtagsErrMsg(l:errmsg, l:infomsg, a:silent, ctags_cmd, ctags_output, v:shell_error)
                                    let s:checked_ctags = 2
                                    return 0
    1   0.000445   0.000104     elseif !s:CheckExCtagsVersion(ctags_output)
                                    let l:errmsg = 'Tagbar: Exuberant Ctags is too old!'
                                    let l:infomsg = 'You need at least version 5.5 for Tagbar to work.' . ' Please download a newer version from ctags.sourceforge.net.'
                                    call s:CtagsErrMsg(l:errmsg, l:infomsg, a:silent, ctags_cmd, ctags_output)
                                    let s:checked_ctags = 2
                                    return 0
    1              0.000002     else
    1              0.000007         let s:checked_ctags = 1
    1              0.000003         return 1
                                endif

FUNCTION  tagbar#is_paused()
    Defined: ~\AppData\Local\nvim-data\plugged\tagbar\autoload\tagbar.vim:3825
Called 1196 times
Total time:   0.009239
 Self time:   0.009239

count  total (s)   self (s)
 1196              0.006568     return s:paused

FUNCTION  <SNR>142_addTag()
    Defined: ~\AppData\Local\nvim-data\plugged\tagbar\autoload\tagbar\prototypes\fileinfo.vim:69
Called 540 times
Total time:   0.031445
 Self time:   0.031445

count  total (s)   self (s)
  540              0.006594     call add(self._taglist, a:tag)
                            
  540              0.005852     if has_key(self._tagdict, a:tag.name)
   14              0.000149         call add(self._tagdict[a:tag.name], a:tag)
  526              0.001132     else
  526              0.007230         let self._tagdict[a:tag.name] = [a:tag]
  540              0.001303     endif

FUNCTION  <SNR>138_ExecuteCtagsOnFile()
    Defined: ~\AppData\Local\nvim-data\plugged\tagbar\autoload\tagbar.vim:1365
Called 27 times
Total time:   5.113102
 Self time:   0.032966

count  total (s)   self (s)
   27   0.002249   0.001185     call tagbar#debug#log('ExecuteCtagsOnFile called [' . a:fname . ']')
                            
   27              0.000637     if has_key(a:typeinfo, 'ctagsargs') && type(a:typeinfo.ctagsargs) == type('')
                                    " if ctagsargs is a string, prepend and append space separators
                                    let ctags_args = ' ' . a:typeinfo.ctagsargs . ' '
   27              0.000649     elseif has_key(a:typeinfo, 'ctagsargs') && type(a:typeinfo.ctagsargs) == type([])
                                    let ctags_args = a:typeinfo.ctagsargs
                                " otherwise ctagsargs is not defined or not defined as a valid type
   27              0.000056     else
                                    "Prefer constructing ctags_args as a list rather than a string
                                    "See s:EscapeCtagsCmd() - It's a best practice to shellescape()
                                    "each arg separately because in special cases where space is
                                    "intended to be in an argument, spaces in a single ctag_args
                                    "string would be ambiguous. Is the space an argument separator
                                    "or to be included in the argument
   27              0.000220         let ctags_args = []
   27              0.000331         if exists('g:tagbar_ctags_options')
                                        for value in g:tagbar_ctags_options
                                            call add(ctags_args, '--options='.value)
                                        endfor
   27              0.000061         endif
                            
                                    " universal-ctags deprecated this argument name
   27              0.000159         if s:ctags_is_uctags
                                        let ctags_args += [ '--extras=+F' ]
   27              0.000060         else
   27              0.000465             let ctags_args += [ '--extra=', '--file-scope=yes' ]
   27              0.000067         endif
                            
   27              0.000902         let ctags_args  = ctags_args + [ '-f', '-', '--format=2', '--excmd=pattern', '--fields=nksSafet', '--sort=no', '--append=no' ]
                            
                                    " verbose if debug enabled
   27   0.001140   0.000856         if tagbar#debug#enabled()
                                        let ctags_args += [ '-V' ]
   27              0.000054         endif
                            
                                    " Third-party programs may not necessarily make use of this
   27              0.000310         if has_key(a:typeinfo, 'ctagstype')
   27              0.000299             let ctags_type = a:typeinfo.ctagstype
                            
   27              0.000166             let ctags_kinds = ''
  189              0.000901             for kind in a:typeinfo.kinds
  162              0.001099                 if kind.short !=# '?'
  139              0.001281                     let ctags_kinds .= kind.short
  162              0.000430                 endif
  189              0.000479             endfor
                            
   27              0.000478             let ctags_args += ['--language-force=' . ctags_type]
   27              0.000491             let ctags_args += ['--' . ctags_type . '-kinds=' . ctags_kinds]
   27              0.000065         endif
                            
                                    " Include extra type definitions - include last to allow for any
                                    " overrides
   27              0.000560         if has_key(a:typeinfo, 'deffile') && filereadable(expand(a:typeinfo.deffile))
                                        let ctags_args += ['--options=' . expand(a:typeinfo.deffile)]
   27              0.000054         endif
   27              0.000054     endif
                            
   27              0.000530     if has_key(a:typeinfo, 'ctagsbin')
                                    " reset 'wildignore' temporarily in case *.exe is included in it
                                    let wildignore_save = &wildignore
                                    set wildignore&
                                    let ctags_bin = expand(a:typeinfo.ctagsbin)
                                    let &wildignore = wildignore_save
   27              0.000066     else
   27              0.000316         let ctags_bin = g:tagbar_ctags_bin
   27              0.000051     endif
                            
   27   0.052384   0.001626     let ctags_cmd = s:EscapeCtagsCmd(ctags_bin, ctags_args, a:fname)
   27              0.000180     if ctags_cmd ==# ''
                                    return ''
   27              0.000044     endif
                            
   27   5.027197   0.001365     let ctags_output = s:ExecuteCtags(ctags_cmd)
                            
   27              0.002763     if v:shell_error || ctags_output =~? 'Warning: cannot open \(source\|input\) file'
                                    call tagbar#debug#log('Command output:')
                                    call tagbar#debug#log(ctags_output)
                                    call tagbar#debug#log('Exit code: ' . v:shell_error)
                                    " Only display an error message if the Tagbar window is open and we
                                    " haven't seen the error before.
                                    if bufwinnr(s:TagbarBufName()) != -1 && (!s:known_files.has(a:realfname) || !empty(s:known_files.get(a:realfname)))
                                        call s:warning('Tagbar: Could not execute ctags for ' . a:realfname . '!')
                                        echomsg 'Executed command: "' . ctags_cmd . '"'
                                        if !empty(ctags_output)
                                            echomsg 'Command output:'
                                            for line in split(ctags_output, '\n')
                                                echomsg line
                                            endfor
                                        endif
                                        echomsg 'Exit code: ' . v:shell_error
                                    endif
                                    return -1
   27              0.000071     endif
                            
   27   0.002899   0.001558     call tagbar#debug#log('Ctags executed successfully')
   27   0.002365   0.001507     call tagbar#debug#log_ctags_output(ctags_output)
                            
   27              0.000360     return ctags_output

FUNCTION  <SNR>21_backspace()
    Defined: ~\AppData\Local\nvim-data\plugged\auto-pairs\plugin\auto-pairs.vim:135
Called 2 times
Total time:   0.000168
 Self time:   0.000075

count  total (s)   self (s)
    2   0.000163   0.000070   return repeat("\<BS>", s:ulen(a:s))

FUNCTION  ChangeGlobalVariable()
    Defined: ~\AppData\Local\nvim\myPlugins\SidePannel.vim:49
Called 32 times
Total time:   0.001823
 Self time:   0.001823

count  total (s)   self (s)
   32              0.000921     if exists("b:CloseThisWindowIfItsLonely")
    1              0.000011         let t:SidePanelInUse = 0
    1              0.000008         let t:NerdTreeInUse = 0
    1              0.000006         let t:TagBarInUse = 0
   32              0.000114     endif

FUNCTION  AutoPairsDelete()
    Defined: ~\AppData\Local\nvim-data\plugged\auto-pairs\plugin\auto-pairs.vim:303
Called 85 times
Total time:   0.141951
 Self time:   0.113166

count  total (s)   self (s)
   85              0.001990   if !b:autopairs_enabled
                                return "\<BS>"
   85              0.000321   end
                            
   85   0.034322   0.005816   let [before, after, ig] = s:getline()
  856              0.008572   for [open, close, opt] in b:AutoPairsList
  773              0.023460     let b = matchstr(before, '\V'.open.'\v\s?$')
  773              0.019890     let a = matchstr(after, '^\v\s*\V'.close)
  773              0.005358     if b != '' && a != ''
    2              0.000017       if b[-1:-1] == ' '
                                    if a[0] == ' '
                                      return "\<BS>\<DELETE>"
                                    else
                                      return "\<BS>"
                                    end
    2              0.000004       end
    2   0.000382   0.000102       return s:backspace(b).s:delete(a)
  771              0.001716     end
  854              0.002492   endfor
                            
   83              0.000923   return "\<BS>"
                              " delete the pair foo[]| <BS> to foo
                              for [open, close, opt] in b:AutoPairsList
                                let m = s:matchend(before, '\V'.open.'\v\s*'.'\V'.close.'\v$')
                                if len(m) > 0
                                  return s:backspace(m[2])
                                end
                              endfor
                              return "\<BS>"

FUNCTION  <SNR>21_delete()
    Defined: ~\AppData\Local\nvim-data\plugged\auto-pairs\plugin\auto-pairs.vim:131
Called 2 times
Total time:   0.000111
 Self time:   0.000055

count  total (s)   self (s)
    2   0.000108   0.000052   return repeat("\<DEL>", s:ulen(a:s))

FUNCTION  <SNR>138_ProcessFile()
    Defined: ~\AppData\Local\nvim-data\plugged\tagbar\autoload\tagbar.vim:1208
Called 27 times
Total time:   7.865219
 Self time:   0.352867

count  total (s)   self (s)
   27   0.001411   0.000718     call tagbar#debug#log('ProcessFile called [' . a:fname . ']')
                            
   27   0.029630   0.000800     if !s:IsValidFile(a:fname, a:ftype)
                                    call tagbar#debug#log('Not a valid file, returning')
                                    return
   27              0.000044     endif
                            
   27              0.006870     let l:bufnum = bufnr(a:fname)
                            
   27              0.000289     if !bufloaded(l:bufnum)
                                    call tagbar#debug#log('[ProcessFile] Buffer is not loaded exiting...')
                                    return
   27              0.000045     endif
   27              0.000212     if !bufexists(l:bufnum)
                                    call tagbar#debug#log('[ProcessFile] Buffer does not exist exiting...')
                                    return
   27              0.000039     endif
                            
   27              0.000358     let typeinfo = s:known_types[a:ftype]
                            
                                " If the file has only been updated preserve the fold states, otherwise
                                " create a new entry
   27   0.003488   0.002309     if s:known_files.has(a:fname) && !empty(s:known_files.get(a:fname)) && s:known_files.get(a:fname).ftype == a:ftype
   21   0.000808   0.000534         let fileinfo = s:known_files.get(a:fname)
   21              0.000167         let typeinfo = fileinfo.typeinfo
   21   0.024175   0.000672         call fileinfo.reset()
    6              0.000012     else
    6              0.000106         if exists('#TagbarProjects#User')
                                        execute 'doautocmd <nomodeline> TagbarProjects User ' . a:fname
                                        if exists('b:tagbar_type')
                                            let typeinfo = extend(copy(typeinfo), s:TransformUserTypeDef(b:tagbar_type))
                                            call typeinfo.createKinddict()
                                        endif
    6              0.000008         endif
    6   0.052031   0.041096         let fileinfo = tagbar#prototypes#fileinfo#new(a:fname, a:ftype, typeinfo)
   27              0.000054     endif
                            
   27   0.004201   0.003176     call tagbar#debug#log('typeinfo for file to process: ' . string(typeinfo))
                            
   27              0.000539     if g:tagbar_file_size_limit > 0 && fileinfo.fsize > g:tagbar_file_size_limit && !exists('b:tagbar_force_update')
                                    call tagbar#debug#log('File size exceeds defined limit')
                                    let fileinfo.fsize_exceeded = 1
                                    call s:known_files.put(fileinfo)
                                    return
   27              0.000151     elseif g:tagbar_use_cache
                                    " Use a temporary files for ctags processing instead of the original one.
                                    " This allows using Tagbar for files accessed with netrw, and also doesn't
                                    " slow down Tagbar for files that sit on slow network drives.
   27              0.001688         let tempfile = tempname()
   27              0.000530         let ext = fnamemodify(fileinfo.fpath, ':e')
   27              0.000161         if ext !=# ''
   27              0.000326             let tempfile .= '.' . ext
   27              0.000061         endif
                            
   27   0.001673   0.000851         call tagbar#debug#log('Caching file into: ' . tempfile)
   27              0.003399         let templines = getbufline(fileinfo.bufnr, 1, '$')
   27              0.049725         let res = writefile(templines, tempfile)
                            
   27              0.000425         if res != 0
                                        call tagbar#debug#log('Could not create copy '.tempfile)
                                        return
   27              0.000106         endif
   27              0.006796         let fileinfo.mtime = getftime(tempfile)
   27              0.000328         let fileinfo.fsize_exceeded = 0
                            
   27   5.115483   0.002380         let ctags_output = s:ExecuteCtagsOnFile(tempfile, a:fname, typeinfo)
                            
   27   0.001068   0.000834         if !tagbar#debug#enabled()
   27              0.022895             call delete(tempfile)
   27              0.000282         endif
                                else
                                    call tagbar#debug#log('File caching disabled')
                                    let fileinfo.fsize_exceeded = 0
                                    let ctags_output = s:ExecuteCtagsOnFile(a:fname, a:fname, typeinfo)
   27              0.000070     endif
                            
   27              0.000531     if ctags_output == -1
                                    call tagbar#debug#log('Ctags error when processing file')
                                    " Put an empty entry into known_files so the error message is only
                                    " shown once
                                    call s:known_files.put({}, a:fname)
                                    return
   27              0.000434     elseif ctags_output ==# ''
                                    call tagbar#debug#log('Ctags output empty')
                                    " No need to go through the tag processing if there are no tags, and
                                    " preserving the old fold state isn't necessary either
                                    call s:known_files.put(tagbar#prototypes#fileinfo#new(a:fname, a:ftype, s:known_types[a:ftype]), a:fname)
                                    return
   27              0.000057     endif
                            
   27   0.003769   0.002549     call tagbar#debug#log('Filetype tag kinds: ' . string(keys(typeinfo.kinddict)))
                            
                                " Parse the ctags output lines
   27   0.001792   0.000851     call tagbar#debug#log('Parsing ctags output')
   27              0.003222     let rawtaglist = split(ctags_output, '\n\+')
   27              0.000338     let seen = {}
  601              0.004596     for line in rawtaglist
                                    " skip comments and duplicates (can happen when --sort=no)
  574              0.018523         if line =~# '^!_TAG_' || has_key(seen, line)
                                        continue
  574              0.001269         endif
  574              0.004891         if g:tagbar_ignore_anonymous && line =~# '__anon'
                                        call tagbar#debug#log('anonymous tag found - ignoring per tagbar configuration')
                                        continue
  574              0.001003         endif
                            
  574              0.007244         let seen[line] = 1
                            
  574              0.013327         let parts = split(line, ';"')
  574              0.005672         if len(parts) == 2 " Is a valid tag line
  543   2.135554   0.029217             call s:ParseTagline(parts[0], parts[1], typeinfo, fileinfo)
  574              0.001323         endif
  601              0.001659     endfor
                            
                                " Create a placeholder tag for the 'kind' header for folding purposes, but
                                " only for non-scoped tags
  189              0.000766     for kind in typeinfo.kinds
  162              0.002561         if has_key(get(typeinfo, 'kind2scope', {}), kind.short)
   92              0.000246             continue
   70              0.000110         endif
                            
   70   0.016262   0.015787         let curtags = filter(copy(fileinfo.getTags()), 'v:val.fields.kind ==# kind.short && ' . '!has_key(v:val, "scope")')
   70   0.005006   0.002921         call tagbar#debug#log('Processing kind: ' . kind.short . ', number of tags: ' . len(curtags))
                            
   70              0.000450         if empty(curtags)
   11              0.000025             continue
   59              0.000162         endif
                            
   59   0.147338   0.045144         let kindtag          = tagbar#prototypes#kindheadertag#new(kind.long)
   59              0.000640         let kindtag.short    = kind.short
   59              0.000645         let kindtag.numtags  = len(curtags)
   59              0.000423         let kindtag.fileinfo = fileinfo
                            
  515              0.001488         for tag in curtags
  456              0.002128             let tag.parent = kindtag
  515              0.000941         endfor
   86              0.000322     endfor
                            
                                " Clear old folding information from previous file version to prevent leaks
   27   0.001765   0.000861     call fileinfo.clearOldFolds()
                            
                                " Sort the tags
   27   0.117096   0.000715     call fileinfo.sortTags(typeinfo)
                            
   27   0.001852   0.000633     call s:known_files.put(fileinfo)

FUNCTION  <SNR>138_ParseTagline()
    Defined: ~\AppData\Local\nvim-data\plugged\tagbar\autoload\tagbar.vim:1482
Called 543 times
Total time:   2.106337
 Self time:   0.387538

count  total (s)   self (s)
  543              0.013041     let basic_info  = split(a:part1, '\t')
  543              0.004834     let tagname  = basic_info[0]
  543              0.003973     let filename = basic_info[1]
                            
                                " the pattern can contain tabs and thus may have been split up, so join
                                " the rest of the items together again
  543              0.009763     let pattern = join(basic_info[2:], "\t")
  543              0.004430     if pattern[0] ==# '/'
  543              0.003248         let start   = 2 " skip the slash and the ^
  543              0.006572         let end     = strlen(pattern) - 1
  543              0.004954         if pattern[end - 1] ==# '$'
  543              0.003306             let end -= 1
  543              0.003042             let dollar = '\$'
                                    else
                                        let dollar = ''
  543              0.000889         endif
  543              0.011563         let pattern = '\V\^\C' . strpart(pattern, start, end - start) . dollar
                                else
                                    let pattern = ''
  543              0.000895     endif
                            
                                " When splitting fields make sure not to create empty keys or values in
                                " case a value illegally contains tabs
  543              0.020900     let fields = split(a:part2, '^\t\|\t\ze\w\+:')
  543              0.003881     let fielddict = {}
  543              0.006380     if fields[0] !~# ':'
  543              0.010769         let fielddict.kind = remove(fields, 0)
  543              0.001060     endif
 1172              0.006861     for field in fields
                                    " can't use split() since the value can contain ':'
  629              0.007182         let delimit = stridx(field, ':')
  629              0.007744         let key = strpart(field, 0, delimit)
                                    " Remove all tabs that may illegally be in the value
  629              0.016164         let val = substitute(strpart(field, delimit + 1), '\t', '', 'g')
                                    " File-restricted scoping
  629              0.004021         if key ==# 'file'
    1              0.000003             let fielddict[key] = 'yes'
  629              0.001195         endif
  629              0.006421         if len(val) > 0
  628              0.006380             if key ==# 'line' || key ==# 'column' || key ==# 'end'
  543              0.007561                 let fielddict[key] = str2nr(val)
   85              0.000206             else
   85              0.000867                 let fielddict[key] = val
  628              0.001212             endif
  629              0.001205         endif
 1172              0.004568     endfor
                            
                                " If the tag covers multiple scopes, split it up and create individual tags
                                " for each scope so that the hierarchy can be displayed correctly.
                                " This can happen with PHP's 'namespace' tags in uctags, for example.
  543              0.017746     if has_key(a:typeinfo, 'kind2scope') && has_key(a:typeinfo.kind2scope, fielddict.kind) && tagname =~# '\V' . escape(a:typeinfo.sro, '\')
                                    let tagparts = split(tagname, '\V' . escape(a:typeinfo.sro, '\'))
                            
                                    let scope = a:typeinfo.kind2scope[fielddict.kind]
                                    if has_key(fielddict, scope)
                                        let parent = fielddict[scope]
                                    else
                                        let parent = ''
                                    endif
                                    let curfielddict = fielddict
                            
                                    for i in range(len(tagparts))
                                        let part = tagparts[i]
                                        call s:ProcessTag(part, filename, pattern, curfielddict, i != len(tagparts) - 1, a:typeinfo, a:fileinfo)
                                        if parent !=# ''
                                            let parent = parent . a:typeinfo.sro . part
                                        else
                                            let parent = part
                                        endif
                                        let curfielddict = copy(fielddict)
                                        let curfielddict[scope] = parent
                                    endfor
  543              0.001127     else
  543   1.745596   0.026798         call s:ProcessTag(tagname, filename, pattern, fielddict, 0, a:typeinfo, a:fileinfo)
  543              0.000945     endif

FUNCTION  <SNR>138_EscapeCtagsCmd()
    Defined: ~\AppData\Local\nvim-data\plugged\tagbar\autoload\tagbar.vim:2988
Called 29 times
Total time:   0.053866
 Self time:   0.050050

count  total (s)   self (s)
   29   0.002100   0.001032     call tagbar#debug#log('EscapeCtagsCmd called')
   29   0.001574   0.000831     call tagbar#debug#log('ctags_bin: ' . a:ctags_bin)
   29              0.000461     if type(a:args)==type('')
    2   0.000114   0.000063         call tagbar#debug#log('ctags_args (is a string): ' . a:args)
   27              0.000312     elseif type(a:args)==type([])
   27   0.002206   0.001437         call tagbar#debug#log('ctags_args (is a list): ' . string(a:args))
   29              0.000100     endif
                            
   29              0.000396     if exists('+shellslash')
   29              0.000304         let shellslash_save = &shellslash
   29   0.010856   0.010799         set noshellslash
   29              0.000113     endif
                            
                                "Set up 0th argument of ctags_cmd
                                "a:ctags_bin may have special characters that require escaping.
   29              0.002648     if (&shell =~? 'cmd\.exe$' || &shell =~? 'powershell\.exe$' || &shell =~? 'powershell$' || &shell =~? 'pwsh\.exe$' || &shell =~? 'pwsh$') && a:ctags_bin !~# '\s'
                                    "For windows cmd.exe, escaping the 0th argument can cause
                                    "problems if it references a batch file and the batch file uses %~dp0.
                                    "So for windows cmd.exe, only escape the 0th argument iff necessary.
                                    "Only known necessary case is when ctags_bin executable filename has
                                    "whitespace character(s).
                            
                                    "  Example: If 0th argument is wrapped in double quotes AND it is not
                                    "  an absolute path to ctags_bin, but rather an executable in %PATH%,
                                    "  then %~dp0 resolves to the current working directory rather than
                                    "  the batch file's directory. Batch files like this generally exepect
                                    "  and depend on %~dp0 to resolve the batch file's directory.
                                    "  Note: Documentation such as `help cmd.exe` and
                                    "  http://www.microsoft.com/resources/documentation/windows/xp/all/proddocs/en-us/cmd.mspx?mfr=true
                                    "  suggest other special characters that require escaping for command
                                    "  line completion.  But tagbar.vim does not use the command line
                                    "  completion feature of cmd.exe and testing shows that the only special
                                    "  character that needs to be escaped for tagbar.vim is <space> for
                                    "  windows cmd.exe.
   29              0.000366         let ctags_cmd = a:ctags_bin
                                else
                                    let ctags_cmd = shellescape(a:ctags_bin)
   29              0.000061     endif
                            
                                "Add additional arguments to ctags_cmd
   29              0.000384     if type(a:args)==type('')
                                    "When a:args is a string, append the arguments
                                    "Note: In this case, do not attempt to shell escape a:args string.
                                    "This function expects the string to already be escaped properly for
                                    "the shell type. Why not escape? Because it could be ambiguous about
                                    "whether a space is an argument separator or included in the argument.
                                    "Since escaping rules vary from shell to shell, it is better to pass a
                                    "list of arguments to a:args. With a list, each argument is clearly
                                    "separated, so shellescape() can calculate the appropriate escaping
                                    "for each argument for the current &shell.
    2              0.000033         let ctags_cmd .= ' ' . a:args
   27              0.000312     elseif type(a:args)==type([])
                                    "When a:args is a list, shellescape() each argument and append ctags_cmd
                                    "Note: It's a better practice to shellescape() each argument separately so that
                                    "spaces used as a separator between arguments can be distinguished with
                                    "spaces used inside a single argument.
  324              0.001444         for arg in a:args
  297              0.005332             let ctags_cmd .= ' ' . shellescape(arg)
  324              0.000871         endfor
   29              0.000066     endif
                            
                                "if a filename was specified, add filename as final argument to ctags_cmd.
   29              0.000188     if a:0 == 1
   27              0.000638         let ctags_cmd .= ' ' . shellescape(a:1)
   29              0.000059     endif
                            
   29              0.000346     if exists('+shellslash')
   29   0.010367   0.010345         let &shellslash = shellslash_save
   29              0.000122     endif
                            
                                " Needed for cases where 'encoding' is different from the system's
                                " encoding
   29              0.001209     if has('multi_byte')
   29              0.000391         if g:tagbar_systemenc != &encoding
                                        let ctags_cmd = iconv(ctags_cmd, &encoding, g:tagbar_systemenc)
   29              0.001084         elseif $LANG !=# ''
                                        let ctags_cmd = iconv(ctags_cmd, &encoding, $LANG)
   29              0.000069         endif
   29              0.000047     endif
                            
   29   0.002592   0.001487     call tagbar#debug#log('Escaped ctags command: ' . ctags_cmd)
                            
   29              0.000213     if ctags_cmd ==# ''
                                    if !s:warnings.encoding
                                        call s:warning('Tagbar: Ctags command encoding conversion failed!' . ' Please read ":h g:tagbar_systemenc".')
                                        let s:warnings.encoding = 1
                                    endif
   29              0.000049     endif
                            
   29              0.000248     return ctags_cmd

FUNCTION  <SNR>122_indent_like_block()
    Defined: ~\AppData\Local\nvim-data\plugged\vim-polyglot\indent\python.vim:255
Called 1 time
Total time:   0.000518
 Self time:   0.000518

count  total (s)   self (s)
    1              0.000013     let text = getline(a:lnum)
    3              0.000042     for [multiple, block_rules] in [ [0, s:block_rules], [1, s:block_rules_multiple], ]
    6              0.000065         for [line_re, blocks_ignore] in items(block_rules)
    4              0.000099             if text !~# line_re
    4              0.000012                 continue
                                        endif
                            
                                        let [blocks, skip] = blocks_ignore
                                        let indents = s:find_start_of_block(a:lnum, blocks, skip, multiple)
                                        if empty(indents)
                                            return -1
                                        endif
                                        if len(indents) == 1
                                            return indents[0]
                                        endif
                            
                                        " Multiple valid indents, e.g. for 'else' with both try and if.
                                        let indent = indent(a:lnum)
                                        if index(indents, indent) != -1
                                            " The indent is valid, keep it.
                                            return indent
                                        endif
                                        " Fallback to the first/nearest one.
                                        return indents[0]
    2              0.000005         endfor
    3              0.000016     endfor
    1              0.000004     return -2

FUNCTION  tagbar#types#ctags#init()
    Defined: ~\AppData\Local\nvim-data\plugged\tagbar\autoload\tagbar\types\ctags.vim:3
Called 1 time
Total time:   0.169694
 Self time:   0.154518

count  total (s)   self (s)
    1              0.000021     let types = {}
                            
                                " Ant {{{1
    1   0.032288   0.030652     let type_ant = tagbar#prototypes#typeinfo#new()
    1              0.000008     let type_ant.ctagstype = 'ant'
    1              0.000039     let type_ant.kinds     = [ {'short' : 'p', 'long' : 'projects', 'fold' : 0, 'stl' : 1}, {'short' : 't', 'long' : 'targets',  'fold' : 0, 'stl' : 1} ]
    1              0.000007     let types.ant = type_ant
                                " Asm {{{1
    1   0.000199   0.000030     let type_asm = tagbar#prototypes#typeinfo#new()
    1              0.000007     let type_asm.ctagstype = 'asm'
    1              0.000069     let type_asm.kinds     = [ {'short' : 'm', 'long' : 'macros',  'fold' : 0, 'stl' : 1}, {'short' : 't', 'long' : 'types',   'fold' : 0, 'stl' : 1}, {'short' : 'd', 'long' : 'defines', 'fold' : 0, 'stl' : 1}, {'short' : 'l', 'long' : 'labels',  'fold' : 0, 'stl' : 1} ]
    1              0.000006     let types.asm = type_asm
                                " ASP {{{1
    1   0.000179   0.000027     let type_aspvbs = tagbar#prototypes#typeinfo#new()
    1              0.000007     let type_aspvbs.ctagstype = 'asp'
    1              0.000091     let type_aspvbs.kinds     = [ {'short' : 'd', 'long' : 'constants',   'fold' : 0, 'stl' : 1}, {'short' : 'c', 'long' : 'classes',     'fold' : 0, 'stl' : 1}, {'short' : 'f', 'long' : 'functions',   'fold' : 0, 'stl' : 1}, {'short' : 's', 'long' : 'subroutines', 'fold' : 0, 'stl' : 1}, {'short' : 'v', 'long' : 'variables',   'fold' : 0, 'stl' : 1} ]
    1              0.000007     let types.aspvbs = type_aspvbs
                                " Asymptote {{{1
                                " Asymptote gets parsed well using filetype = c
    1   0.000226   0.000050     let type_asy = tagbar#prototypes#typeinfo#new()
    1              0.000006     let type_asy.ctagstype = 'c'
    1              0.000233     let type_asy.kinds     = [ {'short' : 'd', 'long' : 'macros',      'fold' : 1, 'stl' : 0}, {'short' : 'p', 'long' : 'prototypes',  'fold' : 1, 'stl' : 0}, {'short' : 'g', 'long' : 'enums',       'fold' : 0, 'stl' : 1}, {'short' : 'e', 'long' : 'enumerators', 'fold' : 0, 'stl' : 0}, {'short' : 't', 'long' : 'typedefs',    'fold' : 0, 'stl' : 0}, {'short' : 's', 'long' : 'structs',     'fold' : 0, 'stl' : 1}, {'short' : 'u', 'long' : 'unions',      'fold' : 0, 'stl' : 1}, {'short' : 'm', 'long' : 'members',     'fold' : 0, 'stl' : 0}, {'short' : 'v', 'long' : 'variables',   'fold' : 0, 'stl' : 0}, {'short' : 'f', 'long' : 'functions',   'fold' : 0, 'stl' : 1} ]
    1              0.000006     let type_asy.sro        = '::'
    1              0.000016     let type_asy.kind2scope = { 'g' : 'enum', 's' : 'struct', 'u' : 'union' }
    1              0.000016     let type_asy.scope2kind = { 'enum'   : 'g', 'struct' : 's', 'union'  : 'u' }
    1              0.000006     let types.asy = type_asy
                                " Awk {{{1
    1   0.000188   0.000027     let type_awk = tagbar#prototypes#typeinfo#new()
    1              0.000006     let type_awk.ctagstype = 'awk'
    1              0.000020     let type_awk.kinds     = [ {'short' : 'f', 'long' : 'functions', 'fold' : 0, 'stl' : 1} ]
    1              0.000006     let types.awk = type_awk
                                " Basic {{{1
    1   0.000174   0.000027     let type_basic = tagbar#prototypes#typeinfo#new()
    1              0.000007     let type_basic.ctagstype = 'basic'
    1              0.000196     let type_basic.kinds     = [ {'short' : 'c', 'long' : 'constants',    'fold' : 0, 'stl' : 1}, {'short' : 'g', 'long' : 'enumerations', 'fold' : 0, 'stl' : 1}, {'short' : 'f', 'long' : 'functions',    'fold' : 0, 'stl' : 1}, {'short' : 'l', 'long' : 'labels',       'fold' : 0, 'stl' : 1}, {'short' : 't', 'long' : 'types',        'fold' : 0, 'stl' : 1}, {'short' : 'v', 'long' : 'variables',    'fold' : 0, 'stl' : 1} ]
    1              0.000008     let types.basic = type_basic
                                " BETA {{{1
    1   0.000185   0.000033     let type_beta = tagbar#prototypes#typeinfo#new()
    1              0.000006     let type_beta.ctagstype = 'beta'
    1              0.000049     let type_beta.kinds     = [ {'short' : 'f', 'long' : 'fragments', 'fold' : 0, 'stl' : 1}, {'short' : 's', 'long' : 'slots',     'fold' : 0, 'stl' : 1}, {'short' : 'v', 'long' : 'patterns',  'fold' : 0, 'stl' : 1} ]
    1              0.000006     let types.beta = type_beta
                                " C {{{1
    1   0.000168   0.000026     let type_c = tagbar#prototypes#typeinfo#new()
    1              0.000006     let type_c.ctagstype = 'c'
    1              0.000325     let type_c.kinds     = [ {'short' : 'd', 'long' : 'macros',      'fold' : 1, 'stl' : 0}, {'short' : 'p', 'long' : 'prototypes',  'fold' : 1, 'stl' : 0}, {'short' : 'g', 'long' : 'enums',       'fold' : 0, 'stl' : 1}, {'short' : 'e', 'long' : 'enumerators', 'fold' : 0, 'stl' : 0}, {'short' : 't', 'long' : 'typedefs',    'fold' : 0, 'stl' : 0}, {'short' : 's', 'long' : 'structs',     'fold' : 0, 'stl' : 1}, {'short' : 'u', 'long' : 'unions',      'fold' : 0, 'stl' : 1}, {'short' : 'm', 'long' : 'members',     'fold' : 0, 'stl' : 0}, {'short' : 'v', 'long' : 'variables',   'fold' : 0, 'stl' : 0}, {'short' : 'f', 'long' : 'functions',   'fold' : 0, 'stl' : 1} ]
    1              0.000008     let type_c.sro        = '::'
    1              0.000015     let type_c.kind2scope = { 'g' : 'enum', 's' : 'struct', 'u' : 'union' }
    1              0.000034     let type_c.scope2kind = { 'enum'   : 'g', 'struct' : 's', 'union'  : 'u' }
    1              0.000012     let types.c = type_c
    1              0.000008     let types.lpc = type_c
                                " C++ {{{1
    1   0.000374   0.000057     let type_cpp = tagbar#prototypes#typeinfo#new()
    1              0.000010     let type_cpp.ctagstype = 'c++'
    1              0.000313     let type_cpp.kinds     = [ {'short' : 'd', 'long' : 'macros',      'fold' : 1, 'stl' : 0}, {'short' : 'p', 'long' : 'prototypes',  'fold' : 1, 'stl' : 0}, {'short' : 'g', 'long' : 'enums',       'fold' : 0, 'stl' : 1}, {'short' : 'e', 'long' : 'enumerators', 'fold' : 0, 'stl' : 0}, {'short' : 't', 'long' : 'typedefs',    'fold' : 0, 'stl' : 0}, {'short' : 'n', 'long' : 'namespaces',  'fold' : 0, 'stl' : 1}, {'short' : 'c', 'long' : 'classes',     'fold' : 0, 'stl' : 1}, {'short' : 's', 'long' : 'structs',     'fold' : 0, 'stl' : 1}, {'short' : 'u', 'long' : 'unions',      'fold' : 0, 'stl' : 1}, {'short' : 'f', 'long' : 'functions',   'fold' : 0, 'stl' : 1}, {'short' : 'm', 'long' : 'members',     'fold' : 0, 'stl' : 0}, {'short' : 'v', 'long' : 'variables',   'fold' : 0, 'stl' : 0} ]
    1              0.000006     let type_cpp.sro        = '::'
    1              0.000073     let type_cpp.kind2scope = { 'g' : 'enum', 'n' : 'namespace', 'c' : 'class', 's' : 'struct', 'u' : 'union' }
    1              0.000023     let type_cpp.scope2kind = { 'enum'      : 'g', 'namespace' : 'n', 'class'     : 'c', 'struct'    : 's', 'union'     : 'u' }
    1              0.000007     let types.cpp = type_cpp
    1              0.000006     let types.cuda = type_cpp
                                " C# {{{1
    1   0.000230   0.000036     let type_cs = tagbar#prototypes#typeinfo#new()
    1              0.000006     let type_cs.ctagstype = 'c#'
    1              0.000357     let type_cs.kinds     = [ {'short' : 'd', 'long' : 'macros',      'fold' : 1, 'stl' : 0}, {'short' : 'f', 'long' : 'fields',      'fold' : 0, 'stl' : 1}, {'short' : 'g', 'long' : 'enums',       'fold' : 0, 'stl' : 1}, {'short' : 'e', 'long' : 'enumerators', 'fold' : 0, 'stl' : 0}, {'short' : 't', 'long' : 'typedefs',    'fold' : 0, 'stl' : 1}, {'short' : 'n', 'long' : 'namespaces',  'fold' : 0, 'stl' : 1}, {'short' : 'i', 'long' : 'interfaces',  'fold' : 0, 'stl' : 1}, {'short' : 'c', 'long' : 'classes',     'fold' : 0, 'stl' : 1}, {'short' : 's', 'long' : 'structs',     'fold' : 0, 'stl' : 1}, {'short' : 'E', 'long' : 'events',      'fold' : 0, 'stl' : 1}, {'short' : 'm', 'long' : 'methods',     'fold' : 0, 'stl' : 1}, {'short' : 'p', 'long' : 'properties',  'fold' : 0, 'stl' : 1} ]
    1              0.000008     let type_cs.sro        = '.'
    1              0.000027     let type_cs.kind2scope = { 'n' : 'namespace', 'i' : 'interface', 'c' : 'class', 's' : 'struct', 'g' : 'enum' }
    1              0.000033     let type_cs.scope2kind = { 'namespace' : 'n', 'interface' : 'i', 'class'     : 'c', 'struct'    : 's', 'enum'      : 'g' }
    1              0.000010     let types.cs = type_cs
                                " COBOL {{{1
    1   0.000312   0.000050     let type_cobol = tagbar#prototypes#typeinfo#new()
    1              0.000012     let type_cobol.ctagstype = 'cobol'
    1              0.000188     let type_cobol.kinds     = [ {'short' : 'd', 'long' : 'data items',        'fold' : 0, 'stl' : 1}, {'short' : 'f', 'long' : 'file descriptions', 'fold' : 0, 'stl' : 1}, {'short' : 'g', 'long' : 'group items',       'fold' : 0, 'stl' : 1}, {'short' : 'p', 'long' : 'paragraphs',        'fold' : 0, 'stl' : 1}, {'short' : 'P', 'long' : 'program ids',       'fold' : 0, 'stl' : 1}, {'short' : 's', 'long' : 'sections',          'fold' : 0, 'stl' : 1} ]
    1              0.000013     let types.cobol = type_cobol
                                " Crystal {{{1
    1   0.000202   0.000039     let type_crystal = tagbar#prototypes#typeinfo#new()
    1              0.000007     let type_crystal.ctagstype = 'crystal'
    1              0.000184     let type_crystal.kinds     = [ {'short' : 'm', 'long' : 'modules',           'fold' : 0, 'stl' : 1}, {'short' : 'c', 'long' : 'classes',           'fold' : 0, 'stl' : 1}, {'short' : 'd', 'long' : 'defs',              'fold' : 0, 'stl' : 1}, {'short' : 'f', 'long' : 'functions',         'fold' : 0, 'stl' : 1}, {'short' : 'M', 'long' : 'macros',            'fold' : 0, 'stl' : 1}, {'short' : 'l', 'long' : 'libs',              'fold' : 0, 'stl' : 1}, {'short' : 's', 'long' : 'structs',           'fold' : 0, 'stl' : 1}, {'short' : 'a', 'long' : 'aliases',           'fold' : 0, 'stl' : 1} ]
    1              0.000006     let type_crystal.sro        = '::'
    1              0.000008     let types.crystal = type_crystal
                                " DOS Batch {{{1
    1   0.000177   0.000028     let type_dosbatch = tagbar#prototypes#typeinfo#new()
    1              0.000008     let type_dosbatch.ctagstype = 'dosbatch'
    1              0.000035     let type_dosbatch.kinds     = [ {'short' : 'l', 'long' : 'labels',    'fold' : 0, 'stl' : 1}, {'short' : 'v', 'long' : 'variables', 'fold' : 0, 'stl' : 1} ]
    1              0.000010     let types.dosbatch = type_dosbatch
                                " Eiffel {{{1
    1   0.000201   0.000028     let type_eiffel = tagbar#prototypes#typeinfo#new()
    1              0.000007     let type_eiffel.ctagstype = 'eiffel'
    1              0.000034     let type_eiffel.kinds     = [ {'short' : 'c', 'long' : 'classes',  'fold' : 0, 'stl' : 1}, {'short' : 'f', 'long' : 'features', 'fold' : 0, 'stl' : 1} ]
    1              0.000008     let type_eiffel.sro        = '.' " Not sure, is nesting even possible?
    1              0.000030     let type_eiffel.kind2scope = { 'c' : 'class', 'f' : 'feature' }
    1              0.000023     let type_eiffel.scope2kind = { 'class'   : 'c', 'feature' : 'f' }
    1              0.000008     let types.eiffel = type_eiffel
                                " Erlang {{{1
    1   0.000215   0.000035     let type_erlang = tagbar#prototypes#typeinfo#new()
    1              0.000007     let type_erlang.ctagstype = 'erlang'
    1              0.000104     let type_erlang.kinds     = [ {'short' : 'm', 'long' : 'modules',            'fold' : 0, 'stl' : 1}, {'short' : 'd', 'long' : 'macro definitions',  'fold' : 0, 'stl' : 1}, {'short' : 'f', 'long' : 'functions',          'fold' : 0, 'stl' : 1}, {'short' : 'r', 'long' : 'record definitions', 'fold' : 0, 'stl' : 1} ]
    1              0.000008     let type_erlang.sro        = '.' " Not sure, is nesting even possible?
    1              0.000010     let type_erlang.kind2scope = { 'm' : 'module' }
    1              0.000010     let type_erlang.scope2kind = { 'module' : 'm' }
    1              0.000007     let types.erlang = type_erlang
                                " Flex {{{1
                                " Vim doesn't support Flex out of the box, this is based on rough
                                " guesses and probably requires
                                " http://www.vim.org/scripts/script.php?script_id=2909
                                " Improvements welcome!
    1   0.000181   0.000029     let type_as = tagbar#prototypes#typeinfo#new()
    1              0.000006     let type_as.ctagstype = 'flex'
    1              0.000128     let type_as.kinds     = [ {'short' : 'v', 'long' : 'global variables', 'fold' : 0, 'stl' : 0}, {'short' : 'c', 'long' : 'classes',          'fold' : 0, 'stl' : 1}, {'short' : 'm', 'long' : 'methods',          'fold' : 0, 'stl' : 1}, {'short' : 'p', 'long' : 'properties',       'fold' : 0, 'stl' : 1}, {'short' : 'f', 'long' : 'functions',        'fold' : 0, 'stl' : 1}, {'short' : 'x', 'long' : 'mxtags',           'fold' : 0, 'stl' : 0} ]
    1              0.000006     let type_as.sro        = '.'
    1              0.000010     let type_as.kind2scope = { 'c' : 'class' }
    1              0.000012     let type_as.scope2kind = { 'class' : 'c' }
    1              0.000007     let types.mxml = type_as
    1              0.000007     let types.actionscript = type_as
                                " Fortran {{{1
    1   0.000299   0.000036     let type_fortran = tagbar#prototypes#typeinfo#new()
    1              0.000012     let type_fortran.ctagstype = 'fortran'
    1              0.000396     let type_fortran.kinds     = [ {'short' : 'm', 'long' : 'modules',    'fold' : 0, 'stl' : 1}, {'short' : 'p', 'long' : 'programs',   'fold' : 0, 'stl' : 1}, {'short' : 'k', 'long' : 'components', 'fold' : 0, 'stl' : 1}, {'short' : 't', 'long' : 'derived types and structures', 'fold' : 0, 'stl' : 1}, {'short' : 'c', 'long' : 'common blocks', 'fold' : 0, 'stl' : 1}, {'short' : 'b', 'long' : 'block data',    'fold' : 0, 'stl' : 0}, {'short' : 'e', 'long' : 'entry points',  'fold' : 0, 'stl' : 1}, {'short' : 'f', 'long' : 'functions',     'fold' : 0, 'stl' : 1}, {'short' : 's', 'long' : 'subroutines',   'fold' : 0, 'stl' : 1}, {'short' : 'l', 'long' : 'labels',        'fold' : 0, 'stl' : 1}, {'short' : 'n', 'long' : 'namelists',     'fold' : 0, 'stl' : 1}, {'short' : 'v', 'long' : 'variables',     'fold' : 0, 'stl' : 0} ]
    1              0.000013     let type_fortran.sro        = '.' " Not sure, is nesting even possible?
    1              0.000027     let type_fortran.kind2scope = { 'm' : 'module', 'p' : 'program', 'f' : 'function', 's' : 'subroutine' }
    1              0.000026     let type_fortran.scope2kind = { 'module'     : 'm', 'program'    : 'p', 'function'   : 'f', 'subroutine' : 's' }
    1              0.000010     let types.fortran = type_fortran
                                " Go {{{1
    1   0.000241   0.000041     let type_go = tagbar#prototypes#typeinfo#new()
    1              0.000008     let type_go.ctagstype = 'go'
    1              0.000289     let type_go.kinds = [ {'short' : 'p', 'long' : 'packages',       'fold' : 0, 'stl' : 0}, {'short' : 'i', 'long' : 'interfaces',     'fold' : 0, 'stl' : 0}, {'short' : 'c', 'long' : 'constants',      'fold' : 0, 'stl' : 0}, {'short' : 's', 'long' : 'structs',        'fold' : 0, 'stl' : 1}, {'short' : 'm', 'long' : 'struct members', 'fold' : 0, 'stl' : 0}, {'short' : 't', 'long' : 'types',          'fold' : 0, 'stl' : 1}, {'short' : 'f', 'long' : 'functions',      'fold' : 0, 'stl' : 1}, {'short' : 'v', 'long' : 'variables',      'fold' : 0, 'stl' : 0} ]
    1              0.000010     let type_go.sro = '.'
    1              0.000013     let type_go.kind2scope = { 's' : 'struct' }
    1              0.000012     let type_go.scope2kind = { 'struct' : 's' }
    1              0.000008     let types.go = type_go
                                " HTML {{{1
    1   0.000243   0.000043     let type_html = tagbar#prototypes#typeinfo#new()
    1              0.000008     let type_html.ctagstype = 'html'
    1              0.000041     let type_html.kinds = [ {'short' : 'f', 'long' : 'JavaScript functions', 'fold' : 0, 'stl' : 1}, {'short' : 'a', 'long' : 'named anchors',        'fold' : 0, 'stl' : 1} ]
    1              0.000008     let types.html = type_html
                                " Java {{{1
    1   0.000213   0.000034     let type_java = tagbar#prototypes#typeinfo#new()
    1              0.000009     let type_java.ctagstype = 'java'
    1              0.000171     let type_java.kinds     = [ {'short' : 'p', 'long' : 'packages',       'fold' : 1, 'stl' : 0}, {'short' : 'f', 'long' : 'fields',         'fold' : 0, 'stl' : 0}, {'short' : 'g', 'long' : 'enum types',     'fold' : 0, 'stl' : 1}, {'short' : 'e', 'long' : 'enum constants', 'fold' : 0, 'stl' : 0}, {'short' : 'i', 'long' : 'interfaces',     'fold' : 0, 'stl' : 1}, {'short' : 'c', 'long' : 'classes',        'fold' : 0, 'stl' : 1}, {'short' : 'm', 'long' : 'methods',        'fold' : 0, 'stl' : 1} ]
    1              0.000009     let type_java.sro        = '.'
    1              0.000016     let type_java.kind2scope = { 'g' : 'enum', 'i' : 'interface', 'c' : 'class' }
    1              0.000040     let type_java.scope2kind = { 'enum'      : 'g', 'interface' : 'i', 'class'     : 'c' }
    1              0.000008     let types.java = type_java
                                " JavaScript {{{1
    1   0.000205   0.000036     let type_javascript = tagbar#prototypes#typeinfo#new()
    1              0.000008     let type_javascript.ctagstype = 'javascript'
    1              0.000101     let type_javascript.kinds = [ {'short': 'v', 'long': 'global variables', 'fold': 0, 'stl': 0}, {'short': 'c', 'long': 'classes',          'fold': 0, 'stl': 1}, {'short': 'p', 'long': 'properties',       'fold': 0, 'stl': 0}, {'short': 'm', 'long': 'methods',          'fold': 0, 'stl': 1}, {'short': 'f', 'long': 'functions',        'fold': 0, 'stl': 1}, ]
    1              0.000007     let type_javascript.sro        = '.'
    1              0.000032     let type_javascript.kind2scope = { 'c' : 'class', 'f' : 'function', 'm' : 'method', 'p' : 'property', }
    1              0.000015     let type_javascript.scope2kind = { 'class'    : 'c', 'function' : 'f', }
    1              0.000009     let types.javascript = type_javascript
                                " Lisp {{{1
    1   0.000196   0.000033     let type_lisp = tagbar#prototypes#typeinfo#new()
    1              0.000006     let type_lisp.ctagstype = 'lisp'
    1              0.000020     let type_lisp.kinds     = [ {'short' : 'f', 'long' : 'functions', 'fold' : 0, 'stl' : 1} ]
    1              0.000006     let types.lisp = type_lisp
    1              0.000006     let types.clojure = type_lisp
                                " Lua {{{1
    1   0.000173   0.000027     let type_lua = tagbar#prototypes#typeinfo#new()
    1              0.000006     let type_lua.ctagstype = 'lua'
    1              0.000019     let type_lua.kinds     = [ {'short' : 'f', 'long' : 'functions', 'fold' : 0, 'stl' : 1} ]
    1              0.000006     let types.lua = type_lua
                                " Make {{{1
    1   0.000211   0.000027     let type_make = tagbar#prototypes#typeinfo#new()
    1              0.000006     let type_make.ctagstype = 'make'
    1              0.000019     let type_make.kinds     = [ {'short' : 'm', 'long' : 'macros', 'fold' : 0, 'stl' : 1} ]
    1              0.000006     let types.make = type_make
                                " Matlab {{{1
    1   0.000171   0.000027     let type_matlab = tagbar#prototypes#typeinfo#new()
    1              0.000007     let type_matlab.ctagstype = 'matlab'
    1              0.000019     let type_matlab.kinds     = [ {'short' : 'f', 'long' : 'functions', 'fold' : 0, 'stl' : 1} ]
    1              0.000007     let types.matlab = type_matlab
                                " ObjectiveC {{{1
    1   0.000168   0.000026     let type_objc = tagbar#prototypes#typeinfo#new()
    1              0.000007     let type_objc.ctagstype = 'objectivec'
    1              0.000472     let type_objc.kinds = [ {'short' : 'M', 'long' : 'preprocessor macros',   'fold' : 1, 'stl' : 0}, {'short' : 'v', 'long' : 'global variables',      'fold' : 0, 'stl' : 0}, {'short' : 'i', 'long' : 'class interfaces',      'fold' : 0, 'stl' : 1}, {'short' : 'I', 'long' : 'class implementations', 'fold' : 0, 'stl' : 1}, {'short' : 'c', 'long' : 'class methods',         'fold' : 0, 'stl' : 1}, {'short' : 'F', 'long' : 'object fields',         'fold' : 0, 'stl' : 0}, {'short' : 'm', 'long' : 'object methods',        'fold' : 0, 'stl' : 1}, {'short' : 's', 'long' : 'type structures',       'fold' : 0, 'stl' : 1}, {'short' : 't', 'long' : 'type aliases',          'fold' : 0, 'stl' : 1}, {'short' : 'e', 'long' : 'enumerations',          'fold' : 0, 'stl' : 1}, {'short' : 'f', 'long' : 'functions',             'fold' : 0, 'stl' : 1}, {'short' : 'p', 'long' : 'properties',            'fold' : 0, 'stl' : 0}, ]
    1              0.000008     let type_objc.sro        = ':'
    1              0.000017     let type_objc.kind2scope = { 'i' : 'interface', 'I' : 'implementation', 's' : 'struct', }
    1              0.000017     let type_objc.scope2kind = { 'interface' : 'i', 'implementation' : 'I', 'struct' : 's', }
    1              0.000006     let types.objc = type_objc
    1              0.000006     let types.objcpp = type_objc
                                " Ocaml {{{1
    1   0.000189   0.000034     let type_ocaml = tagbar#prototypes#typeinfo#new()
    1              0.000007     let type_ocaml.ctagstype = 'ocaml'
    1              0.000222     let type_ocaml.kinds     = [ {'short' : 'M', 'long' : 'modules or functors', 'fold' : 0, 'stl' : 1}, {'short' : 'v', 'long' : 'global variables',    'fold' : 0, 'stl' : 0}, {'short' : 'c', 'long' : 'classes',             'fold' : 0, 'stl' : 1}, {'short' : 'C', 'long' : 'constructors',        'fold' : 0, 'stl' : 1}, {'short' : 'm', 'long' : 'methods',             'fold' : 0, 'stl' : 1}, {'short' : 'e', 'long' : 'exceptions',          'fold' : 0, 'stl' : 1}, {'short' : 't', 'long' : 'type names',          'fold' : 0, 'stl' : 1}, {'short' : 'f', 'long' : 'functions',           'fold' : 0, 'stl' : 1}, {'short' : 'r', 'long' : 'structure fields',    'fold' : 0, 'stl' : 0} ]
    1              0.000007     let type_ocaml.sro        = '.' " Not sure, is nesting even possible?
    1              0.000015     let type_ocaml.kind2scope = { 'M' : 'Module', 'c' : 'class', 't' : 'type' }
    1              0.000015     let type_ocaml.scope2kind = { 'Module' : 'M', 'class'  : 'c', 'type'   : 't' }
    1              0.000006     let types.ocaml = type_ocaml
                                " Pascal {{{1
    1   0.000175   0.000028     let type_pascal = tagbar#prototypes#typeinfo#new()
    1              0.000007     let type_pascal.ctagstype = 'pascal'
    1              0.000034     let type_pascal.kinds     = [ {'short' : 'f', 'long' : 'functions',  'fold' : 0, 'stl' : 1}, {'short' : 'p', 'long' : 'procedures', 'fold' : 0, 'stl' : 1} ]
    1              0.000007     let types.pascal = type_pascal
                                " Perl {{{1
    1   0.000208   0.000026     let type_perl = tagbar#prototypes#typeinfo#new()
    1              0.000007     let type_perl.ctagstype = 'perl'
    1              0.000091     let type_perl.kinds     = [ {'short' : 'p', 'long' : 'packages',    'fold' : 1, 'stl' : 0}, {'short' : 'c', 'long' : 'constants',   'fold' : 0, 'stl' : 0}, {'short' : 'f', 'long' : 'formats',     'fold' : 0, 'stl' : 0}, {'short' : 'l', 'long' : 'labels',      'fold' : 0, 'stl' : 1}, {'short' : 's', 'long' : 'subroutines', 'fold' : 0, 'stl' : 1} ]
    1              0.000006     let types.perl = type_perl
                                " PHP {{{1
    1   0.000173   0.000028     let type_php = tagbar#prototypes#typeinfo#new()
    1              0.000006     let type_php.ctagstype = 'php'
    1              0.000168     let type_php.kinds     = [ {'short' : 'i', 'long' : 'interfaces',           'fold' : 0, 'stl' : 1}, {'short' : 'c', 'long' : 'classes',              'fold' : 0, 'stl' : 1}, {'short' : 'd', 'long' : 'constant definitions', 'fold' : 0, 'stl' : 0}, {'short' : 'f', 'long' : 'functions',            'fold' : 0, 'stl' : 1}, {'short' : 'v', 'long' : 'variables',            'fold' : 0, 'stl' : 0}, {'short' : 'j', 'long' : 'javascript functions', 'fold' : 0, 'stl' : 1} ]
    1              0.000008     let types.php = type_php
                                " Python {{{1
    1   0.000219   0.000049     let type_python = tagbar#prototypes#typeinfo#new()
    1              0.000006     let type_python.ctagstype = 'python'
    1              0.000089     let type_python.kinds     = [ {'short' : 'i', 'long' : 'imports',   'fold' : 1, 'stl' : 0}, {'short' : 'c', 'long' : 'classes',   'fold' : 0, 'stl' : 1}, {'short' : 'f', 'long' : 'functions', 'fold' : 0, 'stl' : 1}, {'short' : 'm', 'long' : 'members',   'fold' : 0, 'stl' : 1}, {'short' : 'v', 'long' : 'variables', 'fold' : 0, 'stl' : 0} ]
    1              0.000006     let type_python.sro        = '.'
    1              0.000016     let type_python.kind2scope = { 'c' : 'class', 'f' : 'function', 'm' : 'function' }
    1              0.000013     let type_python.scope2kind = { 'class'    : 'c', 'function' : 'f' }
    1              0.000007     let types.python = type_python
    1              0.000006     let types.pyrex  = type_python
    1              0.000005     let types.cython = type_python
                                " REXX {{{1
    1   0.000205   0.000032     let type_rexx = tagbar#prototypes#typeinfo#new()
    1              0.000006     let type_rexx.ctagstype = 'rexx'
    1              0.000021     let type_rexx.kinds     = [ {'short' : 's', 'long' : 'subroutines', 'fold' : 0, 'stl' : 1} ]
    1              0.000007     let types.rexx = type_rexx
                                " Ruby {{{1
    1   0.000171   0.000026     let type_ruby = tagbar#prototypes#typeinfo#new()
    1              0.000006     let type_ruby.ctagstype = 'ruby'
    1              0.000072     let type_ruby.kinds     = [ {'short' : 'm', 'long' : 'modules',           'fold' : 0, 'stl' : 1}, {'short' : 'c', 'long' : 'classes',           'fold' : 0, 'stl' : 1}, {'short' : 'f', 'long' : 'methods',           'fold' : 0, 'stl' : 1}, {'short' : 'F', 'long' : 'singleton methods', 'fold' : 0, 'stl' : 1} ]
    1              0.000006     let type_ruby.sro        = '.'
    1              0.000024     let type_ruby.kind2scope = { 'c' : 'class', 'm' : 'class', 'f' : 'class' }
    1              0.000010     let type_ruby.scope2kind = { 'class' : 'c' }
    1              0.000006     let types.ruby = type_ruby
                                " Scheme {{{1
    1   0.000181   0.000026     let type_scheme = tagbar#prototypes#typeinfo#new()
    1              0.000007     let type_scheme.ctagstype = 'scheme'
    1              0.000034     let type_scheme.kinds     = [ {'short' : 'f', 'long' : 'functions', 'fold' : 0, 'stl' : 1}, {'short' : 's', 'long' : 'sets',      'fold' : 0, 'stl' : 1} ]
    1              0.000006     let types.scheme = type_scheme
    1              0.000005     let types.racket = type_scheme
                                " Shell script {{{1
    1   0.000172   0.000028     let type_sh = tagbar#prototypes#typeinfo#new()
    1              0.000006     let type_sh.ctagstype = 'sh'
    1              0.000019     let type_sh.kinds     = [ {'short' : 'f', 'long' : 'functions', 'fold' : 0, 'stl' : 1} ]
    1              0.000016     let types.sh = type_sh
    1              0.000010     let types.csh = type_sh
    1              0.000009     let types.zsh = type_sh
                                " SLang {{{1
    1   0.000201   0.000027     let type_slang = tagbar#prototypes#typeinfo#new()
    1              0.000006     let type_slang.ctagstype = 'slang'
    1              0.000034     let type_slang.kinds     = [ {'short' : 'n', 'long' : 'namespaces', 'fold' : 0, 'stl' : 1}, {'short' : 'f', 'long' : 'functions',  'fold' : 0, 'stl' : 1} ]
    1              0.000012     let types.slang = type_slang
                                " SML {{{1
    1   0.000168   0.000026     let type_sml = tagbar#prototypes#typeinfo#new()
    1              0.000006     let type_sml.ctagstype = 'sml'
    1              0.000160     let type_sml.kinds     = [ {'short' : 'e', 'long' : 'exception declarations', 'fold' : 0, 'stl' : 0}, {'short' : 'f', 'long' : 'function definitions',   'fold' : 0, 'stl' : 1}, {'short' : 'c', 'long' : 'functor definitions',    'fold' : 0, 'stl' : 1}, {'short' : 's', 'long' : 'signature declarations', 'fold' : 0, 'stl' : 0}, {'short' : 'r', 'long' : 'structure declarations', 'fold' : 0, 'stl' : 0}, {'short' : 't', 'long' : 'type definitions',       'fold' : 0, 'stl' : 1}, {'short' : 'v', 'long' : 'value bindings',         'fold' : 0, 'stl' : 0} ]
    1              0.000009     let types.sml = type_sml
                                " SQL {{{1
                                " The SQL ctags parser seems to be buggy for me, so this just uses the
                                " normal kinds even though scopes should be available. Improvements
                                " welcome!
    1   0.000167   0.000026     let type_sql = tagbar#prototypes#typeinfo#new()
    1              0.000006     let type_sql.ctagstype = 'sql'
    1              0.000936     let type_sql.kinds     = [ {'short' : 'P', 'long' : 'packages',               'fold' : 1, 'stl' : 1}, {'short' : 'd', 'long' : 'prototypes',             'fold' : 0, 'stl' : 1}, {'short' : 'c', 'long' : 'cursors',                'fold' : 0, 'stl' : 1}, {'short' : 'f', 'long' : 'functions',              'fold' : 0, 'stl' : 1}, {'short' : 'F', 'long' : 'record fields',          'fold' : 0, 'stl' : 1}, {'short' : 'L', 'long' : 'block label',            'fold' : 0, 'stl' : 1}, {'short' : 'p', 'long' : 'procedures',             'fold' : 0, 'stl' : 1}, {'short' : 's', 'long' : 'subtypes',               'fold' : 0, 'stl' : 1}, {'short' : 't', 'long' : 'tables',                 'fold' : 0, 'stl' : 1}, {'short' : 'T', 'long' : 'triggers',               'fold' : 0, 'stl' : 1}, {'short' : 'v', 'long' : 'variables',              'fold' : 0, 'stl' : 1}, {'short' : 'i', 'long' : 'indexes',                'fold' : 0, 'stl' : 1}, {'short' : 'e', 'long' : 'events',                 'fold' : 0, 'stl' : 1}, {'short' : 'U', 'long' : 'publications',           'fold' : 0, 'stl' : 1}, {'short' : 'R', 'long' : 'services',               'fold' : 0, 'stl' : 1}, {'short' : 'D', 'long' : 'domains',                'fold' : 0, 'stl' : 1}, {'short' : 'V', 'long' : 'views',                  'fold' : 0, 'stl' : 1}, {'short' : 'n', 'long' : 'synonyms',               'fold' : 0, 'stl' : 1}, {'short' : 'x', 'long' : 'MobiLink Table Scripts', 'fold' : 0, 'stl' : 1}, {'short' : 'y', 'long' : 'MobiLink Conn Scripts',  'fold' : 0, 'stl' : 1}, {'short' : 'z', 'long' : 'MobiLink Properties',    'fold' : 0, 'stl' : 1} ]
    1              0.000011     let types.sql = type_sql
                                " Tcl {{{1
    1   0.000192   0.000032     let type_tcl = tagbar#prototypes#typeinfo#new()
    1              0.000006     let type_tcl.ctagstype = 'tcl'
    1              0.000093     let type_tcl.kinds     = [ {'short' : 'c', 'long' : 'classes',    'fold' : 0, 'stl' : 1}, {'short' : 'm', 'long' : 'methods',    'fold' : 0, 'stl' : 1}, {'short' : 'p', 'long' : 'procedures', 'fold' : 0, 'stl' : 1} ]
    1              0.000009     let types.tcl = type_tcl
                                " LaTeX {{{1
    1   0.000202   0.000045     let type_tex = tagbar#prototypes#typeinfo#new()
    1              0.000006     let type_tex.ctagstype = 'tex'
    1              0.000204     let type_tex.kinds     = [ {'short' : 'i', 'long' : 'includes',       'fold' : 1, 'stl' : 0}, {'short' : 'p', 'long' : 'parts',          'fold' : 0, 'stl' : 1}, {'short' : 'c', 'long' : 'chapters',       'fold' : 0, 'stl' : 1}, {'short' : 's', 'long' : 'sections',       'fold' : 0, 'stl' : 1}, {'short' : 'u', 'long' : 'subsections',    'fold' : 0, 'stl' : 1}, {'short' : 'b', 'long' : 'subsubsections', 'fold' : 0, 'stl' : 1}, {'short' : 'P', 'long' : 'paragraphs',     'fold' : 0, 'stl' : 0}, {'short' : 'G', 'long' : 'subparagraphs',  'fold' : 0, 'stl' : 0}, {'short' : 'l', 'long' : 'labels',         'fold' : 0, 'stl' : 0} ]
    1              0.000005     let type_tex.sro        = '""'
    1              0.000028     let type_tex.kind2scope = { 'p' : 'part', 'c' : 'chapter', 's' : 'section', 'u' : 'subsection', 'b' : 'subsubsection' }
    1              0.000025     let type_tex.scope2kind = { 'part'          : 'p', 'chapter'       : 'c', 'section'       : 's', 'subsection'    : 'u', 'subsubsection' : 'b' }
    1              0.000005     let type_tex.sort = 0
    1              0.000009     let types.tex = type_tex
                                " Vala {{{1
                                " Vala is supported by the ctags fork provided by Anjuta, so only add the
                                " type if the fork is used to prevent error messages otherwise
    1              0.055558     if has_key(a:supported_types, 'vala') || executable('anjuta-tags')
                                    let type_vala = tagbar#prototypes#typeinfo#new()
                                    let type_vala.ctagstype = 'vala'
                                    let type_vala.kinds     = [ {'short' : 'e', 'long' : 'Enumerations',       'fold' : 0, 'stl' : 1}, {'short' : 'v', 'long' : 'Enumeration values', 'fold' : 0, 'stl' : 0}, {'short' : 's', 'long' : 'Structures',         'fold' : 0, 'stl' : 1}, {'short' : 'i', 'long' : 'Interfaces',         'fold' : 0, 'stl' : 1}, {'short' : 'd', 'long' : 'Delegates',          'fold' : 0, 'stl' : 1}, {'short' : 'c', 'long' : 'Classes',            'fold' : 0, 'stl' : 1}, {'short' : 'p', 'long' : 'Properties',         'fold' : 0, 'stl' : 0}, {'short' : 'f', 'long' : 'Fields',             'fold' : 0, 'stl' : 0}, {'short' : 'm', 'long' : 'Methods',            'fold' : 0, 'stl' : 1}, {'short' : 'E', 'long' : 'Error domains',      'fold' : 0, 'stl' : 1}, {'short' : 'r', 'long' : 'Error codes',        'fold' : 0, 'stl' : 1}, {'short' : 'S', 'long' : 'Signals',            'fold' : 0, 'stl' : 1} ]
                                    let type_vala.sro = '.'
                                    " 'enum' doesn't seem to be used as a scope, but it can't hurt to have
                                    " it here
                                    let type_vala.kind2scope = { 's' : 'struct', 'i' : 'interface', 'c' : 'class', 'e' : 'enum' }
                                    let type_vala.scope2kind = { 'struct'    : 's', 'interface' : 'i', 'class'     : 'c', 'enum'      : 'e' }
                                    let types.vala = type_vala
    1              0.000003     endif
    1              0.054949     if !has_key(a:supported_types, 'vala') && executable('anjuta-tags')
                                    let types.vala.ctagsbin = 'anjuta-tags'
    1              0.000004     endif
                                " Vera {{{1
                                " Why are variables 'virtual'?
    1   0.000263   0.000060     let type_vera = tagbar#prototypes#typeinfo#new()
    1              0.000007     let type_vera.ctagstype = 'vera'
    1              0.000271     let type_vera.kinds     = [ {'short' : 'd', 'long' : 'macros',      'fold' : 1, 'stl' : 0}, {'short' : 'g', 'long' : 'enums',       'fold' : 0, 'stl' : 1}, {'short' : 'T', 'long' : 'typedefs',    'fold' : 0, 'stl' : 0}, {'short' : 'c', 'long' : 'classes',     'fold' : 0, 'stl' : 1}, {'short' : 'e', 'long' : 'enumerators', 'fold' : 0, 'stl' : 0}, {'short' : 'm', 'long' : 'members',     'fold' : 0, 'stl' : 1}, {'short' : 'f', 'long' : 'functions',   'fold' : 0, 'stl' : 1}, {'short' : 't', 'long' : 'tasks',       'fold' : 0, 'stl' : 1}, {'short' : 'v', 'long' : 'variables',   'fold' : 0, 'stl' : 0}, {'short' : 'p', 'long' : 'programs',    'fold' : 0, 'stl' : 1} ]
    1              0.000008     let type_vera.sro        = '.' " Nesting doesn't seem to be possible
    1              0.000014     let type_vera.kind2scope = { 'g' : 'enum', 'c' : 'class', 'v' : 'virtual' }
    1              0.000015     let type_vera.scope2kind = { 'enum'      : 'g', 'class'     : 'c', 'virtual'   : 'v' }
    1              0.000012     let types.vera = type_vera
                                " Verilog {{{1
    1   0.000190   0.000035     let type_verilog = tagbar#prototypes#typeinfo#new()
    1              0.000007     let type_verilog.ctagstype = 'verilog'
    1              0.000229     let type_verilog.kinds     = [ {'short' : 'c', 'long' : 'constants',           'fold' : 0, 'stl' : 0}, {'short' : 'e', 'long' : 'events',              'fold' : 0, 'stl' : 1}, {'short' : 'f', 'long' : 'functions',           'fold' : 0, 'stl' : 1}, {'short' : 'm', 'long' : 'modules',             'fold' : 0, 'stl' : 1}, {'short' : 'n', 'long' : 'net data types',      'fold' : 0, 'stl' : 1}, {'short' : 'p', 'long' : 'ports',               'fold' : 0, 'stl' : 1}, {'short' : 'r', 'long' : 'register data types', 'fold' : 0, 'stl' : 1}, {'short' : 't', 'long' : 'tasks',               'fold' : 0, 'stl' : 1} ]
    1              0.000013     let types.verilog = type_verilog
                                " VHDL {{{1
                                " The VHDL ctags parser unfortunately doesn't generate proper scopes
    1   0.000198   0.000047     let type_vhdl = tagbar#prototypes#typeinfo#new()
    1              0.000006     let type_vhdl.ctagstype = 'vhdl'
    1              0.000155     let type_vhdl.kinds     = [ {'short' : 'P', 'long' : 'packages',   'fold' : 1, 'stl' : 0}, {'short' : 'c', 'long' : 'constants',  'fold' : 0, 'stl' : 0}, {'short' : 't', 'long' : 'types',      'fold' : 0, 'stl' : 1}, {'short' : 'T', 'long' : 'subtypes',   'fold' : 0, 'stl' : 1}, {'short' : 'r', 'long' : 'records',    'fold' : 0, 'stl' : 1}, {'short' : 'e', 'long' : 'entities',   'fold' : 0, 'stl' : 1}, {'short' : 'f', 'long' : 'functions',  'fold' : 0, 'stl' : 1}, {'short' : 'p', 'long' : 'procedures', 'fold' : 0, 'stl' : 1} ]
    1              0.000009     let types.vhdl = type_vhdl
                                " Vim {{{1
    1   0.000286   0.000041     let type_vim = tagbar#prototypes#typeinfo#new()
    1              0.000006     let type_vim.ctagstype = 'vim'
    1              0.000110     let type_vim.kinds     = [ {'short' : 'n', 'long' : 'vimball filenames',  'fold' : 0, 'stl' : 1}, {'short' : 'v', 'long' : 'variables',          'fold' : 1, 'stl' : 0}, {'short' : 'f', 'long' : 'functions',          'fold' : 0, 'stl' : 1}, {'short' : 'a', 'long' : 'autocommand groups', 'fold' : 1, 'stl' : 1}, {'short' : 'c', 'long' : 'commands',           'fold' : 0, 'stl' : 0}, {'short' : 'm', 'long' : 'maps',               'fold' : 1, 'stl' : 0} ]
    1              0.000006     let types.vim = type_vim
                                " YACC {{{1
    1   0.000221   0.000067     let type_yacc = tagbar#prototypes#typeinfo#new()
    1              0.000006     let type_yacc.ctagstype = 'yacc'
    1              0.000017     let type_yacc.kinds     = [ {'short' : 'l', 'long' : 'labels', 'fold' : 0, 'stl' : 1} ]
    1              0.000006     let types.yacc = type_yacc
                                " }}}1
                            
   56              0.000361     for [type, typeinfo] in items(types)
   55              0.000267         let typeinfo.ftype = type
   56              0.000085     endfor
                            
   56              0.000225     for typeinfo in values(types)
   55   0.007135   0.001172         call typeinfo.createKinddict()
   56              0.000088     endfor
                            
    1              0.000005     return types

FUNCTION  <SNR>9_get_shiftwidth()
    Defined: ~\AppData\Local\nvim-data\plugged\vim-polyglot\autoload\polyglot\init.vim:2749
Called 46 times
Total time:   0.054056
 Self time:   0.054056

count  total (s)   self (s)
   46              0.000360     let shiftwidth = 0
   46              0.000223     let max_count = 0
   46              0.000395     let final_counts = {}
  276              0.002649     for [indent, indent_count] in items(a:indents)
  230              0.002536       let indent_count = indent_count * 1.5
 1380              0.010931       for [indent2, indent2_count] in items(a:indents)
 1150              0.009303         if indent2 > indent && indent2 % indent == 0
  230              0.001767           let indent_count = indent_count + indent2_count
 1150              0.001844         endif
 1380              0.002469       endfor
  230              0.002210       let final_counts[indent] = indent_count
  276              0.000583     endfor
  276              0.002256     for [indent, final_count] in items(final_counts)
  230              0.001149       if final_count > max_count
   71              0.000428         let shiftwidth = indent
   71              0.000406         let max_count = final_count
  230              0.000372       endif
  276              0.000511     endfor
   46              0.000267     return shiftwidth

FUNCTION  neoterm#target#get()
    Defined: ~\AppData\Local\nvim-data\plugged\neoterm\autoload\neoterm\target.vim:3
Called 6 times
Total time:   0.002922
 Self time:   0.000685

count  total (s)   self (s)
    6   0.001897   0.000399   let l:instance = s:get(a:opts)
                            
    6   0.000989   0.000250   return s:set_instance_opts(l:instance, a:opts)

FUNCTION  <SNR>138_ShrinkIfExpanded()
    Defined: ~\AppData\Local\nvim-data\plugged\tagbar\autoload\tagbar.vim:1135
Called 17 times
Total time:   0.000414
 Self time:   0.000414

count  total (s)   self (s)
   17              0.000251     if !s:window_expanded || &filetype ==# 'tagbar' || s:expand_bufnr == -1
   17              0.000072         return
                                endif
                            
                                let tablist = []
                                for i in range(tabpagenr('$'))
                                    call extend(tablist, tabpagebuflist(i + 1))
                                endfor
                            
                                if index(tablist, s:expand_bufnr) == -1
                                    let &columns -= g:tagbar_width + 1
                                    let s:window_expanded = 0
                                    let s:expand_bufnr = -1
                                    " Only restore window position if it is available and if the
                                    " window hasn't been moved manually after the expanding
                                    if getwinposx() != -1 && getwinposx() == s:window_pos.post.x && getwinposy() == s:window_pos.post.y
                                       execute 'winpos ' . s:window_pos.pre.x . ' ' . s:window_pos.pre.y
                                    endif
                                endif
                            
                                " The window sizes may have changed due to the shrinking happening after
                                " the window closing, so equalize them again.
                                if &equalalways
                                    wincmd =
                                endif

FUNCTION  <SNR>146_compare_by_line()
    Defined: ~\AppData\Local\nvim-data\plugged\tagbar\autoload\tagbar\sorting.vim:59
Called 2335 times
Total time:   0.017227
 Self time:   0.017227

count  total (s)   self (s)
 2335              0.014334     return a:tag1.fields.line - a:tag2.fields.line

FUNCTION  <SNR>145_getPrototype()
    Defined: ~\AppData\Local\nvim-data\plugged\tagbar\autoload\tagbar\prototypes\kindheadertag.vim:21
Called 1 time
Total time:   0.000023
 Self time:   0.000023

count  total (s)   self (s)
    1              0.000021     return self.name . ': ' . self.numtags . ' ' . (self.numtags > 1 ? 'tags' : 'tag')

FUNCTION  <SNR>122_indent_like_opening_paren()
    Defined: ~\AppData\Local\nvim-data\plugged\vim-polyglot\indent\python.vim:210
Called 1 time
Total time:   0.069072
 Self time:   0.000063

count  total (s)   self (s)
    1   0.069056   0.000047     let [paren_lnum, paren_col] = s:find_opening_paren(a:lnum, 1)
    1              0.000006     if paren_lnum <= 0
    1              0.000004         return -2
                                endif
                                let text = getline(paren_lnum)
                                let base = indent(paren_lnum)
                            
                                let nothing_after_opening_paren = s:match_expr_on_line( s:skip_after_opening_paren, paren_lnum, paren_col+1)
                                let starts_with_closing_paren = getline(a:lnum) =~# '^\s*[])}]'
                            
                                let hang_closing = get(b:, 'python_pep8_indent_hang_closing', get(g:, 'python_pep8_indent_hang_closing', 0))
                            
                                if nothing_after_opening_paren
                                    if starts_with_closing_paren && !hang_closing
                                        let res = base
                                    else
                                        let res = base + s:sw()
                            
                                        " Special case for parenthesis.
                                        if text[paren_col-1] ==# '(' && getline(a:lnum) !~# '\v\)\s*:?\s*$'
                                            return res
                                        endif
                                    endif
                                else
                                    " Indent to match position of opening paren.
                                    let res = paren_col
                                endif
                            
                                " If this line is the continuation of a control statement
                                " indent further to distinguish the continuation line
                                " from the next logical line.
                                if text =~# b:control_statement && res == base + s:sw()
                                    " But only if not inside parens itself (Flake's E127).
                                    let [paren_lnum, _] = s:find_opening_paren(paren_lnum, 1)
                                    if paren_lnum <= 0
                                        return res + s:sw()
                                    endif
                                endif
                                return res

FUNCTION  <SNR>141_add_snr()
    Defined: ~\AppData\Local\nvim-data\plugged\tagbar\autoload\tagbar\prototypes\typeinfo.vim:35
Called 92 times
Total time:   0.002828
 Self time:   0.002828

count  total (s)   self (s)
   92              0.000752     if !exists('s:snr')
    1              0.000090         let s:snr = matchstr(expand('<sfile>'), '<SNR>\d\+_\zeget_snr$')
   92              0.000160     endif
   92              0.000598     return s:snr . a:funcname

FUNCTION  <SNR>138_ExecuteCtags()
    Defined: ~\AppData\Local\nvim-data\plugged\tagbar\autoload\tagbar.vim:3120
Called 29 times
Total time:   5.350040
 Self time:   0.039596

count  total (s)   self (s)
   29   0.001960   0.001075     call tagbar#debug#log('Executing ctags command: ' . a:ctags_cmd)
                            
   29              0.000813     if &shell =~# 'fish$'
                                    " Reset shell since fish isn't really compatible
                                    let shell_save = &shell
                                    set shell=sh
   29              0.000052     endif
                            
   29              0.000528     if &shell =~# 'elvish'
                                    " Reset shell since Elvish isn't really compatible
                                    let shell_save = &shell
                                    set shell=sh
   29              0.000043     endif
                            
   29              0.000312     if exists('+shellslash')
   29              0.000291         let shellslash_save = &shellslash
   29   0.010673   0.010653         set noshellslash
   29              0.000103     endif
                            
   29              0.000692     if &shell =~? 'cmd\.exe'
   29              0.000341         let shellxquote_save = &shellxquote
   29   0.000566   0.000559         set shellxquote=\"
   29              0.000285         let shellcmdflag_save = &shellcmdflag
   29   0.000342   0.000332         set shellcmdflag=/s\ /c
   29              0.000053     endif
                            
   29   0.001371   0.001067     if tagbar#debug#enabled()
                                    silent 5verbose let ctags_output = system(a:ctags_cmd)
                                    call tagbar#debug#log(v:statusmsg)
                                    call tagbar#debug#log('Exit code: ' . v:shell_error)
                                    redraw!
   29              0.000069     else
   29              0.000511         let py_version = get(g:, 'tagbar_python', 1)
   29   5.310677   0.001534         silent let ctags_output = s:run_system(a:ctags_cmd, py_version)
   29              0.000125     endif
                            
   29              0.001349     if &shell =~? 'cmd\.exe'
   29   0.000962   0.000937         let &shellxquote  = shellxquote_save
   29   0.000517   0.000489         let &shellcmdflag = shellcmdflag_save
   29              0.000079     endif
                            
   29              0.000479     if exists('+shellslash')
   29   0.012338   0.012318         let &shellslash = shellslash_save
   29              0.000134     endif
                            
   29              0.000467     if exists('shell_save')
                                    let &shell = shell_save
   29              0.000112     endif
                            
   29              0.000484     return ctags_output

FUNCTION  <SNR>69_Remove_Matches()
    Defined: ~\scoop\apps\neovim\0.6.1\share\nvim\runtime\plugin\matchparen.vim:197
Called 1393 times
Total time:   0.087475
 Self time:   0.087475

count  total (s)   self (s)
 1393              0.033593   if exists('w:paren_hl_on') && w:paren_hl_on
  177              0.017876     silent! call matchdelete(3)
  177              0.001855     let w:paren_hl_on = 0
 1393              0.004502   endif

FUNCTION  <SNR>138_run_system()
    Defined: ~\AppData\Local\nvim-data\plugged\tagbar\autoload\tagbar.vim:3083
Called 29 times
Total time:   5.309144
 Self time:   0.009229

count  total (s)   self (s)
   29              0.002238     if has('win32') && !has('nvim') && a:version > 0 && (has('python3') || has('python2'))
                                    if a:version == 3 && has('python3')
                                        let pyx = 'py3 '
                                        let python_eval = 'py3eval'
                                    elseif a:version == 2 && has('python2')
                                        let pyx = 'py2 '
                                        let python_eval = 'pyeval'
                                    else
                                        let pyx = 'pyx '
                                        let python_eval = 'pyxeval'
                                    endif
                                    let l:pc = 0
                                    exec pyx . 'import subprocess, vim'
                                    exec pyx . '__argv = {"args":vim.eval("a:cmd"), "shell":True}'
                                    exec pyx . '__argv["stdout"] = subprocess.PIPE'
                                    exec pyx . '__argv["stderr"] = subprocess.STDOUT'
                                    exec pyx . '__argv["errors"] = "ignore"'
                                    exec pyx . '__pp = subprocess.Popen(**__argv, universal_newlines=True, encoding="utf8")'
                                    exec pyx . '__return_text = __pp.stdout.read()'
                                    exec pyx . '__pp.stdout.close()'
                                    exec pyx . '__return_code = __pp.wait()'
                                    exec 'let l:hr = '. python_eval .'("__return_text")'
                                    exec 'let l:pc = '. python_eval .'("__return_code")'
                                    let s:shell_error = l:pc
                                    return l:hr
   29              0.000069     endif
   29   5.301716   0.001801     let hr = system(a:cmd)
   29              0.000788     let s:shell_error = v:shell_error
   29              0.000532     return hr

FUNCTION  neoterm#term#new()
    Defined: ~\AppData\Local\nvim-data\plugged\neoterm\autoload\neoterm\term.vim:1
Called 1 time
Total time:   0.010774
 Self time:   0.002628

count  total (s)   self (s)
    1   0.010770   0.002624   return extend(   extend(copy(s:term), copy(s:adapter()), 'error'),   neoterm#default#opts(a:opts) )

FUNCTION  neoterm#origin#return()
    Defined: ~\AppData\Local\nvim-data\plugged\neoterm\autoload\neoterm\origin.vim:8
Called 1 time
Total time:   0.000092
 Self time:   0.000092

count  total (s)   self (s)
    1              0.000024   if get(a:, 1, '') ==# 'buffer'
                                exec printf('buffer %s', a:origin.last_buffer_id)
    1              0.000015   elseif a:origin.win_id
    1              0.000017     call win_gotoid(a:origin.win_id)
                              else
                                wincmd p
    1              0.000003   end

FUNCTION  <SNR>144_getChildren()
    Defined: ~\AppData\Local\nvim-data\plugged\tagbar\autoload\tagbar\prototypes\basetag.vim:216
Called 544 times
Total time:   0.003233
 Self time:   0.003233

count  total (s)   self (s)
  544              0.002467     return self._childlist

FUNCTION  <SNR>138_LoadUserTypeDefs()
    Defined: ~\AppData\Local\nvim-data\plugged\tagbar\autoload\tagbar.vim:380
Called 1 time
Total time:   0.008713
 Self time:   0.000385

count  total (s)   self (s)
    1              0.000007     if a:0 > 0
                                    let type = a:1
                            
                                    let defdict = {}
                                    let defdict[type] = g:tagbar_type_{type}
    1              0.000002     else
    1   0.007432   0.000035         let defdict = tagbar#getusertypes()
    1              0.000003     endif
                            
    1              0.000006     let transformed = {}
    2              0.000019     for [type, def] in items(defdict)
    1   0.000541   0.000059         let transformed[type] = s:TransformUserTypeDef(def)
    1              0.000010         let transformed[type].ftype = type
    2              0.000004     endfor
                            
    2              0.000019     for [key, value] in items(transformed)
    1   0.000063   0.000032         call tagbar#debug#log("Initializing user type '" . key . "'")
    1              0.000015         if !has_key(s:known_types, key) || get(value, 'replace', 0)
    1   0.000348   0.000034             let s:known_types[key] = tagbar#prototypes#typeinfo#new(value)
                                    else
                                        call extend(s:known_types[key], value)
    1              0.000002         endif
    1   0.000131   0.000026         call s:known_types[key].createKinddict()
    2              0.000005     endfor

FUNCTION  <SNR>144_initFoldState()
    Defined: ~\AppData\Local\nvim-data\plugged\tagbar\autoload\tagbar\prototypes\basetag.vim:111
Called 394 times
Total time:   0.057089
 Self time:   0.050805

count  total (s)   self (s)
  394              0.003356     let fileinfo = self.fileinfo
                            
  394   0.026539   0.020255     if a:known_files.has(fileinfo.fpath) && has_key(fileinfo, '_tagfolds_old') && has_key(fileinfo._tagfolds_old[self.fields.kind], self.fullpath)
                                    " The file has been updated and the tag was there before, so copy its
                                    " old fold state
  330              0.008984         let fileinfo.tagfolds[self.fields.kind][self.fullpath] = fileinfo._tagfolds_old[self.fields.kind][self.fullpath]
   64              0.000464     elseif self.depth >= fileinfo.foldlevel
                                    let fileinfo.tagfolds[self.fields.kind][self.fullpath] = 1
   64              0.000123     else
   64              0.001301         let fileinfo.tagfolds[self.fields.kind][self.fullpath] = fileinfo.kindfolds[self.fields.kind]
  394              0.000696     endif

FUNCTION  190()
    Defined: ~\AppData\Local\nvim-data\plugged\nerdtree\lib\nerdtree\creator.vim:37
Called 631 times
Total time:   0.006201
 Self time:   0.006201

count  total (s)   self (s)
  631              0.004358     return 'NERD_tree_'

FUNCTION  <SNR>122_find_start_of_multiline_statement()
    Defined: ~\AppData\Local\nvim-data\plugged\vim-polyglot\indent\python.vim:140
Called 1 time
Total time:   0.067332
 Self time:   0.000102

count  total (s)   self (s)
    1              0.000006     let lnum = a:lnum
    1              0.000005     while lnum > 0
    1              0.000019         if getline(lnum - 1) =~# '\\$'
                                        let lnum = prevnonblank(lnum - 1)
    1              0.000003         else
    1   0.067272   0.000042             let [paren_lnum, _] = s:find_opening_paren(lnum, 1)
    1              0.000006             if paren_lnum < 1
    1              0.000004                 return lnum
                                        else
                                            let lnum = paren_lnum
                                        endif
                                    endif
                                endwhile

FUNCTION  AutoPairsInit()
    Defined: ~\AppData\Local\nvim-data\plugged\auto-pairs\plugin\auto-pairs.vim:471
Called 7 times
Total time:   0.044035
 Self time:   0.030217

count  total (s)   self (s)
    7              0.000065   let b:autopairs_loaded  = 1
    7              0.000078   if !exists('b:autopairs_enabled')
    7              0.000053     let b:autopairs_enabled = 1
    7              0.000012   end
                            
    7              0.000055   if !exists('b:AutoPairs')
    7   0.001954   0.000250     let b:AutoPairs = AutoPairsDefaultPairs()
    7              0.000013   end
                            
    7              0.000077   if !exists('b:AutoPairsMoveCharacter')
    7              0.000079     let b:AutoPairsMoveCharacter = g:AutoPairsMoveCharacter
    7              0.000012   end
                            
    7              0.000059   let b:autopairs_return_pos = 0
    7              0.000066   let b:autopairs_saved_pair = [0, 0]
    7              0.000043   let b:AutoPairsList = []
                            
                              " buffer level map pairs keys
                              " n - do not map the first charactor of closed pair to close key
                              " m - close key jumps through multi line
                              " s - close key jumps only in the same line
   71              0.000651   for [open, close] in items(b:AutoPairs)
   64              0.000512     let o = open[-1:-1]
   64              0.000371     let c = close[0]
   64              0.000849     let opt = {'mapclose': 1, 'multiline':1}
   64              0.000423     let opt['key'] = c
   64              0.000299     if o == c
   42              0.000275       let opt['multiline'] = 0
   64              0.000122     end
   64              0.001781     let m = matchlist(close, '\v(.*)//(.*)$')
   64              0.000461     if len(m) > 0 
                                  if m[2] =~ 'n'
                                    let opt['mapclose'] = 0
                                  end
                                  if m[2] =~ 'm'
                                    let opt['multiline'] = 1
                                  end
                                  if m[2] =~ 's'
                                    let opt['multiline'] = 0
                                  end
                                  let ks = matchlist(m[2], '\vk(.)')
                                  if len(ks) > 0
                                    let opt['key'] = ks[1]
                                    let c = opt['key']
                                  end
                                  let close = m[1]
   64              0.000098     end
   64   0.008955   0.001603     call AutoPairsMap(o)
   64              0.000686     if o != c && c != '' && opt['mapclose']
   21   0.002523   0.000408       call AutoPairsMap(c)
   64              0.000119     end
   64              0.000991     let b:AutoPairsList += [[open, close, opt]]
   71              0.000219   endfor
                            
                              " sort pairs by length, longer pair should have higher priority
    7   0.005668   0.003021   let b:AutoPairsList = sort(b:AutoPairsList, "s:sortByLength")
                            
   71              0.000242   for item in b:AutoPairsList
   64              0.000442     let [open, close, opt] = item
   64              0.000382     if open == "'" && open == close
    7              0.000049       let item[0] = '\v(^|\W)\zs'''
   64              0.000092     end
   71              0.000127   endfor
                            
                            
   63              0.000624   for key in split(b:AutoPairsMoveCharacter, '\s*')
   56              0.000951     let escaped_key = substitute(key, "'", "''", 'g')
   56              0.004335     execute 'inoremap <silent> <buffer> <M-'.key."> <C-R>=AutoPairsMoveCharacter('".escaped_key."')<CR>"
   63              0.000141   endfor
                            
                              " Still use <buffer> level mapping for <BS> <SPACE>
    7              0.000040   if g:AutoPairsMapBS
                                " Use <C-R> instead of <expr> for issue #14 sometimes press BS output strange words
    7              0.000352     execute 'inoremap <buffer> <silent> <BS> <C-R>=AutoPairsDelete()<CR>'
    7              0.000014   end
                            
    7              0.000028   if g:AutoPairsMapCh
    7              0.000369     execute 'inoremap <buffer> <silent> <C-h> <C-R>=AutoPairsDelete()<CR>'
    7              0.000015   endif
                            
    7              0.000034   if g:AutoPairsMapSpace
                                " Try to respect abbreviations on a <SPACE>
    7              0.000043     let do_abbrev = ""
    7              0.000096     if v:version == 703 && has("patch489") || v:version > 703
    7              0.000048       let do_abbrev = "<C-]>"
    7              0.000012     endif
    7              0.000411     execute 'inoremap <buffer> <silent> <SPACE> '.do_abbrev.'<C-R>=AutoPairsSpace()<CR>'
    7              0.000012   end
                            
    7              0.000058   if g:AutoPairsShortcutFastWrap != ''
                                execute 'inoremap <buffer> <silent> '.g:AutoPairsShortcutFastWrap.' <C-R>=AutoPairsFastWrap()<CR>'
    7              0.000013   end
                            
    7              0.000048   if g:AutoPairsShortcutBackInsert != ''
                                execute 'inoremap <buffer> <silent> '.g:AutoPairsShortcutBackInsert.' <C-R>=AutoPairsBackInsert()<CR>'
    7              0.000012   end
                            
    7              0.000040   if g:AutoPairsShortcutToggle != ''
                                " use <expr> to ensure showing the status when toggle
    7              0.000332     execute 'inoremap <buffer> <silent> <expr> '.g:AutoPairsShortcutToggle.' AutoPairsToggle()'
    7              0.000425     execute 'noremap <buffer> <silent> '.g:AutoPairsShortcutToggle.' :call AutoPairsToggle()<CR>'
    7              0.000012   end
                            
    7              0.000042   if g:AutoPairsShortcutJump != ''
    7              0.000420     execute 'inoremap <buffer> <silent> ' . g:AutoPairsShortcutJump. ' <ESC>:call AutoPairsJump()<CR>a'
    7              0.000382     execute 'noremap <buffer> <silent> ' . g:AutoPairsShortcutJump. ' :call AutoPairsJump()<CR>'
    7              0.000010   end
                            
    7              0.000052   if &keymap != ''
                                let l:imsearch = &imsearch
                                let l:iminsert = &iminsert
                                let l:imdisable = &imdisable
                                execute 'setlocal keymap=' . &keymap
                                execute 'setlocal imsearch=' . l:imsearch
                                execute 'setlocal iminsert=' . l:iminsert
                                if l:imdisable
                                  execute 'setlocal imdisable'
                                else
                                  execute 'setlocal noimdisable'
                                end
    7              0.000010   end
                            

FUNCTION  <SNR>165_create_window()
    Defined: ~\AppData\Local\nvim-data\plugged\neoterm\autoload\neoterm.vim:262
Called 1 time
Total time:   0.027298
 Self time:   0.002887

count  total (s)   self (s)
    1              0.000010   let l:instance = a:instance
                            
    1              0.000012   if empty(l:instance.mod)
    1              0.000013     let l:instance.mod = g:neoterm_default_mod
    1              0.000005   end
                            
    1              0.000014   if exists('*g:neoterm_callbacks.before_create_window')
                                call g:neoterm_callbacks.before_create_window(l:instance)
    1              0.000003   end
                            
    1   0.003291   0.002252   let l:instance.size = neoterm#args#size(get(l:instance, 'args', ''), g:neoterm_size)
                            
    1              0.000010   if l:instance.mod !=# ''
                                let l:hidden=&hidden
                                let &hidden=0
                            
                                let l:cmd = printf('%s %snew', l:instance.mod, l:instance.size)
                                if l:instance.buffer_id > 0
                                  let l:cmd .= printf(' +buffer%s', l:instance.buffer_id)
                                end
                            
                                exec l:cmd
                            
                                let &hidden=l:hidden
    1              0.000021   elseif get(l:instance, 'buffer_id', 0) > 0 && bufnr('') != l:instance.buffer_id
                                exec printf('buffer %s', l:instance.buffer_id)
    1              0.000002   else
    1   0.023808   0.000437     enew
    1              0.000003   end

FUNCTION  AutoPairsReturn()
    Defined: ~\AppData\Local\nvim-data\plugged\auto-pairs\plugin\auto-pairs.vim:384
Called 14 times
Total time:   0.018344
 Self time:   0.015649

count  total (s)   self (s)
   14              0.000171   if b:autopairs_enabled == 0
                                return ''
   14              0.000034   end
   14              0.000157   let b:autopairs_return_pos = 0
   14              0.000255   let before = getline(line('.')-1)
   14   0.003285   0.000590   let [ig, ig, afterline] = s:getline()
   14              0.000072   let cmd = ''
  140              0.001137   for [open, close, opt] in b:AutoPairsList
  126              0.000608     if close == ''
                                  continue
  126              0.000183     end
                            
  126              0.003084     if before =~ '\V'.open.'\v\s*$' && afterline =~ '^\s*\V'.close
                                  let b:autopairs_return_pos = line('.')
                                  if g:AutoPairsCenterLine && winline() * 3 >= winheight(0) * 2
                                    " Recenter before adding new line to avoid replacing line content
                                    let cmd = "zz"
                                  end
                            
                                  " If equalprg has been set, then avoid call =
                                  " https://github.com/jiangmiao/auto-pairs/issues/24
                                  if &equalprg != ''
                                    return "\<ESC>".cmd."O"
                                  endif
                            
                                  " conflict with javascript and coffee
                                  " javascript   need   indent new line
                                  " coffeescript forbid indent new line
                                  if &filetype == 'coffeescript' || &filetype == 'coffee'
                                    return "\<ESC>".cmd."k==o"
                                  else
                                    return "\<ESC>".cmd."=ko"
                                  endif
  126              0.000192     end
  140              0.000336   endfor
   14              0.000056   return ''

FUNCTION  neoterm#args#size()
    Defined: ~\AppData\Local\nvim-data\plugged\neoterm\autoload\neoterm\args.vim:1
Called 1 time
Total time:   0.000096
 Self time:   0.000096

count  total (s)   self (s)
    1              0.000060   let l:size = str2nr(matchstr(a:args, 'resize=\zs\d\+'))
    1              0.000014   let l:size = l:size > 0 ? l:size : a:default
                            
    1              0.000014   return str2nr(l:size) == 0 ? '' : l:size

FUNCTION  <SNR>138_InitTypes()
    Defined: ~\AppData\Local\nvim-data\plugged\tagbar\autoload\tagbar.vim:232
Called 1 time
Total time:   0.557368
 Self time:   0.054584

count  total (s)   self (s)
    1   0.000048   0.000023     call tagbar#debug#log('Initializing types')
                            
    1   0.161158   0.000066     let supported_types = s:GetSupportedFiletypes()
                            
    1              0.000009     if s:ctags_is_uctags
                                    let s:known_types = tagbar#types#uctags#init(supported_types)
    1              0.000004     else
    1   0.222968   0.049854         let s:known_types = tagbar#types#ctags#init(supported_types)
    1              0.000002     endif
                            
                                " Use dart_ctags if available
    1   0.053834   0.000055     let dart_ctags = s:CheckFTCtags('dart_ctags', 'dart')
    1              0.000007     if dart_ctags !=# ''
                                    let supported_types['dart'] = 1
                                    call tagbar#debug#log('Detected dart_ctags, overriding typedef')
                                    let type_dart = tagbar#prototypes#typeinfo#new()
                                    let type_dart.ctagstype = 'dart'
                                    let type_dart.kinds = [ {'short' : 'l', 'long' : 'library',            'fold' : 0, 'stl' : 0}, {'short' : 't', 'long' : 'export',             'fold' : 0, 'stl' : 0}, {'short' : 'i', 'long' : 'imports',            'fold' : 1, 'stl' : 0}, {'short' : 'D', 'long' : 'dart',               'fold' : 0, 'stl' : 0}, {'short' : 'U', 'long' : 'pub',                'fold' : 0, 'stl' : 0}, {'short' : 'L', 'long' : 'local',              'fold' : 0, 'stl' : 0}, {'short' : 'P', 'long' : 'part',               'fold' : 0, 'stl' : 0}, {'short' : 'p', 'long' : 'part of',            'fold' : 0, 'stl' : 0}, {'short' : 'C', 'long' : 'consts',             'fold' : 0, 'stl' : 0}, {'short' : 'v', 'long' : 'variables',          'fold' : 0, 'stl' : 0}, {'short' : 'F', 'long' : 'functions',          'fold' : 0, 'stl' : 0}, {'short' : 'E', 'long' : 'enums',              'fold' : 0, 'stl' : 0}, {'short' : 'e', 'long' : 'constants',          'fold' : 0, 'stl' : 0}, {'short' : 'x', 'long' : 'mixins',             'fold' : 0, 'stl' : 0}, {'short' : 'c', 'long' : 'classes',            'fold' : 0, 'stl' : 0}, {'short' : 'd', 'long' : 'extends',            'fold' : 0, 'stl' : 0}, {'short' : 'w', 'long' : 'with',               'fold' : 0, 'stl' : 0}, {'short' : 'z', 'long' : 'implements',         'fold' : 0, 'stl' : 0}, {'short' : 'r', 'long' : 'constructors',       'fold' : 0, 'stl' : 0}, {'short' : 'a', 'long' : 'abstract functions', 'fold' : 0, 'stl' : 0}, {'short' : 'f', 'long' : 'fields',             'fold' : 0, 'stl' : 0}, {'short' : 'm', 'long' : 'methods',            'fold' : 0, 'stl' : 0}, {'short' : 'M', 'long' : 'static methods',     'fold' : 0, 'stl' : 0}, {'short' : 'g', 'long' : 'getters',            'fold' : 0, 'stl' : 0}, {'short' : 's', 'long' : 'setters',            'fold' : 0, 'stl' : 0}, {'short' : 'o', 'long' : 'operators',          'fold' : 0, 'stl' : 0}, ]
                                    let type_dart.sro        = ':'
                                    let type_dart.kind2scope = { 'c' : 'class', 'E' : 'enum', 'x' : 'mixin', 'i' : 'directive' }
                                    let type_dart.scope2kind = { 'class'  : 'c', 'enum'   : 'E', 'mixin'  : 'x', 'directive' : 'i' }
                                    let type_dart.ctagsbin   = dart_ctags
                                    let type_dart.ctagsargs  = '-l'
                                    let type_dart.ftype      = 'dart'
                                    call type_dart.createKinddict()
                                    let s:known_types.dart   = type_dart
    1              0.000002     endif
                            
                                " Use jsctags/doctorjs if available
    1   0.052803   0.000066     let jsctags = s:CheckFTCtags('jsctags', 'javascript')
    1              0.000007     if jsctags !=# ''
                                    call tagbar#debug#log('Detected jsctags, overriding typedef')
                                    let type_javascript = tagbar#prototypes#typeinfo#new()
                                    let type_javascript.ctagstype = 'javascript'
                                    let type_javascript.kinds = [ {'short' : 'v', 'long' : 'variables', 'fold' : 0, 'stl' : 0}, {'short' : 'f', 'long' : 'functions', 'fold' : 0, 'stl' : 1} ]
                                    let type_javascript.sro        = '.'
                                    let type_javascript.kind2scope = { 'v' : 'namespace', 'f' : 'namespace' }
                                    let type_javascript.scope2kind = { 'namespace' : 'f' }
                                    let type_javascript.ctagsbin   = jsctags
                                    let type_javascript.ctagsargs  = '-f -'
                                    let type_javascript.ftype = 'javascript'
                                    call type_javascript.createKinddict()
                                    let s:known_types.javascript = type_javascript
    1              0.000002     endif
                            
                                " Use gotags if available
    1   0.053385   0.000060     let gotags = s:CheckFTCtags('gotags', 'go')
    1              0.000007     if gotags !=# ''
                                    call tagbar#debug#log('Detected gotags, overriding typedef')
                                    let type_go = tagbar#prototypes#typeinfo#new()
                                    let type_go.ctagstype = 'go'
                                    let type_go.kinds = [ {'short' : 'p', 'long' : 'package',      'fold' : 0, 'stl' : 0}, {'short' : 'i', 'long' : 'imports',      'fold' : 1, 'stl' : 0}, {'short' : 'c', 'long' : 'constants',    'fold' : 0, 'stl' : 0}, {'short' : 'v', 'long' : 'variables',    'fold' : 0, 'stl' : 0}, {'short' : 't', 'long' : 'types',        'fold' : 0, 'stl' : 0}, {'short' : 'n', 'long' : 'intefaces',    'fold' : 0, 'stl' : 0}, {'short' : 'w', 'long' : 'fields',       'fold' : 0, 'stl' : 0}, {'short' : 'e', 'long' : 'embedded',     'fold' : 0, 'stl' : 0}, {'short' : 'm', 'long' : 'methods',      'fold' : 0, 'stl' : 0}, {'short' : 'r', 'long' : 'constructors', 'fold' : 0, 'stl' : 0}, {'short' : 'f', 'long' : 'functions',    'fold' : 0, 'stl' : 0}, ]
                                    let type_go.sro        = '.'
                                    let type_go.kind2scope = { 't' : 'ctype', 'n' : 'ntype' }
                                    let type_go.scope2kind = { 'ctype' : 't', 'ntype' : 'n' }
                                    let type_go.ctagsbin   = gotags
                                    let type_go.ctagsargs  = '-sort -silent'
                                    let type_go.ftype = 'go'
                                    call type_go.createKinddict()
                                    let s:known_types.go = type_go
    1              0.000002     endif
                            
    1   0.008775   0.000062     call s:LoadUserTypeDefs()
                            
                                " Add an 'unknown' kind to the types for pseudotags that we can't
                                " determine the correct kind for since they don't have any children that
                                " are not pseudotags and that therefore don't provide scope information
   57              0.000207     for typeinfo in values(s:known_types)
   56              0.000365         if has_key(typeinfo, 'kind2scope')
   23              0.000322             let unknown_kind = {'short' : '?', 'long' : 'unknown',  'fold' : 0, 'stl' : 1}
                                        " Check for existence first since some types exist under more than
                                        " one name
   23              0.000270             if index(typeinfo.kinds, unknown_kind) == -1
   17              0.000125                 call add(typeinfo.kinds, unknown_kind)
   23              0.000034             endif
   23              0.000154             let typeinfo.kind2scope['?'] = 'unknown'
   56              0.000087         endif
   57              0.000088     endfor
                            
    1              0.000006     let s:type_init_done = 1

FUNCTION  <SNR>74_GetAutocmdPrefix()
    Defined: ~\scoop\apps\neovim\0.6.1\share\nvim\runtime\autoload\remote\define.vim:228
Called 1 time
Total time:   0.000187
 Self time:   0.000187

count  total (s)   self (s)
    1              0.000015   if has_key(a:opts, 'group')
    1              0.000012     let group = a:opts.group
                              else
                                let group = s:GetNextAutocmdGroup()
    1              0.000003   endif
    1              0.000019   let rv = ['autocmd!', group, a:name]
                            
    1              0.000013   if has_key(a:opts, 'pattern')
    1              0.000018     call add(rv, a:opts.pattern)
                              else
                                call add(rv, '*')
    1              0.000003   endif
                            
    1              0.000017   if has_key(a:opts, 'nested') && a:opts.nested
                                call add(rv, 'nested')
    1              0.000004   endif
                            
    1              0.000025   return join(rv, ' ')

FUNCTION  neoterm#default#opts()
    Defined: ~\AppData\Local\nvim-data\plugged\neoterm\autoload\neoterm\default.vim:1
Called 1 time
Total time:   0.004176
 Self time:   0.003149

count  total (s)   self (s)
    1   0.003983   0.002956   let l:default_opts = { 'handlers': {}, 'mod': '', 'buffer_id': 0, 'from_session': v:false, 'origin': neoterm#origin#new(), 'size': g:neoterm_size, 'shell': g:neoterm_shell }
    1              0.000187   return extend(copy(a:opts), l:default_opts, 'keep')

FUNCTION  GetPythonPEPIndent()
    Defined: ~\AppData\Local\nvim-data\plugged\vim-polyglot\indent\python.vim:380
Called 1 time
Total time:   0.141547
 Self time:   0.000641

count  total (s)   self (s)
                                " First line has indent 0
    1              0.000017     if a:lnum == 1
                                    return 0
    1              0.000004     endif
                            
    1              0.000018     let line = getline(a:lnum)
    1              0.000012     let prevline = getline(a:lnum-1)
                            
                                " Multilinestrings: continous, docstring or starting.
    1   0.000958   0.000140     if s:is_python_string(a:lnum-1, max([1, len(prevline)])) && (s:is_python_string(a:lnum, 1)     || match(line, '^\%("""\|''''''\)') != -1)
                            
                                    " Indent closing quotes as the line with the opening ones.
                                    let match_quotes = match(line, '^\s*\zs\%("""\|''''''\)')
                                    if match_quotes != -1
                                        " closing multiline string
                                        let quotes = line[match_quotes:(match_quotes+2)]
                                        call cursor(a:lnum, 1)
                                        let pairpos = searchpairpos(quotes, '', quotes, 'bW', '', 0, g:python_pep8_indent_searchpair_timeout)
                                        if pairpos[0] != 0
                                            return indent(pairpos[0])
                                        else
                                            return -1
                                        endif
                                    endif
                            
                                    if s:is_python_string(a:lnum-1)
                                        " Previous line is (completely) a string: keep current indent.
                                        return -1
                                    endif
                            
                                    if match(prevline, '^\s*\%("""\|''''''\)') != -1
                                        " docstring.
                                        return indent(a:lnum-1)
                                    endif
                            
                                    let indent_multi = get(b:, 'python_pep8_indent_multiline_string', get(g:, 'python_pep8_indent_multiline_string', 0))
                                    if match(prevline, '\v%("""|'''''')$') != -1
                                        " Opening multiline string, started in previous line.
                                        if (&autoindent && indent(a:lnum) == indent(a:lnum-1)) || match(line, '\v^\s+$') != -1
                                            " <CR> with empty line or to split up 'foo("""bar' into
                                            " 'foo("""' and 'bar'.
                                            if indent_multi == -2
                                                return indent(a:lnum-1) + s:sw()
                                            endif
                                            return indent_multi
                                        endif
                                    endif
                            
                                    " Keep existing indent.
                                    if match(line, '\v^\s*\S') != -1
                                        return -1
                                    endif
                            
                                    if indent_multi != -2
                                        return indent_multi
                                    endif
                            
                                    return s:indent_like_opening_paren(a:lnum)
    1              0.000002     endif
                            
                                " Parens: If we can find an open parenthesis/bracket/brace, line up with it.
    1   0.069122   0.000050     let indent = s:indent_like_opening_paren(a:lnum)
    1              0.000005     if indent >= -1
                                    return indent
    1              0.000002     endif
                            
                                " Blocks: Match indent of first block of this type.
    1   0.000560   0.000042     let indent = s:indent_like_block(a:lnum)
    1              0.000005     if indent >= -1
                                    return indent
    1              0.000002     endif
                            
    1   0.070538   0.000039     return s:indent_like_previous_line(a:lnum)

FUNCTION  <SNR>144_isFoldable()
    Defined: ~\AppData\Local\nvim-data\plugged\tagbar\autoload\tagbar\prototypes\basetag.vim:151
Called 15 times
Total time:   0.000194
 Self time:   0.000194

count  total (s)   self (s)
   15              0.000167     return !empty(self._childlist)

FUNCTION  287()
    Defined: ~\AppData\Local\nvim-data\plugged\neoterm\autoload\neoterm\term.vim:57
Called 112 times
Total time:   0.006922
 Self time:   0.006922

count  total (s)   self (s)
  112              0.004074   if has_key(l:self.handlers, 'on_stdout')
                                call l:self.handlers['on_stdout'](a:)
  112              0.000390   end

FUNCTION  <SNR>144_getChildrenByName()
    Defined: ~\AppData\Local\nvim-data\plugged\tagbar\autoload\tagbar\prototypes\basetag.vim:221
Called 3 times
Total time:   0.000021
 Self time:   0.000021

count  total (s)   self (s)
    3              0.000019     return get(self._childdict, a:tagname, [])

FUNCTION  <SNR>21_matchend()
    Defined: ~\AppData\Local\nvim-data\plugged\auto-pairs\plugin\auto-pairs.vim:162
Called 197 times
Total time:   0.009996
 Self time:   0.009996

count  total (s)   self (s)
  197              0.006580     let m = matchstr(a:text, '\V'.a:open.'\v$')
  197              0.001148     if m == ""
  181              0.000825       return []
   16              0.000031     end
   16              0.000484     return [a:text, strpart(a:text, 0, len(a:text)-len(m)), m]

FUNCTION  <SNR>167_set_adapter()
    Defined: ~\AppData\Local\nvim-data\plugged\neoterm\autoload\neoterm\term.vim:16
Called 2 times
Total time:   0.003197
 Self time:   0.002278

count  total (s)   self (s)
    2              0.000040   if !has_key(g:neoterm, 'adapter')
    1              0.000051     if has('nvim')
    1   0.002957   0.002038       let g:neoterm.adapter = neoterm#term#neovim#()
                                elseif has('terminal')
                                  let g:neoterm.adapter = neoterm#term#vim#()
                                else
                                  throw 'neoterm does not support your vim/neovim version'
    1              0.000002     end
    2              0.000005   end
                            
    2              0.000020   return g:neoterm.adapter

FUNCTION  tagbar#state#set_current_file()
    Defined: ~\AppData\Local\nvim-data\plugged\tagbar\autoload\tagbar\state.vim:5
Called 367 times
Total time:   0.032961
 Self time:   0.016552

count  total (s)   self (s)
  367   0.032245   0.015836     call s:get().setCurrentFile(a:fileinfo)

FUNCTION  TrimWhitespace()
    Defined: ~\AppData\Local\nvim\init.vim:421
Called 19 times
Total time:   0.026251
 Self time:   0.026251

count  total (s)   self (s)
   19              0.000684     let l:save = winsaveview()
   19              0.024748     keeppatterns %s/\s\+$//e
   19              0.000651     call winrestview(l:save)

FUNCTION  neoterm#do()
    Defined: ~\AppData\Local\nvim-data\plugged\neoterm\autoload\neoterm.vim:130
Called 6 times
Total time:   0.158388
 Self time:   0.001754

count  total (s)   self (s)
    6              0.001265   let l:opts = extend(a:opts, { 'mod': '', 'target': 0 }, 'keep')
    6              0.000133   let l:opts.cmd = [l:opts.cmd, g:neoterm_eof]
                            
    6              0.000087   let g:neoterm.last_command = l:opts
                            
    6   0.156846   0.000212   call neoterm#exec(l:opts)

FUNCTION  <SNR>22_remove_builtin_extra()
    Defined: ~\AppData\Local\nvim-data\plugged\semshi\plugin\semshi.vim:58
Called 2 times
Total time:   0.000050
 Self time:   0.000050

count  total (s)   self (s)
    2              0.000029     syn keyword pythonKeyword True False None
    2              0.000014     hi link pythonKeyword pythonNumber

FUNCTION  NeotermTerminalPython()
    Defined: ~\AppData\Local\nvim\after\ftplugin\python.vim:48
Called 5 times
Total time:   1.626078
 Self time:   0.005591

count  total (s)   self (s)
    5              0.000130     if g:python_RunFile=='undefined'|| a:Update_RunFile==1
    1              0.000036         let g:python_RunFile = a:current_file
    5              0.000021     endif
    5              0.000194     let g:main_window_nr = a:main_window_nr
                            
    5   0.119793   0.000501     execute "1winc w"
    5              0.000040     if t:NerdTreeInUse == 1
                                    NERDTreeToggle
                                    execute "71winc |"
    5              0.000010     endif
                            
    5              0.000040     if g:python_PlugPluggidiliditity == 1
                                    "execute 'T PROMPT ________________________$_$_\033[32m' . substitute(getcwd(), '^.*\', '', '') . '$g$s'
    1   0.150436   0.002605         execute 'T PROMPT ________________________$_$_' . substitute(getcwd(), '^.*\', '', '') . '$g$s'
    1   0.000079   0.000051         exec "setlocal statusline="
    1              0.000024         let b:CloseThisWindowIfItsLonely = 1    " re-label this variable to be named after your plugin
    1   0.000908   0.000044         setlocal nobuflisted
    1   0.000039   0.000031         setlocal noswapfile
    1   0.000029   0.000026         setlocal bufhidden="wipe"
    1   0.000028   0.000025         setlocal foldcolumn=1
    1   0.000043   0.000040         setlocal winfixwidth
    5              0.000013     endif
    5              0.000114     let g:python_PlugPluggidiliditity = 0
    5   0.013733   0.000745     execute "T python " . g:python_RunFile
    5   1.339922   0.000454     execute a:main_window_nr . "winc w"

FUNCTION  <SNR>138_InitWindow()
    Defined: ~\AppData\Local\nvim-data\plugged\tagbar\autoload\tagbar.vim:980
Called 1 time
Total time:   0.095969
 Self time:   0.000829

count  total (s)   self (s)
    1   0.000060   0.000030     call tagbar#debug#log('InitWindow called with autoclose: ' . a:autoclose)
                            
                                " Buffer-local options
                            
    1   0.089019   0.000038     setlocal filetype=tagbar
                            
    1   0.000025   0.000020     setlocal noreadonly " in case the "view" mode is used
    1   0.000020   0.000018     setlocal buftype=nofile
    1   0.000013   0.000012     setlocal bufhidden=hide
    1   0.000017   0.000014     setlocal noswapfile
    1   0.000627   0.000031     setlocal nobuflisted
    1   0.000031   0.000024     setlocal nomodifiable
    1   0.000034   0.000032     setlocal textwidth=0
    1   0.000017   0.000016     setlocal colorcolumn=""
                            
    1              0.000009     if g:tagbar_scrolloff > 0
                                    execute 'setlocal scrolloff=' . g:tagbar_scrolloff
    1              0.000003     endif
                            
    1              0.000056     if g:tagbar_show_balloon == 1 && has('balloon_eval')
                                    setlocal balloonexpr=TagbarBalloonExpr()
    1              0.000001     endif
                            
                            
                                " Window-local options
                            
    1   0.000013   0.000012     setlocal nolist
    1   0.000015   0.000013     setlocal winfixwidth
    1   0.000011   0.000010     setlocal nospell
                            
    1              0.000005     if g:tagbar_wrap == 0
    1   0.000013   0.000009         setlocal nowrap
                                else
                                    setlocal wrap
                                    if exists('+linebreak')
                                        setlocal breakindent
                                        setlocal breakindentopt=shift:4
                                        if g:tagbar_wrap == 1
                                            setlocal linebreak
                                        elseif g:tagbar_wrap == 2
                                            setlocal nolinebreak
                                        endif
                                    endif
    1              0.000001     endif
                            
    1              0.000006     if g:tagbar_show_linenumbers == 0
                                    setlocal nonumber
                                    if exists('+relativenumber')
                                        setlocal norelativenumber
                                    endif
    1              0.000005     elseif g:tagbar_show_linenumbers == 1
                                    setlocal number
    1              0.000004     elseif g:tagbar_show_linenumbers == 2
                                    setlocal relativenumber
    1              0.000002     else
    1   0.000014   0.000012         set number<
    1              0.000009         if exists('+relativenumber')
    1   0.000016   0.000013             set relativenumber<
    1              0.000002         endif
    1              0.000002     endif
                            
    1   0.000014   0.000011     setlocal nofoldenable
    1   0.000016   0.000014     setlocal foldcolumn=0
                                " Reset fold settings in case a plugin set them globally to something
                                " expensive. Apparently 'foldexpr' gets executed even if 'foldenable' is
                                " off, and then for every appended line (like with :put).
    1   0.000014   0.000013     setlocal foldmethod&
    1   0.000019   0.000017     setlocal foldexpr&
                            
    1   0.000016   0.000014     silent! setlocal signcolumn=no
                            
    1              0.000010     let w:autoclose = a:autoclose
                            
    1   0.001106   0.000045     call s:SetStatusLine()
                            
    1              0.000005     let s:new_window = 1
                            
    1              0.000008     let cpoptions_save = &cpoptions
    1   0.000019   0.000017     set cpoptions&vim
                            
    1              0.000010     if !exists('b:tagbar_mapped_keys')
    1   0.004446   0.000049         call s:MapKeys()
    1              0.000002     endif
                            
    1   0.000024   0.000021     let &cpoptions = cpoptions_save
                            
    1              0.000005     if g:tagbar_expand
                                    let s:expand_bufnr = bufnr('%')
    1              0.000002     endif
                            
    1   0.000053   0.000026     call tagbar#debug#log('InitWindow finished')

FUNCTION  tagbar#debug#log()
    Defined: ~\AppData\Local\nvim-data\plugged\tagbar\autoload\tagbar\debug.vim:30
Called 3127 times
Total time:   0.105147
 Self time:   0.105147

count  total (s)   self (s)
 3127              0.019482     if s:debug_enabled
                                    execute 'redir >> ' . s:debug_file
                                    silent echon s:gettime() . ': ' . a:msg . "\n"
                                    redir END
 3127              0.005855     endif

FUNCTION  <SNR>138_PrintTag()
    Defined: ~\AppData\Local\nvim-data\plugged\tagbar\autoload\tagbar.vim:2096
Called 15 times
Total time:   0.011994
 Self time:   0.005482

count  total (s)   self (s)
   15              0.000216     if g:tagbar_hide_nonpublic && get(a:tag.fields, 'access', 'public') !=# 'public'
                                    let a:tag.tline = -1
                                    return
   15              0.000025     endif
                            
                                " Print tag indented according to depth
   15   0.007026   0.000707     let tagstr = repeat(' ', a:depth * g:tagbar_indent) . a:tag.strfmt()
   15              0.000203     call add(a:output, tagstr)
                            
                                " Save the current tagbar line in the tag for easy highlighting access
   15              0.000236     let offset = g:tagbar_compact && s:short_help ? 0 : line('.')
   15              0.000184     let curline                   = len(a:output) + offset
   15              0.000124     let a:tag.tline               = curline
   15              0.000191     let a:fileinfo.tline[curline] = a:tag
                            
                                " Recursively print children
   15   0.000749   0.000555     if a:tag.isFoldable() && !a:tag.isFolded()
                                    for ckind in a:typeinfo.kinds
                                        let childfilter = 'v:val.fields.kind ==# ckind.short'
                                        if g:tagbar_hide_nonpublic
                                            let childfilter .= ' && get(v:val.fields, "access", "public") ==# "public"'
                                        endif
                                        let childtags = filter(copy(a:tag.getChildren()), childfilter)
                                        if len(childtags) > 0
                                            " Print 'kind' header of following children, but only if they
                                            " are not scope-defining tags (since those already have an
                                            " identifier)
                                            if !has_key(a:typeinfo.kind2scope, ckind.short)
                                                let indent  = (a:depth + 1) * g:tagbar_indent
                                                let indent += g:tagbar_show_visibility
                                                let indent += 1 " fold symbol
                                                call add(a:output, repeat(' ', indent) . '[' . ckind.long . ']')
                                                " Add basic tag to allow folding when on the header line
                                                let headertag = tagbar#prototypes#basetag#new(ckind.long)
                                                let headertag.parent = a:tag
                                                let headertag.fileinfo = a:tag.fileinfo
                                                let a:fileinfo.tline[len(a:output) + offset] = headertag
                                            endif
                                            for childtag in childtags
                                                call s:PrintTag(childtag, a:depth + 1, a:output, a:fileinfo, a:typeinfo)
                                            endfor
                                        endif
                                    endfor
   15              0.000029     endif

FUNCTION  AutoPairsMap()
    Defined: ~\AppData\Local\nvim-data\plugged\auto-pairs\plugin\auto-pairs.vim:445
Called 85 times
Total time:   0.009468
 Self time:   0.009468

count  total (s)   self (s)
                              " | is special key which separate map command from text
   85              0.000484   let key = a:key
   85              0.000379   if key == '|'
                                let key = '<BAR>'
   85              0.000125   end
   85              0.001574   let escaped_key = substitute(key, "'", "''", 'g')
                              " use expr will cause search() doesn't work
   85              0.006064   execute 'inoremap <buffer> <silent> '.key." <C-R>=AutoPairsInsert('".escaped_key."')<CR>"

FUNCTION  <SNR>21_left()
    Defined: ~\AppData\Local\nvim-data\plugged\auto-pairs\plugin\auto-pairs.vim:123
Called 16 times
Total time:   0.001305
 Self time:   0.000575

count  total (s)   self (s)
   16   0.001270   0.000540   return repeat(s:Left, s:ulen(a:s))

FUNCTION  <SNR>55_CursorHoldUpdate()
    Defined: ~\AppData\Local\nvim-data\plugged\vim-devicons\plugin\webdevicons.vim:409
Called 347 times
Total time:   0.158136
 Self time:   0.037634

count  total (s)   self (s)
  347              0.010111   if g:NERDTreeUpdateOnCursorHold != 1 || g:NERDTreeGitStatusUpdateOnCursorHold != 1
                                return
  347              0.001297   endif
                            
  347   0.139183   0.018681   if !exists('g:NERDTree') || !g:NERDTree.IsOpen()
  347              0.001105     return
                              endif
                            
                              " Do not update when a special buffer is selected
                              if !empty(&l:buftype)
                                return
                              endif
                            
                              " winnr need to make focus go to opened file
                              " CursorToTreeWin needed to avoid error on opening file
                              let l:winnr = winnr()
                              let l:altwinnr = winnr('#')
                            
                              call g:NERDTree.CursorToTreeWin()
                              call b:NERDTree.root.refreshFlags()
                              call NERDTreeRender()
                            
                              exec l:altwinnr . 'wincmd w'
                              exec l:winnr . 'wincmd w'

FUNCTION  <SNR>122_indent_like_previous_line()
    Defined: ~\AppData\Local\nvim-data\plugged\vim-polyglot\indent\python.vim:288
Called 1 time
Total time:   0.070499
 Self time:   0.001702

count  total (s)   self (s)
    1              0.000015     let lnum = prevnonblank(a:lnum - 1)
                            
                                " No previous line, keep current indent.
    1              0.000005     if lnum < 1
                                  return -1
    1              0.000002     endif
                            
    1              0.000009     let text = getline(lnum)
    1   0.067372   0.000040     let start = s:find_start_of_multiline_statement(lnum)
    1              0.000024     let base = indent(start)
    1              0.000011     let current = indent(a:lnum)
                            
                                " Ignore last character in previous line?
    1              0.000010     let lastcol = len(text)
    1              0.000005     let col = lastcol
                            
                                " Search for final colon that is not inside something to be ignored.
   25              0.000056     while 1
   49              0.000148         if col == 1 | break | endif
   24   0.002176   0.000753         if text[col-1] =~# '\s' || s:_skip_special_chars(lnum, col)
   24              0.000137             let col = col - 1
   24              0.000060             continue
                                    elseif text[col-1] ==# ':'
                                        return base + s:sw()
                                    endif
                                    break
    1              0.000005     endwhile
                            
    1              0.000035     if text =~# '\\$' && !s:_skip_special_chars(lnum, lastcol)
                                    " If this line is the continuation of a control statement
                                    " indent further to distinguish the continuation line
                                    " from the next logical line.
                                    if getline(start) =~# b:control_statement
                                        return base + s:sw() * 2
                                    endif
                            
                                    " Nest (other) explicit continuations only one level deeper.
                                    return base + s:sw()
    1              0.000002     endif
                            
    1              0.000028     let empty = getline(a:lnum) =~# '^\s*$'
                            
                                " Current and prev line are empty, next is not -> indent like next.
    1              0.000020     if empty && a:lnum > 1 && (getline(a:lnum - 1) =~# '^\s*$') && !(getline(a:lnum + 1) =~# '^\s*$')
                                  return indent(a:lnum + 1)
    1              0.000002     endif
                            
                                " If the previous statement was a stop-execution statement or a pass
    1              0.000050     if getline(start) =~# s:stop_statement
                                    " Remove one level of indentation if the user hasn't already dedented
                                    if empty || current > base - s:sw()
                                        return base - s:sw()
                                    endif
                                    " Otherwise, trust the user
                                    return -1
    1              0.000002     endif
                            
    1   0.000078   0.000037     if (current || !empty) && s:is_dedented_already(current, base)
                                    return -1
    1              0.000002     endif
                            
                                " In all other cases, line up with the start of the previous statement.
    1              0.000004     return base

FUNCTION  <SNR>138_PrintHelp()
    Defined: ~\AppData\Local\nvim-data\plugged\tagbar\autoload\tagbar.vim:2147
Called 5 times
Total time:   0.003166
 Self time:   0.002709

count  total (s)   self (s)
    5              0.000105     if !g:tagbar_compact && !g:tagbar_help_visibility && s:short_help
    5   0.001158   0.000701         silent 0put ='\" Press ' . s:get_map_str('help') . ' for help'
    5              0.000183         silent  put _
                                elseif g:tagbar_help_visibility || !s:short_help
                                    let help_cmds = [ ['jump',              'Jump to tag definition'], ['preview',           'As above, but stay in tagbar window'], ['previewwin',        'Show tag in preview window'], ['nexttag',           'Go to next top-level tag'], ['prevtag',           'Go to previous top-level tag'], ['showproto',         'Display tag prototype'], ['hidenonpublic',     'Hide non-public tags'], ]
                                    let fold_cmds = [ ['openfold',          'Open fold'], ['closefold',         'Close fold'], ['togglefold',        'Toggle fold'], ['openallfolds',      'Open all folds'], ['closeallfolds',     'Close all folds'], ['incrementfolds',    'Increment fold level by 1'], ['decrementfolds',    'Decrement fold level by 1'], ['nextfold',          'Go to next fold'], ['prevfold',          'Go to previous fold'], ]
                                    let misc_cmds = [ ['togglesort',        'Toggle sort'], ['togglecaseinsensitive', 'Toggle case insensitive sort option'], ['toggleautoclose',   'Toggle autoclose option'], ['togglepause',       'Toggle pause'], ['zoomwin',           'Zoom window in/out'], ['close',             'Close window'], ['help',              'Toggle help'], ]
                            
                                    silent 0put ='\" Tagbar keybindings'
                                    silent  put ='\"'
                                    silent  put ='\" --------- General ---------'
                                    for [cmd, desc] in help_cmds
                                        if !empty(s:get_map_str(cmd)) | silent put ='\" ' . s:get_map_str(cmd) . ': ' . desc | endif
                                    endfor
                                    silent  put ='\"'
                                    silent  put ='\" ---------- Folds ----------'
                                    for [cmd, desc] in fold_cmds
                                        if !empty(s:get_map_str(cmd)) | silent put ='\" ' . s:get_map_str(cmd) . ': ' . desc | endif
                                    endfor
                                    silent  put ='\"'
                                    silent  put ='\" ---------- Misc -----------'
                                    for [cmd, desc] in misc_cmds
                                        if !empty(s:get_map_str(cmd)) | silent put ='\" ' . s:get_map_str(cmd) . ': ' . desc | endif
                                    endfor
                                    silent  put _
    5              0.000011     endif

FUNCTION  <SNR>144_addChild()
    Defined: ~\AppData\Local\nvim-data\plugged\tagbar\autoload\tagbar\prototypes\basetag.vim:205
Called 3 times
Total time:   0.000082
 Self time:   0.000082

count  total (s)   self (s)
    3              0.000016     call add(self._childlist, a:tag)
                            
    3              0.000016     if has_key(self._childdict, a:tag.name)
                                    call add(self._childdict[a:tag.name], a:tag)
    3              0.000003     else
    3              0.000020         let self._childdict[a:tag.name] = [a:tag]
    3              0.000003     endif

FUNCTION  <SNR>13_LoadIndent()
    Defined: ~\scoop\apps\neovim\0.6.1\share\nvim\runtime\indent.vim:13
Called 5 times
Total time:   0.038754
 Self time:   0.033618

count  total (s)   self (s)
    5              0.000071     if exists("b:undo_indent")
                                  exe b:undo_indent
                                  unlet! b:undo_indent b:did_indent
    5              0.000010     endif
    5              0.000090     let s = expand("<amatch>")
    5              0.000031     if s != ""
    5              0.000037       if exists("b:did_indent")
                            	unlet b:did_indent
    5              0.000008       endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "indent/aaa.vim" and then "indent/bbb.vim".
   10              0.000174       for name in split(s, '\.')
    5   0.022922   0.017786         exe 'runtime! indent/' . name . '.vim'
    5              0.015112         exe 'runtime! indent/' . name . '.lua'
   10              0.000061       endfor
    5              0.000015     endif

FUNCTION  <SNR>142_clearOldFolds()
    Defined: ~\AppData\Local\nvim-data\plugged\tagbar\autoload\tagbar\prototypes\fileinfo.vim:122
Called 27 times
Total time:   0.000904
 Self time:   0.000904

count  total (s)   self (s)
   27              0.000301     if exists('self._tagfolds_old')
   21              0.000434         unlet self._tagfolds_old
   27              0.000053     endif

FUNCTION  AutoPairsDefaultPairs()
    Defined: ~\AppData\Local\nvim-data\plugged\auto-pairs\plugin\auto-pairs.vim:20
Called 7 times
Total time:   0.001704
 Self time:   0.001704

count  total (s)   self (s)
    7              0.000067   if exists('b:autopairs_defaultpairs')
                                return b:autopairs_defaultpairs
    7              0.000013   end
    7              0.000137   let r = copy(g:AutoPairs)
    7              0.000335   let allPairs = { 'vim': {'\v^\s*\zs"': ''}, 'rust': {'\w\zs<': '>', '&\zs''': ''}, 'php': {'<?': '?>//k]', '<?php': '?>//k]'} }
   28              0.000279   for [filetype, pairs] in items(allPairs)
   21              0.000146     if &filetype == filetype
    2              0.000011       for [open, close] in items(pairs)
    1              0.000006         let r[open] = close
    2              0.000003       endfor
   21              0.000037     end
   28              0.000063   endfor
    7              0.000058   let b:autopairs_defaultpairs = r
    7              0.000026   return r

FUNCTION  <SNR>143_getPrototype()
    Defined: ~\AppData\Local\nvim-data\plugged\tagbar\autoload\tagbar\prototypes\normaltag.vim:75
Called 3 times
Total time:   0.000622
 Self time:   0.000622

count  total (s)   self (s)
    3              0.000031     if self.prototype !=# ''
                                    let prototype = self.prototype
    3              0.000006     else
    3              0.000022         let bufnr = self.fileinfo.bufnr
                            
    3              0.000035         if self.fields.line == 0 || !bufloaded(bufnr)
                                        " No linenumber available or buffer not loaded (probably due to
                                        " 'nohidden'), try the pattern instead
                                        return substitute(self.pattern, '^\\M\\^\\C\s*\(.*\)\\$$', '\1', '')
    3              0.000005         endif
                            
    3              0.000051         let line = getbufline(bufnr, self.fields.line)[0]
                                    " If prototype includes declaration, remove the '=' and anything after
                                    " FIXME: Need to remove this code. This breaks python prototypes that
                                    " can include a '=' in the function paramter list.
                                    "   ex: function(arg1, optional_arg2=False)
                                    " let line = substitute(line, '\s*=.*', '', '')
    3              0.000210         let list = split(line, '\zs')
                            
    3              0.000032         let start = index(list, '(')
    3              0.000013         if start == -1
    2              0.000039             return substitute(line, '^\s\+', '', '')
    1              0.000002         endif
                            
    1              0.000012         let opening = count(list, '(', 0, start)
    1              0.000009         let closing = count(list, ')', 0, start)
    1              0.000005         if closing >= opening
    1              0.000020             return substitute(line, '^\s\+', '', '')
                                    endif
                            
                                    let balance = opening - closing
                            
                                    let prototype = line
                                    let curlinenr = self.fields.line + 1
                                    while balance > 0 && curlinenr < line('$')
                                        let curline = getbufline(bufnr, curlinenr)[0]
                                        let curlist = split(curline, '\zs')
                                        let balance += count(curlist, '(')
                                        let balance -= count(curlist, ')')
                                        let prototype .= "\n" . curline
                                        let curlinenr += 1
                                    endwhile
                            
                                    let self.prototype = prototype
                                endif
                            
                                if a:short
                                    " join all lines and remove superfluous spaces
                                    let prototype = substitute(prototype, '^\s\+', '', '')
                                    let prototype = substitute(prototype, '\_s\+', ' ', 'g')
                                    let prototype = substitute(prototype, '(\s\+', '(', 'g')
                                    let prototype = substitute(prototype, '\s\+)', ')', 'g')
                                    " Avoid hit-enter prompts
                                    let maxlen = &columns - 12
                                    if len(prototype) > maxlen
                                        let prototype = prototype[:maxlen - 1 - 3]
                                        let prototype .= '...'
                                    endif
                                endif
                            
                                return prototype

FUNCTION  <SNR>144_openParents()
    Defined: ~\AppData\Local\nvim-data\plugged\tagbar\autoload\tagbar\prototypes\basetag.vim:195
Called 1 time
Total time:   0.000033
 Self time:   0.000033

count  total (s)   self (s)
    1              0.000007     let parent = self.parent
                            
    1              0.000008     while !empty(parent)
                                    call parent.openFold()
                                    let parent = parent.parent
    1              0.000003     endwhile

FUNCTION  BuffergatorUpdateMRU()
    Defined: ~\AppData\Local\nvim-data\plugged\vim-buffergator\plugin\buffergator.vim:41
Called 69 times
Total time:   0.018733
 Self time:   0.018733

count  total (s)   self (s)
   69              0.001127     if len(g:buffergator_mru) < 1 " maybe should be 2?
                                    if g:buffergator_mru_cycle_loop
                                        let g:buffergator_mru = []
                                        for l:bni in range(bufnr("$"), 1, -1)
                                            if buflisted(l:bni)   && getbufvar(l:bni, "&filetype") != "netrw"
                                                call add(g:buffergator_mru, l:bni)
                                            endif
                                        endfor
                                    endif
   69              0.000137     endif
   69              0.000931     if !exists("w:buffergator_mru")
    5              0.000098         let w:buffergator_mru = g:buffergator_mru[:]
   69              0.000132     endif
   69              0.000371     if g:buffergator_track_mru
   69              0.000810         let bnum = a:acmd_bufnr + 0
                                    " if bnum == 0 || !buflisted(bnum) || !(empty(getbufvar(bnum, "netrw_browser_active")))
   69              0.001938         if bnum == 0 || !buflisted(bnum) || getbufvar(bnum, "&filetype") == "netrw"
   12              0.000034             return
   57              0.000119         endif
   57              0.002940         call filter(g:buffergator_mru, 'v:val !=# bnum')
   57              0.000738         call insert(g:buffergator_mru, bnum, 0)
   57              0.001913         call filter(w:buffergator_mru, 'v:val !=# bnum')
   57              0.000695         call insert(w:buffergator_mru, bnum, 0)
   57              0.000161     endif

FUNCTION  neoterm#term#current_id()
    Defined: ~\AppData\Local\nvim-data\plugged\neoterm\autoload\neoterm\term.vim:8
Called 1 time
Total time:   0.000289
 Self time:   0.000082

count  total (s)   self (s)
    1   0.000285   0.000079   return s:adapter().get_current_termid()

FUNCTION  tagbar#state#get_current_file()
    Defined: ~\AppData\Local\nvim-data\plugged\tagbar\autoload\tagbar\state.vim:1
Called 1196 times
Total time:   0.158046
 Self time:   0.060735

count  total (s)   self (s)
 1196   0.155232   0.057922     return s:get().getCurrent(a:force_current)

FUNCTION  <SNR>5_SynSet()
    Defined: ~\scoop\apps\neovim\current\share\nvim\runtime\syntax\synload.vim:26
Called 36 times
Total time:   1.935054
 Self time:   0.761852

count  total (s)   self (s)
                              " clear syntax for :set syntax=OFF  and any syntax name that doesn't exist
   36              0.000523   syn clear
   36              0.000809   if exists("b:current_syntax")
                                unlet b:current_syntax
   36              0.000121   endif
                            
   36              0.004645   let s = expand("<amatch>")
   36              0.000288   if s == "ON"
                                " :set syntax=ON
                                if &filetype == ""
                                  echohl ErrorMsg
                                  echo "filetype unknown"
                                  echohl None
                                endif
                                let s = &filetype
   36              0.000298   elseif s == "OFF"
                                let s = ""
   36              0.000074   endif
                            
   36              0.000193   if s != ""
                                " Load the syntax file(s).  When there are several, separated by dots,
                                " load each in sequence.  Skip empty entries.
   72              0.001683     for name in split(s, '\.')
   36              0.000362       if !empty(name)
   36   1.648818   0.475617         exe "runtime! syntax/" . name . ".vim syntax/" . name . "/*.vim"
   36              0.272635         exe "runtime! syntax/" . name . ".lua syntax/" . name . "/*.lua"
   36              0.000319       endif
   72              0.000320     endfor
   36              0.000115   endif

FUNCTION  <SNR>22_filetype_changed()
    Defined: ~\AppData\Local\nvim-data\plugged\semshi\plugin\semshi.vim:63
Called 5 times
Total time:   0.105513
 Self time:   0.000609

count  total (s)   self (s)
    5              0.000102     let l:ft = expand('<amatch>')
    5              0.000077     if index(g:semshi#filetypes, l:ft) != -1
    2              0.000022         if !get(b:, 'semshi_attached', v:false)
    2   0.105032   0.000128             Semshi enable
    2              0.000005         endif
    3              0.000007     else
    3              0.000063         if get(b:, 'semshi_attached', v:false)
                                        Semshi disable
    3              0.000006         endif
    5              0.000009     endif

FUNCTION  tagbar#prototypes#normaltag#new()
    Defined: ~\AppData\Local\nvim-data\plugged\tagbar\autoload\tagbar\prototypes\normaltag.vim:10
Called 543 times
Total time:   0.953904
 Self time:   0.156374

count  total (s)   self (s)
  543   0.783691   0.055715     let newobj = tagbar#prototypes#basetag#new(a:name)
                            
  543   0.034132   0.020139     let newobj.isNormalTag = function(s:add_snr('s:isNormalTag'))
  543   0.032034   0.018253     let newobj.strfmt = function(s:add_snr('s:strfmt'))
  543   0.031857   0.017788     let newobj.str = function(s:add_snr('s:str'))
  543   0.033074   0.019145     let newobj.getPrototype = function(s:add_snr('s:getPrototype'))
  543   0.031911   0.018128     let newobj.getDataType = function(s:add_snr('s:getDataType'))
                            
  543              0.001894     return newobj

FUNCTION  <SNR>145_add_snr()
    Defined: ~\AppData\Local\nvim-data\plugged\tagbar\autoload\tagbar\prototypes\kindheadertag.vim:53
Called 413 times
Total time:   0.010033
 Self time:   0.010033

count  total (s)   self (s)
  413              0.002847     if !exists('s:snr')
    1              0.000118         let s:snr = matchstr(expand('<sfile>'), '<SNR>\d\+_\zeget_snr$')
  413              0.000593     endif
  413              0.002071     return s:snr . a:funcname

FUNCTION  SemshiBufLeave()
    Defined: ~\scoop\apps\neovim\0.6.1\share\nvim\runtime\autoload\remote\define.vim:169
Called 30 times
Total time:   0.033991
 Self time:   0.001929

count  total (s)   self (s)
   30   0.033851   0.001788 return remote#define#request(5, "C:/Users/Lenovo/AppData/Local/nvim-data/plugged/semshi/rplugin/python3/semshi:function:SemshiBufLeave", a:000)

FUNCTION  <SNR>141_createKinddict()
    Defined: ~\AppData\Local\nvim-data\plugged\tagbar\autoload\tagbar\prototypes\typeinfo.vim:25
Called 56 times
Total time:   0.006069
 Self time:   0.006069

count  total (s)   self (s)
   56              0.000205     let i = 0
  368              0.001064     for kind in self.kinds
  312              0.002172         let self.kinddict[kind.short] = i
  312              0.001024         let i += 1
  368              0.000625     endfor
   56              0.000290     let self.kinddict['?'] = i

FUNCTION  <SNR>138_ProcessTag()
    Defined: ~\AppData\Local\nvim-data\plugged\tagbar\autoload\tagbar.vim:1564
Called 543 times
Total time:   1.718799
 Self time:   0.498600

count  total (s)   self (s)
  543              0.003108     if a:is_split
                                    let taginfo = tagbar#prototypes#splittag#new(a:name)
  543              0.001021     else
  543   1.017000   0.060629         let taginfo = tagbar#prototypes#normaltag#new(a:name)
  543              0.001108     endif
                            
  543              0.004628     let taginfo.file    = a:filename
  543              0.004243     let taginfo.pattern = a:pattern
  543              0.087835     call extend(taginfo.fields, a:fields)
                            
                                " Needed for jsctags
  543              0.006379     if has_key(taginfo.fields, 'lineno')
                                    let taginfo.fields.line = str2nr(taginfo.fields.lineno)
  543              0.000897     endif
                                " Do some sanity checking in case ctags reports invalid line numbers
  543              0.003461     if taginfo.fields.line < 0
                                    let taginfo.fields.line = 0
  543              0.000781     endif
                            
                                " Make sure our 'end' is valid
  543              0.003869     if taginfo.fields.end < taginfo.fields.line
  543   0.039122   0.020002         if a:typeinfo.getKind(taginfo.fields.kind).stl
                                        " the config indicates this is a scoped kind due to 'stl', but we
                                        " don't have scope vars, assume scope goes to end of file. This
                                        " can also be the case for exhuberant ctags which doesn't support
                                        " the --fields=e option.
                                        " When we call the GetNearbyTag(), it will look up for the nearest
                                        " tag, so if we have multiples that have scope to the end of the
                                        " file it will still only grab the first one above the current line
  103              0.001079             let taginfo.fields.end = line('$')
  440              0.001125         else
  440              0.003647             let taginfo.fields.end = taginfo.fields.line
  543              0.001185         endif
  543              0.000894     endif
                            
  543              0.004776     if !has_key(taginfo.fields, 'kind')
                                    call tagbar#debug#log( "Warning: No 'kind' field found for tag " . a:name[0] . '!')
                                    if index(s:warnings.type, a:typeinfo.ftype) == -1
                                        call s:warning("No 'kind' field found for tag " . a:name[0] . '!' . " Please read the last section of ':help tagbar-extend'.")
                                        call add(s:warnings.type, a:typeinfo.ftype)
                                    endif
                                    return
  543              0.000852     endif
                            
  543              0.004422     let taginfo.fileinfo = a:fileinfo
  543              0.003547     let taginfo.typeinfo = a:typeinfo
                            
  543              0.007766     let a:fileinfo.fline[taginfo.fields.line] = taginfo
                            
  543              0.005117     if has_key(taginfo.fields, 'typeref')
                                    let typeref = taginfo.fields.typeref
                                    let delimit = stridx(typeref, ':')
                                    let key = strpart(typeref, 0, delimit)
                                    if key ==# 'typename'
                                        let taginfo.data_type = substitute(strpart(typeref, delimit + 1), '\t', '', 'g')
                                    else
                                        let taginfo.data_type = key
                                    endif
  543              0.000835     endif
                            
                                " If this filetype doesn't have any scope information then we can stop
                                " here after adding the tag to the list
  543              0.005476     if !has_key(a:typeinfo, 'scope2kind')
  149   0.011522   0.003615         call a:fileinfo.addTag(taginfo)
  149              0.000390         return
  394              0.000584     endif
                            
                            
                                " Make some information easier accessible
 1179              0.011786     for scope in keys(a:typeinfo.scope2kind)
  788              0.008113         if has_key(taginfo.fields, scope)
    3              0.000011             let taginfo.scope = scope
    3              0.000015             let taginfo.path  = taginfo.fields[scope]
                            
    3              0.000022             let taginfo.fullpath = taginfo.path . a:typeinfo.sro . taginfo.name
    3              0.000004             break
  785              0.001486         endif
 1179              0.003790     endfor
  394              0.015283     let pathlist = split(taginfo.path, '\V' . escape(a:typeinfo.sro, '\'))
  394              0.004402     let taginfo.depth = len(pathlist)
                            
                                " Needed for folding
  394              0.001200     try
  394   0.071494   0.014405         call taginfo.initFoldState(s:known_files)
                                catch /^Vim(\a\+):E716:/ " 'Key not present in Dictionary'
                                    " The tag has a 'kind' that doesn't exist in the type definition
                                    call tagbar#debug#log('Warning: Unknown tag kind: ' . taginfo.fields.kind)
                                    if index(s:warnings.type, a:typeinfo.ftype) == -1
                                        call s:warning('Unknown tag kind encountered: ' . '"' . taginfo.fields.kind . '".' . ' Your ctags and Tagbar configurations are out of sync!' . ' Please read '':help tagbar-extend''.')
                                        call add(s:warnings.type, a:typeinfo.ftype)
                                    endif
                                    return
  394              0.001243     endtry
                            
  394   0.195324   0.015613     call s:add_tag_recursive({}, taginfo, pathlist)

FUNCTION  <SNR>138_OpenWindow()
    Defined: ~\AppData\Local\nvim-data\plugged\tagbar\autoload\tagbar.vim:869
Called 1 time
Total time:   1.663793
 Self time:   0.017356

count  total (s)   self (s)
    1   0.000068   0.000035     call tagbar#debug#log("OpenWindow called with flags: '" . a:flags . "'")
                            
    1              0.000021     let autofocus = a:flags =~# 'f'
    1              0.000010     let jump      = a:flags =~# 'j'
    1              0.000015     let autoclose = a:flags =~# 'c'
                            
    1              0.000321     let curfile = fnamemodify(bufname('%'), ':p')
    1              0.000280     let curline = line('.')
                            
                                " If the tagbar window is already open check jump flag
                                " Also set the autoclose flag if requested
    1   0.001812   0.001737     let tagbarwinnr = bufwinnr(s:TagbarBufName())
    1              0.000019     if tagbarwinnr != -1
                                    if winnr() != tagbarwinnr && jump
                                        call s:goto_win(tagbarwinnr)
                                        call s:HighlightTag(g:tagbar_autoshowtag != 2, 1, curline)
                                    endif
                                    call tagbar#debug#log('OpenWindow finished, Tagbar already open')
                                    return
    1              0.000003     endif
                            
                                " Use the window ID if the functionality exists, this is more reliable
                                " since the window number can change due to the Tagbar window opening
    1              0.000019     if exists('*win_getid')
    1              0.000018         let prevwinid = win_getid()
    1              0.000014         if winnr('$') > 1
                                        call s:goto_win('p', 1)
                                        let pprevwinid = win_getid()
                                        call s:goto_win('p', 1)
    1              0.000003         endif
                                else
                                    let prevwinnr = winnr()
                                    if winnr('$') > 1
                                        call s:goto_win('p', 1)
                                        let pprevwinnr = winnr()
                                        call s:goto_win('p', 1)
                                    endif
    1              0.000003     endif
                            
                                " This is only needed for the CorrectFocusOnStartup() function
    1              0.000015     let s:last_autofocus = autofocus
                            
    1   1.286568   0.000058     if !s:Init(0)
                                    return 0
    1              0.000002     endif
                            
                                " Expand the Vim window to accommodate for the Tagbar window if requested
                                " and save the window positions to be able to restore them later.
    1              0.000017     if g:tagbar_expand >= 1 && !s:window_expanded && (has('gui_running') || g:tagbar_expand == 2)
                                    let s:window_pos.pre.x = getwinposx()
                                    let s:window_pos.pre.y = getwinposy()
                                    let &columns += g:tagbar_width + 1
                                    let s:window_pos.post.x = getwinposx()
                                    let s:window_pos.post.y = getwinposy()
                                    let s:window_expanded = 1
    1              0.000002     endif
                            
    1              0.000007     let s:window_opening = 1
    1              0.000022     if g:tagbar_position =~# 'vertical'
    1              0.000008         let size = g:tagbar_width
    1              0.000005         let mode = 'vertical '
                                else
                                    let size = g:tagbar_height
                                    let mode = ''
    1              0.000002     endif
    1   0.115158   0.013947     exe 'silent keepalt ' . g:tagbar_position . size . 'split ' . s:TagbarBufName()
    1              0.000026     exe 'silent ' . mode . 'resize ' . size
    1              0.000007     unlet s:window_opening
                            
    1   0.096020   0.000051     call s:InitWindow(autoclose)
                            
                                " If the current file exists, but is empty, it means that it had a
                                " processing error before opening the window, most likely due to a call to
                                " currenttag() in the statusline. Remove the entry so an error message
                                " will be shown if the processing still fails.
    1   0.000043   0.000025     if empty(s:known_files.get(curfile))
                                    call s:known_files.rm(curfile)
    1              0.000002     endif
                            
    1   0.055451   0.000029     call s:AutoUpdate(curfile, 0)
    1   0.072888   0.000045     call s:HighlightTag(g:tagbar_autoshowtag != 2, 1, curline)
                            
    1              0.000021     if !(g:tagbar_autoclose || autofocus || g:tagbar_autofocus)
    1              0.000015         if exists('*win_getid')
    1              0.000008             if exists('pprevwinid')
                                            noautocmd call win_gotoid(pprevwinid)
    1              0.000003             endif
    1   0.034403   0.000055             call win_gotoid(prevwinid)
                                    else
                                        " If the Tagbar winnr is identical to one of the saved values
                                        " then that means that the window numbers have changed.
                                        " Just jump back to the previous window since we won't be able to
                                        " restore the window history.
                                        if winnr() == prevwinnr || (exists('pprevwinnr') && winnr() == pprevwinnr)
                                            call s:goto_win('p')
                                        else
                                            if exists('pprevwinnr')
                                                call s:goto_win(pprevwinnr, 1)
                                            endif
                                            call s:goto_win(prevwinnr)
                                        endif
    1              0.000000         endif
    1              0.000000     endif
                            
    1   0.000013   0.000006     call tagbar#debug#log('OpenWindow finished')

FUNCTION  remote#define#request()
    Defined: ~\scoop\apps\neovim\0.6.1\share\nvim\runtime\autoload\remote\define.vim:194
Called 92 times
Total time:   0.299628
 Self time:   0.286824

count  total (s)   self (s)
   92              0.002812   let s:busy[a:chan] = get(s:busy, a:chan, 0)+1
   92              0.182946   let val = call('rpcrequest', [a:chan]+a:000)
   92              0.003204   let s:busy[a:chan] -= 1
   92              0.001270   if s:busy[a:chan] == 0
   90              0.002425     for msg in get(s:pending_notifications, a:chan, [])
                                  call call('rpcnotify', [a:chan] + msg)
   90              0.000486     endfor
   90              0.001217     let s:pending_notifications[a:chan] = []
   92              0.000246   endif
   92              0.000611   return val

FUNCTION  <SNR>144_getClosedParentTline()
    Defined: ~\AppData\Local\nvim-data\plugged\tagbar\autoload\tagbar\prototypes\basetag.vim:130
Called 1 time
Total time:   0.000212
 Self time:   0.000212

count  total (s)   self (s)
    1              0.000012     let tagline  = self.tline
                            
                                " Find the first closed parent, starting from the top of the hierarchy.
    1              0.000008     let parents   = []
    1              0.000009     let curparent = self.parent
    1              0.000016     while !empty(curparent)
                                    call add(parents, curparent)
                                    let curparent = curparent.parent
    1              0.000005     endwhile
    1              0.000077     for parent in reverse(parents)
                                    if parent.isFolded()
                                        let tagline = parent.tline
                                        break
                                    endif
    1              0.000006     endfor
                            
    1              0.000008     return tagline

FUNCTION  <SNR>166_ensure_instance()
    Defined: ~\AppData\Local\nvim-data\plugged\neoterm\autoload\neoterm\target.vim:41
Called 5 times
Total time:   0.000131
 Self time:   0.000131

count  total (s)   self (s)
    5              0.000080   if bufexists(a:instance.buffer_id)
    5              0.000031     return a:instance
                              else
                                echo printf(s:not_found_msg, a:instance.id)
                                call neoterm#destroy(a:instance)
                                return {}
                              end

FUNCTION  292()
    Defined: ~\AppData\Local\nvim-data\plugged\neoterm\autoload\neoterm\term\neovim.vim:15
Called 1 time
Total time:   0.000013
 Self time:   0.000013

count  total (s)   self (s)
    1              0.000011   return b:terminal_job_id

FUNCTION  neoterm#repl#python#is_valid()
    Defined: ~\AppData\Local\nvim-data\plugged\neoterm\autoload\neoterm\repl\python.vim:5
Called 2 times
Total time:   0.000201
 Self time:   0.000201

count  total (s)   self (s)
    2              0.000047   let l:cmd =  type(a:value) == v:t_list ? join(a:value) : a:value
                            
    2              0.000046   if l:cmd =~# '\<ipython\>'
                                return executable('ipython')
    2              0.000021   elseif l:cmd =~# '\<jupyter\>'
                                return executable('jupyter')
    2              0.000027   elseif l:cmd =~# '\<python\>'
                                return executable('python')
    2              0.000003   else
    2              0.000008     return v:false
                              end

FUNCTION  <SNR>138_ToggleWindow()
    Defined: ~\AppData\Local\nvim-data\plugged\tagbar\autoload\tagbar.vim:854
Called 1 time
Total time:   1.697863
 Self time:   0.032721

count  total (s)   self (s)
    1   0.032813   0.031524     call tagbar#debug#log('ToggleWindow called')
                            
    1   0.001148   0.001093     let tagbarwinnr = bufwinnr(s:TagbarBufName())
    1              0.000012     if tagbarwinnr != -1
                                    call s:CloseWindow()
                                    return
    1              0.000003     endif
                            
    1   1.663849   0.000057     call s:OpenWindow(a:flags)
                            
    1   0.000010   0.000005     call tagbar#debug#log('ToggleWindow finished')

FUNCTION  neoterm#new()
    Defined: ~\AppData\Local\nvim-data\plugged\neoterm\autoload\neoterm.vim:1
Called 1 time
Total time:   0.139269
 Self time:   0.002459

count  total (s)   self (s)
    1              0.000013   if exists('*g:neoterm_callbacks.before_new')
                                call g:neoterm_callbacks.before_new()
    1              0.000003   end
                            
    1   0.013960   0.001992   let l:instance = neoterm#term#new(get(a:, 1, {}))
                            
    1              0.000013   if !l:instance.from_session
    1   0.027373   0.000074     call s:create_window(l:instance)
    1              0.000002   end
                            
    1              0.000013   let l:instance.buffer_id = bufnr('')
    1   0.000369   0.000039   let l:instance.id = g:neoterm.next_id()
    1              0.000033   let l:instance.name = printf('neoterm-%s', l:instance.id)
    1              0.000013   let t:neoterm_id = l:instance.id
                            
    1              0.000009   if !l:instance.from_session
    1   0.023780   0.000046     let l:instance.termid = l:instance.new(l:instance)
    1              0.000004   end
                            
    1   0.073515   0.000056   call s:after_open(l:instance)
                            
    1              0.000028   let g:neoterm.instances[l:instance.id] = l:instance
                            
    1   0.000091   0.000070   call s:update_last_active(l:instance)
                            
    1              0.000008   return l:instance

FUNCTION  <SNR>138_do_delayed_update()
    Defined: ~\AppData\Local\nvim-data\plugged\tagbar\autoload\tagbar.vim:3600
Called 456 times
Total time:   5.552949
 Self time:   0.070718

count  total (s)   self (s)
  456   0.098548   0.024524     let curfile = tagbar#state#get_current_file(0)
  456              0.004385     if empty(curfile)
                                    let curfname = ''
  456              0.001294     else
  456              0.004796         let curfname = curfile.fpath
  456              0.001168     endif
                            
  473              0.006878     while !empty(s:delayed_update_files)
   17              0.000273         let fname = remove(s:delayed_update_files, 0)
   17              0.000218         let no_display = curfname !=# fname
   17   5.408980   0.000774         call s:AutoUpdate(fname, 1, no_display)
  473              0.002241     endwhile

FUNCTION  dashboard#close_preview()
    Defined: ~\AppData\Local\nvim-data\plugged\dashboard-nvim\autoload\dashboard.vim:237
Called 29 times
Total time:   0.001893
 Self time:   0.001893

count  total (s)   self (s)
   29              0.000723   let s:dashboard_winid = get(w:,'dashboard_preview_winid',0)
                            
   29              0.000397   if s:dashboard_winid != 0 && nvim_win_is_valid(s:dashboard_winid)
                                call nvim_win_close(s:dashboard_winid,v:true)
                                let w:dashboard_preview_winid = 0
   29              0.000079   endif

FUNCTION  SemshiCursorMoved()
    Defined: ~\scoop\apps\neovim\0.6.1\share\nvim\runtime\autoload\remote\define.vim:169
Called 689 times
Total time:   0.142934
 Self time:   0.039195

count  total (s)   self (s)
  689   0.139596   0.035856 return remote#define#notify(5, "C:/Users/Lenovo/AppData/Local/nvim-data/plugged/semshi/rplugin/python3/semshi:function:SemshiCursorMoved", a:000)

FUNCTION  <SNR>138_CheckFTCtags()
    Defined: ~\AppData\Local\nvim-data\plugged\tagbar\autoload\tagbar.vim:772
Called 3 times
Total time:   0.159840
 Self time:   0.159840

count  total (s)   self (s)
    3              0.159566     if executable(a:bin)
                                    return a:bin
    3              0.000012     endif
                            
    3              0.000067     if exists('g:tagbar_type_' . a:ftype)
                                    let userdef = g:tagbar_type_{a:ftype}
                                    if has_key(userdef, 'ctagsbin')
                                        return userdef.ctagsbin
                                    else
                                        return ''
                                    endif
    3              0.000005     endif
                            
    3              0.000011     return ''

FUNCTION  <SNR>54_Normalize()
    Defined: ~\AppData\Local\nvim-data\plugged\LeaderF\plugin\leaderf.vim:98
Called 70 times
Total time:   0.008863
 Self time:   0.008863

count  total (s)   self (s)
   70              0.005342     if has("nvim") && (has('win32') || has('win64'))
   70              0.000550         if &shellslash
                                        return tr(a:filename, '\', '/')
   70              0.000220         else
   70              0.001327             return tr(a:filename, '/', '\')
                                    endif
                                else
                                    return a:filename
                                endif

FUNCTION  <SNR>138_add_tag_recursive()
    Defined: ~\AppData\Local\nvim-data\plugged\tagbar\autoload\tagbar.vim:1671
Called 397 times
Total time:   0.180328
 Self time:   0.146878

count  total (s)   self (s)
                                " If the pathlist is empty we are at the correct scope for the current tag
  397              0.003730     if empty(a:pathlist)
                                    " If a child tag got processed before a parent tag then there will
                                    " be a pseudotag here as a placeholder. Copy the children over and
                                    " then replace the pseudotag with the real one.
  394              0.002834         let pseudotags = []
  394              0.002732         if empty(a:parent)
  391   0.021961   0.015579             let name_siblings = a:taginfo.fileinfo.getTagsByName(a:taginfo.name)
    3              0.000003         else
    3   0.000072   0.000051             let name_siblings = a:parent.getChildrenByName(a:taginfo.name)
  394              0.000713         endif
                            
                                    " Consider a tag as replaceable if the current tag is considered to
                                    " have more appropriate information
  394              0.003141         for tag in name_siblings
                                        if (tag.fields.kind ==# '?' || tag.fields.kind ==# a:taginfo.fields.kind) && (tag.isPseudoTag() || (!a:taginfo.isSplitTag() && tag.isSplitTag()))
                                            call add(pseudotags, tag)
                                        endif
  394              0.001347         endfor
                            
  394              0.003676         if len(pseudotags) == 1
                                        let pseudotag = pseudotags[0]
                                        for child in pseudotag.getChildren()
                                            call a:taginfo.addChild(child)
                                            let child.parent = a:taginfo
                                        endfor
                                        if empty(a:parent)
                                            call a:taginfo.fileinfo.removeTag(pseudotag)
                                        else
                                            call a:parent.removeChild(pseudotag)
                                        endif
  394              0.003211         elseif len(pseudotags) > 1
                                        echoerr 'Tagbar: Found duplicate pseudotag; this should never happen!' 'Please contact the script maintainer with an example.' 'Pseudotag name:' pseudotag.name
  394              0.000720         endif
                            
                                    " If this is a tag that got created due to splitting up a tag name,
                                    " don't replace existing tags of the same kind.
  394   0.014512   0.011814         if a:taginfo.isSplitTag()
                                        for tag in name_siblings
                                            if tag.fields.kind ==# a:taginfo.fields.kind
                                                return
                                            endif
                                        endfor
  394              0.000696         endif
                            
  394              0.003072         if empty(a:parent)
  391   0.034261   0.010723             call a:taginfo.fileinfo.addTag(a:taginfo)
    3              0.000002         else
    3   0.000118   0.000035             call a:parent.addChild(a:taginfo)
    3              0.000012             let a:taginfo.parent = a:parent
  394              0.000686         endif
  394              0.001068         return
    3              0.000003     endif
                            
                            
                                " There is still at least one more scope between the current one and the
                                " one of the current tag, so we have to either find or create the
                                " intermediate tags
                            
    3              0.000011     let grandparent = a:parent
    3              0.000018     let parentname = remove(a:pathlist, 0)
                            
    3              0.000010     if empty(grandparent)
    3   0.000103   0.000076         let name_siblings = a:taginfo.fileinfo.getTagsByName(parentname)
                                else
                                    let name_siblings = grandparent.getChildrenByName(parentname)
    3              0.000003     endif
    3              0.000012     if empty(a:pathlist)
                                    " If the current tag is a direct child of the parent we're looking for
                                    " then we can also filter the parents based on the scope information
    3              0.000009         let parents = []
    6              0.000019         for tag in name_siblings
    3              0.000043             if tag.fields.kind ==# '?' || get(a:taginfo.typeinfo.kind2scope, tag.fields.kind, '') ==# a:taginfo.scope
    3              0.000040                 call add(parents, tag)
    3              0.000004             endif
    6              0.000010         endfor
                                else
                                    let parents = name_siblings
    3              0.000003     endif
                            
    3              0.000010     if empty(parents)
                                    " No parents found, so either the parent is a pseudotag or it hasn't
                                    " been processed yet. Create a pseudotag as a placeholder; if the
                                    " actual parent gets processed later it will get replaced.
                                    if empty(a:pathlist)
                                        let pseudokind = a:taginfo.typeinfo.scope2kind[a:taginfo.scope]
                                    else
                                        let pseudokind = '?'
                                    endif
                                    let parent = s:create_pseudotag(parentname, grandparent, pseudokind, a:taginfo.typeinfo, a:taginfo.fileinfo)
                                    if empty(grandparent)
                                        call a:taginfo.fileinfo.addTag(parent)
                                    else
                                        call grandparent.addChild(parent)
                                    endif
    3              0.000011     elseif len(parents) == 1
    3              0.000012         let parent = parents[0]
                                else
                                    " If there are multiple possible parents (c.f. issue #139, or tags
                                    " with the same name but a different kind) then we will pick the one
                                    " that is closest above the current tag as a heuristic.
                            
                                    " Start at line 0 so that pseudotags get included
                                    let minline = 0
                                    for candidate in parents
                                        " If the line number of the current tag is 0 then we have no way
                                        " of determining the best candidate by comparing line numbers.
                                        " Just use the first one we have.
                                        if a:taginfo.fields.line == 0
                                            let parent = candidate
                                            break
                                        endif
                            
                                        if candidate.fields.line <= a:taginfo.fields.line && candidate.fields.line >= minline
                                            let parent = candidate
                                            let minline = candidate.fields.line
                                        endif
                                    endfor
                            
                                    if !exists('parent')
                                        " If we still haven't found a parent it must be below the current
                                        " tag, so find the closest parent below the tag. This can happen
                                        " for example in Go.
                                        let maxline = line('$')
                                        for candidate in parents
                                            if candidate.fields.line >= a:taginfo.fields.line && candidate.fields.line <= maxline
                                                let parent = candidate
                                                let maxline = candidate.fields.line
                                            endif
                                        endfor
                                    endif
    3              0.000002     endif
                            
                                " If the parent is a pseudotag it may have gotten created as an in-between
                                " tag without proper information about its kind because all if its
                                " children are also pseudotags, so it may be incorrect. If the current tag
                                " is a direct child of a pseudotag then we can derive the correct kind, so
                                " replace it if necessary.
    3   0.000066   0.000056     if parent.isPseudoTag() && empty(a:pathlist)
                                    let parentkind = a:taginfo.typeinfo.scope2kind[a:taginfo.scope]
                                    if parent.fields.kind ==# '?' || parentkind !=# parent.fields.kind
                                        let parent.fields.kind = parentkind
                                        call parent.initFoldState(s:known_files)
                                    endif
    3              0.000002     endif
                            
    3              0.000033     call s:add_tag_recursive(parent, a:taginfo, a:pathlist)

FUNCTION  <SNR>108_Python2Syntax()
    Defined: ~\AppData\Local\nvim-data\plugged\vim-polyglot\syntax\python.vim:32
Called 12 times
Total time:   0.000901
 Self time:   0.000602

count  total (s)   self (s)
   12              0.000144     if exists('b:python_version_2')
                                    return b:python_version_2
   12              0.000026     endif
   12   0.000612   0.000313     return s:Enabled('g:python_version_2')

FUNCTION  <SNR>138_IsValidFile()
    Defined: ~\AppData\Local\nvim-data\plugged\tagbar\autoload\tagbar.vim:3403
Called 407 times
Total time:   0.490176
 Self time:   0.478251

count  total (s)   self (s)
  407   0.024457   0.013020     call tagbar#debug#log('Checking if file is valid [' . a:fname . ']')
                            
  407              0.004318     if a:fname ==# '' || a:ftype ==# ''
    2   0.000083   0.000040         call tagbar#debug#log('Empty filename or type')
    2              0.000009         return 0
  405              0.000712     endif
                            
  405              0.166792     if !filereadable(a:fname) && getbufvar(a:fname, 'netrw_tmpfile') ==# ''
   10   0.000969   0.000523         call tagbar#debug#log('File not readable')
   10              0.000056         return 0
  395              0.000941     endif
                            
  395              0.113970     if getbufvar(a:fname, 'tagbar_ignore') == 1
                                    call tagbar#debug#log('File is marked as ignored')
                                    return 0
  395              0.000761     endif
                            
  395              0.101358     let winnr = bufwinnr(a:fname)
  395              0.008854     if winnr != -1 && getwinvar(winnr, '&diff')
                                    call tagbar#debug#log('Window is in diff mode')
                                    return 0
  395              0.000878     endif
                            
  395              0.002108     if &previewwindow
                                    call tagbar#debug#log('In preview window')
                                    return 0
  395              0.000637     endif
                            
  395              0.005904     if !has_key(s:known_types, a:ftype)
                                    if exists('g:tagbar_type_' . a:ftype)
                                        " Filetype definition must have been specified in an 'ftplugin'
                                        " file, so load it now
                                        call s:LoadUserTypeDefs(a:ftype)
                                    else
                                        call tagbar#debug#log('Unsupported filetype: ' . a:ftype)
                                        return 0
                                    endif
  395              0.000679     endif
                            
  395              0.001532     return 1

FUNCTION  <SNR>138_RenderContent()
    Defined: ~\AppData\Local\nvim-data\plugged\tagbar\autoload\tagbar.vim:1903
Called 5 times
Total time:   0.065070
 Self time:   0.010055

count  total (s)   self (s)
    5   0.000343   0.000166     call tagbar#debug#log('RenderContent called')
    5              0.000039     let s:new_window = 0
                            
    5              0.000024     if a:0 == 1
    4              0.000030         let fileinfo = a:1
    1              0.000001     else
    1   0.000129   0.000025         let fileinfo = tagbar#state#get_current_file(0)
    5              0.000010     endif
                            
    5              0.000039     if empty(fileinfo)
                                    call tagbar#debug#log('Empty fileinfo, returning')
                                    return
    5              0.000008     endif
                            
    5   0.002529   0.002351     let tagbarwinnr = bufwinnr(s:TagbarBufName())
                            
    5              0.000060     if &filetype ==# 'tagbar'
    2              0.000012         let in_tagbar = 1
    3              0.000007     else
    3              0.000017         let in_tagbar = 0
    3              0.000028         let prevwinnr = winnr()
                            
                                    " Get the previous window number, so that we can reproduce
                                    " the window entering history later. Do not run autocmd on
                                    " this command, make sure nothing is interfering.
                                    " let pprevwinnr = winnr('#') " Messes up windows for some reason
    3   0.001009   0.000101         call s:goto_win('p', 1)
    3              0.000034         let pprevwinnr = winnr()
    3   0.000751   0.000092         call s:goto_win(tagbarwinnr, 1)
    5              0.000009     endif
                            
    5   0.001326   0.000296     if !empty(tagbar#state#get_current_file(0)) && fileinfo.fpath ==# tagbar#state#get_current_file(0).fpath
                                    " We're redisplaying the same file, so save the view
    5   0.000281   0.000145         call tagbar#debug#log('Redisplaying file [' . fileinfo.fpath . ']')
    5              0.000051         let saveline = line('.')
    5              0.000042         let savecol  = col('.')
    5              0.000052         let topline  = line('w0')
    5              0.000009     endif
                            
    5              0.000042     let lazyredraw_save = &lazyredraw
    5   0.000117   0.000096     set lazyredraw
    5              0.000043     let eventignore_save = &eventignore
    5              0.000076     set eventignore=all
                            
    5              0.000049     setlocal modifiable
                            
    5              0.001656     silent %delete _
                            
    5   0.003495   0.000329     call s:PrintHelp()
                            
    5              0.000062     let typeinfo = fileinfo.typeinfo
                            
    5              0.000041     if fileinfo.fsize_exceeded == 1
                                    if g:tagbar_compact
                                        silent 0put ='\" File size [' . fileinfo.fsize . 'B] exceeds limit'
                                    else
                                        silent put ='\" File size exceeds defined limit'
                                        silent put ='\"   File Size [' . fileinfo.fsize . ' bytes]'
                                        silent put ='\"   Limit     [' . g:tagbar_file_size_limit . ' bytes]'
                                        silent put ='\" Use TagbarForceUpdate override'
                                    endif
    5   0.000315   0.000262     elseif !empty(fileinfo.getTags())
                                    " Print tags
    5   0.046294   0.000269         call s:PrintKinds(typeinfo, fileinfo)
                                else
                                    call tagbar#debug#log('No tags found, skipping printing.')
                                    if g:tagbar_compact && s:short_help
                                        silent 0put ='\" No tags found.'
                                    else
                                        silent  put ='\" No tags found.'
                                    endif
    5              0.000007     endif
                            
                                " Delete empty lines at the end of the buffer
   10              0.000156     for linenr in range(line('$'), 1, -1)
   10              0.000232         if getline(linenr) =~# '^$'
    5              0.000313             execute 'silent ' . linenr . 'delete _'
    5              0.000010         else
    5              0.000012             break
    5              0.000009         endif
   10              0.000048     endfor
                            
    5              0.000108     setlocal nomodifiable
                            
    5   0.001420   0.000346     if !empty(tagbar#state#get_current_file(0)) && fileinfo.fpath ==# tagbar#state#get_current_file(0).fpath
    5              0.000055         let scrolloff_save = &scrolloff
    5              0.000094         setlocal scrolloff=0
                            
    5              0.000059         call cursor(topline, 1)
    5              0.000285         normal! zt
    5              0.000053         call cursor(saveline, savecol)
                            
    5              0.000110         let &l:scrolloff = scrolloff_save
                                else
                                    " Make sure as much of the Tagbar content as possible is shown in the
                                    " window by jumping to the top after drawing
                                    execute 1
                                    call winline()
                            
                                    " Invalidate highlight cache from old file
                                    let s:last_highlight_tline = 0
    5              0.000009     endif
                            
    5              0.000069     let &lazyredraw  = lazyredraw_save
    5   0.000096   0.000086     let &eventignore = eventignore_save
                            
    5              0.000037     if !in_tagbar
    3   0.000858   0.000097         call s:goto_win(pprevwinnr, 1)
    3   0.000790   0.000078         call s:goto_win(prevwinnr, 1)
    5              0.000009     endif

FUNCTION  <SNR>167_adapter()
    Defined: ~\AppData\Local\nvim-data\plugged\neoterm\autoload\neoterm\term.vim:12
Called 2 times
Total time:   0.003301
 Self time:   0.000103

count  total (s)   self (s)
    2   0.003296   0.000098   return get(g:neoterm, 'adapter', s:set_adapter())

FUNCTION  <SNR>21_sortByLength()
    Defined: ~\AppData\Local\nvim-data\plugged\auto-pairs\plugin\auto-pairs.vim:467
Called 196 times
Total time:   0.002647
 Self time:   0.002647

count  total (s)   self (s)
  196              0.002353   return len(a:i2[0])-len(a:i1[0])

FUNCTION  CreateSidePanel()
    Defined: ~\AppData\Local\nvim\myPlugins\SidePannel.vim:4
Called 2 times
Total time:   0.129133
 Self time:   0.014459

count  total (s)   self (s)
                                "-------------------------------------------
    2              0.000041     if exists(':GuiPopupmenu')
                                    exec "GuiPopupmenu 0"
                                    set guioptions-=mT
    2              0.000003     endif
                                "-------------------------------------------
    2              0.000009     if t:SidePanelInUse == 1
                                    "let g:width = winwidth(1)
    1   0.055914   0.014012         execute "vertical split enew"
    1              0.000035         execute a:width . " wincmd |"
    1              0.000014         let b:CloseThisWindowIfItsLonely = 1    " re-label this variable to be named after your plugin
    1   0.000206   0.000030         setlocal nobuflisted
    1   0.000023   0.000018         setlocal noswapfile
    1   0.000038   0.000029         setlocal bufhidden="wipe"
    1   0.000018   0.000017         setlocal foldcolumn=1
    1   0.000017   0.000016         set winfixwidth
    1   0.000018   0.000014         setlocal nomodifiable
    1   0.000015   0.000014         set buftype=nofile
    1   0.000053   0.000045         set nonumber norelativenumber nocursorline nocursorcolumn
    1   0.072645   0.000081         execute "winc l"
    1              0.000012         let t:SidePanelInUse = 1
    2              0.000003     endif
                                "-------------------------------------------
                            

FUNCTION  neoterm#load_session()
    Defined: ~\AppData\Local\nvim-data\plugged\neoterm\autoload\neoterm.vim:30
Called 1 time
Total time:   0.000427
 Self time:   0.000138

count  total (s)   self (s)
    1   0.000353   0.000065   let l:id = neoterm#term#current_id()
                            
    1              0.000035   if get(g:, 'SessionLoad', 0) && index(g:neoterm.ids(), l:id) < 0
                                call neoterm#new({'from_session': 1, 'id': l:id, 'termid': l:id})
    1              0.000003   end

FUNCTION  <SNR>166_set_instance_opts()
    Defined: ~\AppData\Local\nvim-data\plugged\neoterm\autoload\neoterm\target.vim:51
Called 6 times
Total time:   0.000739
 Self time:   0.000739

count  total (s)   self (s)
    6              0.000061   if empty(a:instance)
    1              0.000005     return a:instance
    5              0.000022   end
                            
   10              0.000260   for [key, value] in items(a:opts)
    5              0.000059     if !empty(value)
                                  let a:instance[key] = value
    5              0.000016     end
   10              0.000049   endfor
                            
    5              0.000036   return a:instance

FUNCTION  remote#define#AutocmdBootstrap()
    Defined: ~\scoop\apps\neovim\0.6.1\share\nvim\runtime\autoload\remote\define.vim:107
Called 1 time
Total time:   0.003148
 Self time:   0.000667

count  total (s)   self (s)
    1   0.000220   0.000068   let channel = remote#host#Require(a:host)
                            
    1              0.000271   exe 'autocmd! '.a:opts.group
    1              0.000012   if channel
    1   0.000767   0.000108     call remote#define#AutocmdOnChannel(channel, a:method, a:sync, a:name, a:opts)
    1   0.001842   0.000172     exe eval(a:forward)
                              else
                                exe 'augroup! '.a:opts.group
                                echoerr 'Host "'a:host.'" for "'.a:name.'" autocmd is not available'
    1              0.000002   endif

FUNCTION  <SNR>138_Init()
    Defined: ~\AppData\Local\nvim-data\plugged\tagbar\autoload\tagbar.vim:209
Called 1 time
Total time:   1.286510
 Self time:   0.000733

count  total (s)   self (s)
    1              0.000016     if s:checked_ctags == 2 && a:silent
                                    return 0
    1              0.000008     elseif s:checked_ctags != 1
    1   0.171543   0.000105         if !s:CheckForExCtags(a:silent)
                                        return 0
    1              0.000004         endif
    1              0.000003     endif
                            
    1              0.000008     if !s:type_init_done
    1   0.557443   0.000075         call s:InitTypes()
    1              0.000002     endif
                            
    1              0.000005     if !s:autocommands_done
    1   0.001097   0.000047         call s:CreateAutocommands()
    1   0.556303   0.000381         call s:AutoUpdate(fnamemodify(expand('%'), ':p'), 0)
    1              0.000002     endif
                            
    1              0.000008     let s:init_done = 1
    1              0.000003     return 1

FUNCTION  <SNR>138_CreateAutocommands()
    Defined: ~\AppData\Local\nvim-data\plugged\tagbar\autoload\tagbar.vim:545
Called 1 time
Total time:   0.001050
 Self time:   0.001019

count  total (s)   self (s)
    1   0.000097   0.000066     call tagbar#debug#log('Creating autocommands')
                            
    1              0.000010     augroup TagbarAutoCmds
    1              0.000193         autocmd!
                            
    1              0.000036         autocmd BufEnter * if expand('<amatch>') !~ '__Tagbar__.*' |     let s:last_alt_bufnr = bufnr('#') | endif
    1              0.000014         if exists('##QuitPre')
    1              0.000017             autocmd QuitPre * let s:vim_quitting = 1
    1              0.000002         endif
    1              0.000025         autocmd WinEnter * nested call s:HandleOnlyWindow()
                            
    1              0.000006         if !g:tagbar_no_autocmds
    1              0.000005             if !g:tagbar_silent
    1              0.000033                 autocmd CursorHold __Tagbar__.* call s:ShowPrototype(1)
    1              0.000002             endif
    1              0.000030             autocmd WinEnter   __Tagbar__.* call s:SetStatusLine()
    1              0.000032             autocmd WinLeave   __Tagbar__.* call s:SetStatusLine()
                            
    1              0.000056             if g:tagbar_show_balloon == 1 && has('balloon_eval')
                                            autocmd WinEnter __Tagbar__.* let s:beval = &beval | set ballooneval
                                            autocmd WinLeave __Tagbar__.* if exists("s:beval") |   let &beval = s:beval | endif
    1              0.000002             endif
                            
    1              0.000004             if g:tagbar_autopreview
                                            autocmd CursorMoved __Tagbar__.* nested call s:ShowInPreviewWin()
    1              0.000001             endif
                            
    1              0.000027             autocmd WinEnter * if bufwinnr(s:TagbarBufName()) == -1 |     call s:ShrinkIfExpanded() | endif
                            
    1              0.000019             autocmd BufWritePost * call s:HandleBufWrite(fnamemodify(expand('<afile>'), ':p'))
    1              0.000043             autocmd CursorHold,CursorHoldI * call s:do_delayed_update()
                                        " BufReadPost is needed for reloading the current buffer if the file
                                        " was changed by an external command; see commit 17d199f
    1              0.000055             autocmd BufReadPost,BufEnter,CursorHold,FileType * call s:AutoUpdate(fnamemodify(expand('<afile>'), ':p'), 0)
    1              0.000005             if g:tagbar_highlight_follow_insert
                                            autocmd CursorHoldI * call s:AutoUpdate(fnamemodify(expand('<afile>'), ':p'), 0)
    1              0.000002             endif
                            
                                        " Suspend Tagbar while grep commands are running, since we don't want
                                        " to process files that only get loaded temporarily to search them
    1              0.000030             autocmd QuickFixCmdPre  *grep* let s:tagbar_qf_active = 1
    1              0.000026             autocmd QuickFixCmdPost *grep* if exists('s:tagbar_qf_active') |     unlet s:tagbar_qf_active | endif
                            
    1              0.000023             autocmd VimEnter * call s:CorrectFocusOnStartup()
    1              0.000002         endif
    1              0.000005     augroup END
                            
                                " Separate these autocmds out from the others as we want to always perform
                                " these actions even if the tagbar window closes.
    1              0.000004     augroup TagbarCleanupAutoCmds
    1              0.000125         autocmd!
                            
    1              0.000005         if !g:tagbar_no_autocmds
    1              0.000043             autocmd BufDelete,BufWipeout * nested call s:HandleBufDelete(expand('<afile>'), expand('<abuf>'))
    1              0.000002         endif
    1              0.000004     augroup END
                            
    1              0.000008     let s:autocommands_done = 1

FUNCTION  tagbar#debug#enabled()
    Defined: ~\AppData\Local\nvim-data\plugged\tagbar\autoload\tagbar\debug.vim:46
Called 83 times
Total time:   0.000821
 Self time:   0.000821

count  total (s)   self (s)
   83              0.000619     return s:debug_enabled

FUNCTION  SemshiBufEnter()
    Defined: ~\scoop\apps\neovim\0.6.1\share\nvim\runtime\autoload\remote\define.vim:169
Called 30 times
Total time:   0.131718
 Self time:   0.002462

count  total (s)   self (s)
   30   0.131557   0.002300 return remote#define#request(5, "C:/Users/Lenovo/AppData/Local/nvim-data/plugged/semshi/rplugin/python3/semshi:function:SemshiBufEnter", a:000)

FUNCTION  227()
    Defined: ~\AppData\Local\nvim-data\plugged\nerdtree\lib\nerdtree\nerdtree.vim:140
Called 347 times
Total time:   0.108570
 Self time:   0.102369

count  total (s)   self (s)
  347              0.005339     if exists('t:NERDTreeBufName')
                                    return bufwinnr(t:NERDTreeBufName)
  347              0.000967     endif
                            
                                " If WindowTree, there is no t:NERDTreeBufName variable. Search all windows.
  978              0.016698     for w in range(1,winnr('$'))
  631   0.055336   0.049135         if bufname(winbufnr(w)) =~# '^' . g:NERDTreeCreator.BufNamePrefix() . '\d\+$'
                                        return w
  631              0.001779         endif
  978              0.003729     endfor
                            
  347              0.001708     return -1

FUNCTION  228()
    Defined: ~\AppData\Local\nvim-data\plugged\nerdtree\lib\nerdtree\nerdtree.vim:156
Called 347 times
Total time:   0.120502
 Self time:   0.011931

count  total (s)   self (s)
  347   0.119490   0.010919     return s:NERDTree.GetWinNum() !=# -1

FUNCTION  <SNR>74_GetRpcFunction()
    Defined: ~\scoop\apps\neovim\0.6.1\share\nvim\runtime\autoload\remote\define.vim:175
Called 1 time
Total time:   0.000039
 Self time:   0.000039

count  total (s)   self (s)
    1              0.000011   if a:sync ==# 'urgent'
                                return 'rpcnotify'
    1              0.000008   elseif a:sync
    1              0.000008     return 'remote#define#request'
                              endif
                              return 'remote#define#notify'

FUNCTION  <SNR>21_ExpandMap()
    Defined: ~\AppData\Local\nvim-data\plugged\auto-pairs\plugin\auto-pairs.vim:596
Called 7 times
Total time:   0.000603
 Self time:   0.000603

count  total (s)   self (s)
    7              0.000046   let map = a:map
    7              0.000263   let map = substitute(map, '\(<Plug>\w\+\)', '\=maparg(submatch(1), "i")', 'g')
    7              0.000234   let map = substitute(map, '\(<Plug>([^)]*)\)', '\=maparg(submatch(1), "i")', 'g')
    7              0.000031   return map

FUNCTION  <SNR>138_HandleOnlyWindow()
    Defined: ~\AppData\Local\nvim-data\plugged\tagbar\autoload\tagbar.vim:3500
Called 23 times
Total time:   0.017575
 Self time:   0.016569

count  total (s)   self (s)
   23   0.016517   0.015511     let tagbarwinnr = bufwinnr(s:TagbarBufName())
   23              0.000252     if tagbarwinnr == -1
   17              0.000067         return
    6              0.000008     endif
                            
    6              0.000034     let vim_quitting = s:vim_quitting
    6              0.000024     let s:vim_quitting = 0
                            
    6              0.000048     if vim_quitting && !s:HasOpenFileWindows()
                                    call tagbar#debug#log('Closing Tagbar window due to QuitPre event')
                                    if winnr('$') >= 1
                                        call s:goto_win(tagbarwinnr, 1)
                                    endif
                            
                                    " Before quitting Vim, delete the tagbar buffer so that the '0 mark is
                                    " correctly set to the previous buffer.
                                    if tabpagenr('$') == 1
                                        noautocmd keepalt bdelete
                                    endif
                            
                                    try
                                        try
                                            quit
                                        catch /.*/ " This can be E173 and maybe others
                                            call s:OpenWindow('')
                                            echoerr v:exception
                                        endtry
                                    catch /.*/
                                        echohl ErrorMsg
                                        echo v:exception
                                        echohl None
                                    endtry
    6              0.000008     endif

FUNCTION  remote#define#AutocmdOnChannel()
    Defined: ~\scoop\apps\neovim\0.6.1\share\nvim\runtime\autoload\remote\define.vim:122
Called 1 time
Total time:   0.000659
 Self time:   0.000344

count  total (s)   self (s)
    1              0.000031   let rpcargs = [a:channel, '"'.a:method.'"']
    1   0.000143   0.000055   call s:AddEval(rpcargs, a:opts)
                            
    1   0.000373   0.000147   let autocmd_def = s:GetAutocmdPrefix(a:name, a:opts) . ' call '.s:GetRpcFunction(a:sync).'('.join(rpcargs, ', ').')'
    1              0.000100   exe autocmd_def

FUNCTION  <SNR>143_strfmt()
    Defined: ~\AppData\Local\nvim-data\plugged\tagbar\autoload\tagbar\prototypes\normaltag.vim:28
Called 60 times
Total time:   0.019447
 Self time:   0.011916

count  total (s)   self (s)
   60              0.000438     let typeinfo = self.typeinfo
                            
   60              0.000743     let suffix = get(self.fields, 'signature', '')
   60              0.000469     if has_key(self.fields, 'type')
                                    let suffix .= ' : ' . self.fields.type
   60              0.001139     elseif has_key(get(typeinfo, 'kind2scope', {}), self.fields.kind)
   15   0.001337   0.000769         let scope = s:maybe_map_scope(typeinfo.kind2scope[self.fields.kind])
   15              0.000082         if !g:tagbar_show_data_type
   15              0.000160             let suffix .= ' : ' . scope
   15              0.000026         endif
   60              0.000090     endif
   60   0.008924   0.001962     let prefix = self._getPrefix()
                            
   60              0.000599     if g:tagbar_show_data_type && self.getDataType() !=# ''
                                    let suffix .= ' : ' . self.getDataType()
   60              0.000093     endif
                            
   60              0.000377     if g:tagbar_show_tag_linenumbers == 1
   60              0.000707         let suffix .= ' [' . self.fields.line . ']'
                                elseif g:tagbar_show_tag_linenumbers == 2
                                    let prefix .= '[' . self.fields.line . '] '
   60              0.000096     endif
                            
   60              0.000562     return prefix . self.name . suffix

FUNCTION  <SNR>166_get()
    Defined: ~\AppData\Local\nvim-data\plugged\neoterm\autoload\neoterm\target.vim:9
Called 6 times
Total time:   0.001498
 Self time:   0.000878

count  total (s)   self (s)
    6              0.000083   if a:opts.target > 0
                                return s:given_target(a:opts.target)
    6              0.000048   elseif g:neoterm_term_per_tab
                                return s:target_per_tab()
    6   0.000301   0.000189   elseif g:neoterm.has_any()
    5   0.000820   0.000312     return s:ensure_instance(g:neoterm.last())
    1              0.000003   else
    1              0.000006     return {}
                              end

FUNCTION  semshi#buffer_attach()
    Defined: ~\AppData\Local\nvim-data\plugged\semshi\plugin\semshi.vim:76
Called 2 times
Total time:   0.012804
 Self time:   0.001211

count  total (s)   self (s)
    2              0.000067     if get(b:, 'semshi_attached', v:false)
                                    return
    2              0.000007     endif
    2              0.000028     let b:semshi_attached = v:true
    2              0.000023     augroup SemshiEvents
    2              0.000462         autocmd! * <buffer>
    2              0.000041         autocmd BufEnter <buffer> call SemshiBufEnter(+expand('<abuf>'), line('w0'), line('w$'))
    2              0.000029         autocmd BufLeave <buffer> call SemshiBufLeave()
    2              0.000050         autocmd VimResized <buffer> call SemshiVimResized(line('w0'), line('w$'))
    2              0.000097         autocmd TextChanged <buffer> call SemshiTextChanged()
    2              0.000062         autocmd TextChangedI <buffer> call SemshiTextChanged()
    2              0.000100         autocmd CursorMoved <buffer> call SemshiCursorMoved(line('w0'), line('w$'))
    2              0.000060         autocmd CursorMovedI <buffer> call SemshiCursorMoved(line('w0'), line('w$'))
    2              0.000008     augroup END
    2   0.011721   0.000128     call SemshiBufEnter(bufnr('%'), line('w0'), line('w$'))

FUNCTION  <SNR>21_ulen()
    Defined: ~\AppData\Local\nvim-data\plugged\auto-pairs\plugin\auto-pairs.vim:119
Called 30 times
Total time:   0.001394
 Self time:   0.001394

count  total (s)   self (s)
   30              0.001329   return len(split(a:s, '\zs'))

FUNCTION  <SNR>144_add_snr()
    Defined: ~\AppData\Local\nvim-data\plugged\tagbar\autoload\tagbar\prototypes\basetag.vim:240
Called 11438 times
Total time:   0.307385
 Self time:   0.307385

count  total (s)   self (s)
11438              0.084244     if !exists('s:snr')
    1              0.000109         let s:snr = matchstr(expand('<sfile>'), '<SNR>\d\+_\zeget_snr$')
11438              0.017684     endif
11438              0.064687     return s:snr . a:funcname

FUNCTION  <SNR>138_HandleBufWrite()
    Defined: ~\AppData\Local\nvim-data\plugged\tagbar\autoload\tagbar.vim:3593
Called 19 times
Total time:   0.001677
 Self time:   0.001677

count  total (s)   self (s)
   19              0.000914     if index(s:delayed_update_files, a:fname) == -1
   19              0.000473         call add(s:delayed_update_files, a:fname)
   19              0.000092     endif

FUNCTION  <SNR>142_getTags()
    Defined: ~\AppData\Local\nvim-data\plugged\tagbar\autoload\tagbar\prototypes\fileinfo.vim:80
Called 105 times
Total time:   0.000758
 Self time:   0.000758

count  total (s)   self (s)
  105              0.000579     return self._taglist

FUNCTION  polyglot#init#is_disabled()
    Defined: ~\AppData\Local\nvim-data\plugged\vim-polyglot\autoload\polyglot\init.vim:23
Called 45 times
Total time:   0.005889
 Self time:   0.005889

count  total (s)   self (s)
   45              0.000838   if !g:polyglot_initialized
   45              0.000982     if a:path[0:7] == "autoload"
                                  let g:polyglot_initialized = 1
                            
                                  for p in globpath(&rtp, a:path, 0, 1)
                                    if p != a:caller
                                      exe "source " . p
                                    endif
                                  endfor
   45              0.000112     endif
   45              0.000133   endif
                            
   45              0.000851   return has_key(g:polyglot_is_disabled, a:name)

FUNCTION  <SNR>143_maybe_map_scope()
    Defined: ~\AppData\Local\nvim-data\plugged\tagbar\autoload\tagbar\prototypes\normaltag.vim:1
Called 15 times
Total time:   0.000568
 Self time:   0.000568

count  total (s)   self (s)
   15              0.000157     if !empty(g:tagbar_scopestrs)
                                    if has_key(g:tagbar_scopestrs, a:scopestr)
                                        return g:tagbar_scopestrs[a:scopestr]
                                    endif
   15              0.000021     endif
   15              0.000069     return a:scopestr

FUNCTION  <SNR>138_GetSupportedFiletypes()
    Defined: ~\AppData\Local\nvim-data\plugged\tagbar\autoload\tagbar.vim:790
Called 1 time
Total time:   0.161091
 Self time:   0.003123

count  total (s)   self (s)
    1   0.000042   0.000021     call tagbar#debug#log('Getting filetypes supported by Exuberant Ctags')
                            
    1   0.001618   0.000039     let ctags_cmd = s:EscapeCtagsCmd(g:tagbar_ctags_bin, '--list-languages')
    1              0.000009     if ctags_cmd ==# ''
                                    return
    1              0.000002     endif
                            
    1   0.156429   0.000060     let ctags_output = s:ExecuteCtags(ctags_cmd)
                            
    1              0.000008     if v:shell_error
                                    " this shouldn't happen as potential problems would have already been
                                    " caught by the previous ctags checking
                                    return
    1              0.000003     endif
                            
    1              0.000199     let types = split(ctags_output, '\n\+')
                            
    1              0.000017     let supported_types = {}
   43              0.000261     for type in types
   42              0.001174         if match(type, '\[disabled\]') == -1
   42              0.000883             let supported_types[tolower(type)] = 1
   42              0.000122         endif
   43              0.000178     endfor
                            
    1              0.000011     return supported_types

FUNCTION  tagbar#prototypes#basetag#new()
    Defined: ~\AppData\Local\nvim-data\plugged\tagbar\autoload\tagbar\prototypes\basetag.vim:10
Called 602 times
Total time:   0.800061
 Self time:   0.492676

count  total (s)   self (s)
  602              0.004680     let newobj = {}
                            
  602              0.004873     let newobj.name          = a:name
  602              0.003932     let newobj.fields        = {}
  602              0.003580     let newobj.fields.line   = 0
  602              0.003170     let newobj.fields.column = 0
  602              0.003146     let newobj.fields.end    = 0
  602              0.003667     let newobj.prototype     = ''
  602              0.003054     let newobj.data_type     = ''
  602              0.002979     let newobj.path          = ''
  602              0.003892     let newobj.fullpath      = a:name
  602              0.002862     let newobj.depth         = 0
  602              0.003349     let newobj.parent        = {}
  602              0.003145     let newobj.tline         = -1
  602              0.003511     let newobj.fileinfo      = {}
  602              0.003138     let newobj.typeinfo      = {}
  602              0.003958     let newobj._childlist    = []
  602              0.003491     let newobj._childdict    = {}
                            
  602   0.050371   0.028083     let newobj.isNormalTag = function(s:add_snr('s:isNormalTag'))
  602   0.042377   0.024449     let newobj.isPseudoTag = function(s:add_snr('s:isPseudoTag'))
  602   0.038578   0.021895     let newobj.isSplitTag = function(s:add_snr('s:isSplitTag'))
  602   0.037734   0.021651     let newobj.isKindheader = function(s:add_snr('s:isKindheader'))
  602   0.036621   0.020694     let newobj.getPrototype = function(s:add_snr('s:getPrototype'))
  602   0.035721   0.020465     let newobj.getDataType = function(s:add_snr('s:getDataType'))
  602   0.036564   0.021173     let newobj._getPrefix = function(s:add_snr('s:_getPrefix'))
  602   0.036530   0.020932     let newobj.initFoldState = function(s:add_snr('s:initFoldState'))
  602   0.037481   0.022130     let newobj.getClosedParentTline = function(s:add_snr('s:getClosedParentTline'))
  602   0.035972   0.020878     let newobj.isFoldable = function(s:add_snr('s:isFoldable'))
  602   0.035906   0.020718     let newobj.isFolded = function(s:add_snr('s:isFolded'))
  602   0.035710   0.020241     let newobj.openFold = function(s:add_snr('s:openFold'))
  602   0.039568   0.020532     let newobj.closeFold = function(s:add_snr('s:closeFold'))
  602   0.039243   0.023843     let newobj.setFolded = function(s:add_snr('s:setFolded'))
  602   0.036311   0.020741     let newobj.openParents = function(s:add_snr('s:openParents'))
  602   0.035085   0.019727     let newobj.addChild = function(s:add_snr('s:addChild'))
  602   0.035167   0.020161     let newobj.getChildren = function(s:add_snr('s:getChildren'))
  602   0.037388   0.022049     let newobj.getChildrenByName = function(s:add_snr('s:getChildrenByName'))
  602   0.036066   0.020645     let newobj.removeChild = function(s:add_snr('s:removeChild'))
                            
  602              0.002303     return newobj

FUNCTION  <SNR>138_TagbarBufName()
    Defined: ~\AppData\Local\nvim-data\plugged\tagbar\autoload\tagbar.vim:3652
Called 824 times
Total time:   0.030704
 Self time:   0.030704

count  total (s)   self (s)
  824              0.010849     if !exists('t:tagbar_buf_name')
    2              0.000022         let s:buffer_seqno += 1
    2              0.000027         let t:tagbar_buf_name = '__Tagbar__.' . s:buffer_seqno
  824              0.001408     endif
                            
  824              0.004732     return t:tagbar_buf_name

FUNCTION  neoterm#origin#new()
    Defined: ~\AppData\Local\nvim-data\plugged\neoterm\autoload\neoterm\origin.vim:1
Called 1 time
Total time:   0.000052
 Self time:   0.000052

count  total (s)   self (s)
    1              0.000048   return { 'win_id': exists('*win_getid') ? win_getid() : 0, 'last_buffer_id': bufnr('#') }

FUNCTION  <SNR>142_getTagsByName()
    Defined: ~\AppData\Local\nvim-data\plugged\tagbar\autoload\tagbar\prototypes\fileinfo.vim:85
Called 394 times
Total time:   0.006409
 Self time:   0.006409

count  total (s)   self (s)
  394              0.005523     return get(self._tagdict, a:tagname, [])

FUNCTION  <SNR>144__getPrefix()
    Defined: ~\AppData\Local\nvim-data\plugged\tagbar\autoload\tagbar\prototypes\basetag.vim:84
Called 60 times
Total time:   0.006962
 Self time:   0.006962

count  total (s)   self (s)
   60              0.000416     let fileinfo = self.fileinfo
                            
   60              0.000476     if !empty(self._childlist)
                                    if fileinfo.tagfolds[self.fields.kind][self.fullpath]
                                        let prefix = g:tagbar#icon_closed
                                    else
                                        let prefix = g:tagbar#icon_open
                                    endif
   60              0.000104     else
   60              0.000284         let prefix = ' '
   60              0.000095     endif
                                " Visibility is called 'access' in the ctags output
   60              0.000279     if g:tagbar_show_visibility
   60              0.000482         if has_key(self.fields, 'access')
   15              0.000252             let prefix .= get(s:visibility_symbols, self.fields.access, ' ')
   45              0.000318         elseif has_key(self.fields, 'file')
                                        let prefix .= s:visibility_symbols.private
   45              0.000072         else
   45              0.000264             let prefix .= ' '
   60              0.000126         endif
   60              0.000089     endif
                            
   60              0.000268     return prefix

FUNCTION  neoterm#repl#set()
    Defined: ~\AppData\Local\nvim-data\plugged\neoterm\autoload\neoterm\repl.vim:51
Called 2 times
Total time:   0.000122
 Self time:   0.000122

count  total (s)   self (s)
    2              0.000033   if type(a:value) == v:t_list
                                let g:neoterm_repl_command = add(a:value, g:neoterm_eof)
    2              0.000006   else
    2              0.000046     let g:neoterm_repl_command = [a:value, g:neoterm_eof]
    2              0.000004   endif

FUNCTION  <SNR>144_isSplitTag()
    Defined: ~\AppData\Local\nvim-data\plugged\tagbar\autoload\tagbar\prototypes\basetag.vim:64
Called 394 times
Total time:   0.002698
 Self time:   0.002698

count  total (s)   self (s)
  394              0.001702     return 0

FUNCTION  dashboard#change_to_dir()
    Defined: ~\AppData\Local\nvim-data\plugged\dashboard-nvim\autoload\dashboard.vim:216
Called 3 times
Total time:   0.000135
 Self time:   0.000135

count  total (s)   self (s)
    3              0.000049   if get(g:, 'dashboard_change_to_dir', 0)
                                let dir = fnamemodify(a:path, ':h')
                                if isdirectory(dir)
                                  echom "test"
                                  execute 'lcd' dir
                                else
                                    " Do nothing. E.g. a:path == `scp://foo/bar`
                                endif
    3              0.000004   endif

FUNCTION  polyglot#sleuth#GlobForFiletype()
    Defined: ~\AppData\Local\nvim-data\plugged\vim-polyglot\autoload\polyglot\sleuth.vim:639
Called 5 times
Total time:   0.000094
 Self time:   0.000094

count  total (s)   self (s)
    5              0.000076   return get(s:globs, a:type, '')

FUNCTION  <SNR>138_goto_win()
    Defined: ~\AppData\Local\nvim-data\plugged\tagbar\autoload\tagbar.vim:3662
Called 348 times
Total time:   0.087582
 Self time:   0.077474

count  total (s)   self (s)
                                "Do not go to a popup window to avoid errors.
                                "Hence, check first if a:winnr is an integer,
                                "if this integer is equal to 0,
                                "the window is a popup window
  348              0.020836     if has('popupwin')
                                    if type(a:winnr) == type(0) && a:winnr == 0
                                        return
                                    endif
                                    if a:winnr ==# 'p' && winnr('#') == 0
                                        return
                                    endif
  348              0.000618     endif
  348              0.007904     let cmd = type(a:winnr) == type(0) ? a:winnr . 'wincmd w' : 'wincmd ' . a:winnr
  348              0.003089     let noauto = a:0 > 0 ? a:1 : 0
                            
  348   0.021323   0.011214     call tagbar#debug#log('goto_win(): ' . cmd . ', ' . noauto)
                            
  348              0.001216     if noauto
  348              0.013827         noautocmd execute cmd
                                else
                                    execute cmd
  348              0.000552     endif

FUNCTION  <SNR>9_detect_indent()
    Defined: ~\AppData\Local\nvim-data\plugged\vim-polyglot\autoload\polyglot\init.vim:2904
Called 45 times
Total time:   1.534874
 Self time:   0.023116

count  total (s)   self (s)
   45              0.000657     if &buftype ==# 'help'
                                  return
   45              0.000110     endif
                            
                                " Do not autodetect indent if language or user sets it
   45              0.000503     if &l:shiftwidth != s:default_shiftwidth
    4              0.000011       return
   41              0.000063     endif
                            
   41              0.012843     let b:sleuth_culprit = expand("<afile>:p")
   41   1.509578   0.007219     if s:guess(getline(1, 128))
   36              0.000094       return
    5              0.000008     endif
    5   0.009533   0.000229     if s:guess(getline(1, 1024))
                                  return
    5              0.000007     endif
    5   0.000307   0.000212     let pattern = polyglot#sleuth#GlobForFiletype(&filetype)
    5              0.000044     if len(pattern) == 0
    5              0.000013       return
                                endif
                                let pattern = '{' . pattern . ',.git,.svn,.hg}'
                                let dir = expand('%:p:h')
                                let level = 3
                                while isdirectory(dir) && dir !=# fnamemodify(dir, ':h') && level > 0
                                  " Ignore files from homedir and root 
                                  if dir == expand('~') || dir == '/'
                                    unlet b:sleuth_culprit
                                    return
                                  endif
                                  for neighbor in glob(dir . '/' . pattern, 0, 1)[0:level]
                                    let b:sleuth_culprit = neighbor
                                    " Do not consider directories above .git, .svn or .hg
                                    if fnamemodify(neighbor, ":h:t")[0] == "."
                                      let level = 0
                                      continue
                                    endif
                                    if neighbor !=# expand('%:p') && filereadable(neighbor)
                                      if s:guess(readfile(neighbor, '', 32))
                                        return
                                      endif
                                    endif
                                  endfor
                            
                                  let dir = fnamemodify(dir, ':h')
                                  let level -= 1
                                endwhile
                            
                                let b:sleuth_culprit = "default"

FUNCTION  <SNR>138_get_map_str()
    Defined: ~\AppData\Local\nvim-data\plugged\tagbar\autoload\tagbar.vim:2202
Called 5 times
Total time:   0.000457
 Self time:   0.000457

count  total (s)   self (s)
    5              0.000138     let def = get(g:, 'tagbar_map_' . a:map)
    5              0.000108     if type(def) ==# type('')
                                    return def
    5              0.000014     else
    5              0.000071         return join(def, ', ')
                                endif

FUNCTION  <SNR>142_sortTags()
    Defined: ~\AppData\Local\nvim-data\plugged\tagbar\autoload\tagbar\prototypes\fileinfo.vim:129
Called 27 times
Total time:   0.116381
 Self time:   0.031012

count  total (s)   self (s)
   27              0.000370     if get(a:compare_typeinfo, 'sort', g:tagbar_sort)
                                    call tagbar#sorting#sort(self._taglist, 'kind', a:compare_typeinfo)
   27              0.000062     else
   27   0.115458   0.030089         call tagbar#sorting#sort(self._taglist, 'line', a:compare_typeinfo)
   27              0.000053     endif

FUNCTION  tagbar#getusertypes()
    Defined: ~\AppData\Local\nvim-data\plugged\tagbar\autoload\tagbar.vim:3830
Called 1 time
Total time:   0.007396
 Self time:   0.007396

count  total (s)   self (s)
    1              0.007267     let userdefs = filter(copy(g:), 'v:key =~? "^tagbar_type_"')
                            
    1              0.000015     let typedict = {}
    2              0.000029     for [key, val] in items(userdefs)
    1              0.000036         let type = substitute(key, '^tagbar_type_', '', '')
    1              0.000010         let typedict[type] = val
    2              0.000008     endfor
                            
    1              0.000006     return typedict

FUNCTION  AutoPairsInsert()
    Defined: ~\AppData\Local\nvim-data\plugged\auto-pairs\plugin\auto-pairs.vim:198
Called 26 times
Total time:   0.096427
 Self time:   0.076990

count  total (s)   self (s)
   26              0.000637   if !b:autopairs_enabled
                                return a:key
   26              0.000143   end
                            
   26              0.000924   let b:autopairs_saved_pair = [a:key, getpos('.')]
                            
   26   0.008764   0.001530   let [before, after, afterline] = s:getline()
                            
                              " Ignore auto close if prev character is \
   26              0.000315   if before[-1:-1] == '\'
                                return a:key
   26              0.000055   end
                            
                              " check open pairs
  207              0.002283   for [open, close, opt] in b:AutoPairsList
  197   0.017273   0.007278     let ms = s:matchend(before.a:key, open)
  197              0.006559     let m = matchstr(afterline, '^\v\s*\zs\V'.close)
  197              0.001901     if len(ms) > 0
                                  " process the open pair
                                  
                                  " remove inserted pair
                                  " eg: if the pairs include < > and  <!-- --> 
                                  " when <!-- is detected the inserted pair < > should be clean up 
   16              0.000137       let target = ms[1]
   16              0.000126       let openPair = ms[2]
   16              0.000212       if len(openPair) == 1 && m == openPair
                                    break
   16              0.000034       end
   16              0.000080       let bs = ''
   16              0.000080       let del = ''
   16              0.000208       while len(before) > len(target)
                                    let found = 0
                                    " delete pair
                                    for [o, c, opt] in b:AutoPairsList
                                      let os = s:matchend(before, o)
                                      if len(os) && len(os[1]) < len(target)
                                        " any text before openPair should not be deleted
                                        continue
                                      end
                                      let cs = s:matchbegin(afterline, c)
                                      if len(os) && len(cs)
                                        let found = 1
                                        let before = os[1]
                                        let afterline = cs[2]
                                        let bs = bs.s:backspace(os[2])
                                        let del = del.s:delete(cs[1])
                                        break
                                      end
                                    endfor
                                    if !found
                                      " delete charactor
                                      let ms = s:matchend(before, '\v.')
                                      if len(ms)
                                        let before = ms[1]
                                        let bs = bs.s:backspace(ms[2])
                                      end
                                    end
   16              0.000041       endwhile
   16   0.001933   0.000628       return bs.del.openPair.close.s:left(close)
  181              0.000456     end
  191              0.000600   endfor
                            
                              " check close pairs
   77              0.000743   for [open, close, opt] in b:AutoPairsList
   77              0.000429     if close == ''
                                  continue
   77              0.000128     end
   77              0.001539     if a:key == g:AutoPairsWildClosedPair || opt['mapclose'] && opt['key'] == a:key
                                  " the close pair is in the same line
   11              0.000502       let m = matchstr(afterline, '^\v\s*\V'.close)
   11              0.000072       if m != ''
   10              0.000325         if before =~ '\V'.open.'\v\s*$' && m[0] =~ '\v\s'
                                      " remove the space we inserted if the text in pairs is blank
                                      return "\<DEL>".s:right(m[1:])
   10              0.000028         else
   10   0.001309   0.000407           return s:right(m)
                                    end
    1              0.000002       end
    1              0.000029       let m = matchstr(after, '^\v\s*\zs\V'.close)
    1              0.000005       if m != ''
                                    if a:key == g:AutoPairsWildClosedPair || opt['multiline']
                                      if b:autopairs_return_pos == line('.') && getline('.') =~ '\v^\s*$'
                                        normal! ddk$
                                      end
                                      call search(m, 'We')
                                      return "\<Right>"
                                    else
                                      break
                                    end
    1              0.000002       end
   67              0.000113     end
   67              0.000152   endfor
                            
                            
                              " Fly Mode, and the key is closed-pairs, search closed-pair and jump
                              if g:AutoPairsFlyMode &&  a:key =~ '\v[\}\]\)]'
                                if search(a:key, 'We')
                                  return "\<Right>"
                                endif
                              endif
                            
                              return a:key

FUNCTION  276()
    Defined: ~\AppData\Local\nvim-data\plugged\tagbar\autoload\tagbar.vim:824
Called 793 times
Total time:   0.015107
 Self time:   0.015107

count  total (s)   self (s)
  793              0.013683     return get(self._files, a:fname, {})

FUNCTION  277()
    Defined: ~\AppData\Local\nvim-data\plugged\tagbar\autoload\tagbar.vim:830
Called 27 times
Total time:   0.001219
 Self time:   0.001219

count  total (s)   self (s)
   27              0.000208     if a:0 == 1
                                    let self._files[a:1] = a:fileinfo
   27              0.000059     else
   27              0.000238         let fname = a:fileinfo.fpath
   27              0.000296         let self._files[fname] = a:fileinfo
   27              0.000046     endif

FUNCTION  278()
    Defined: ~\AppData\Local\nvim-data\plugged\tagbar\autoload\tagbar.vim:840
Called 795 times
Total time:   0.013631
 Self time:   0.013631

count  total (s)   self (s)
  795              0.011467     return has_key(self._files, a:fname)

FUNCTION  <SNR>165_expand()
    Defined: ~\AppData\Local\nvim-data\plugged\neoterm\autoload\neoterm.vim:314
Called 12 times
Total time:   0.005028
 Self time:   0.005028

count  total (s)   self (s)
   12              0.000929   let l:command = substitute(a:command, '[^\\]\zs%\(:[phtre]\)\+', '\=expand(submatch(0))', 'g')
   12              0.000416   let l:command = substitute(l:command, '\c\\<cr>', g:neoterm_eof, 'g')
   12              0.002413   let l:path = g:neoterm_use_relative_path ? expand('%') : expand('%:p')
                            
   12              0.000704   let l:command = substitute(l:command, '[^\\]\zs%', l:path, 'g')
   12              0.000342   let l:command = substitute(l:command, '\\%', '%', 'g')
                            
   12              0.000092   return l:command

FUNCTION  tagbar#prototypes#fileinfo#new()
    Defined: ~\AppData\Local\nvim-data\plugged\tagbar\autoload\tagbar\prototypes\fileinfo.vim:1
Called 6 times
Total time:   0.009381
 Self time:   0.008069

count  total (s)   self (s)
    6              0.000059     let newobj = {}
                            
                                " The complete file path
    6              0.000051     let newobj.fpath = a:fname
                            
    6              0.001804     let newobj.bufnr = bufnr(a:fname)
                            
                                " File modification time
    6              0.001023     let newobj.mtime = getftime(a:fname)
                            
                                " Get file size
    6              0.001371     let newobj.fsize = getfsize(a:fname)
                            
                                " Get the number of lines in the file
    6              0.000073     let newobj.lnum = line('$')
                            
                                " The vim file type
    6              0.000059     let newobj.ftype = a:ftype
                            
                                " List of the tags that are present in the file, sorted according to the
                                " value of 'g:tagbar_sort'
    6              0.000035     let newobj._taglist = []
    6              0.000033     let newobj._tagdict = {}
                            
                                " Dictionary of the tags, indexed by line number in the file
    6              0.000028     let newobj.fline = {}
                            
                                " Dictionary of the tags, indexed by line number in the tagbar
    6              0.000025     let newobj.tline = {}
                            
                                " Dictionary of the folding state of 'kind's, indexed by short name
    6              0.000038     let newobj.kindfolds = {}
    6              0.000039     let newobj.typeinfo = a:typeinfo
                                " copy the default fold state from the type info
   42              0.000173     for kind in a:typeinfo.kinds
   36              0.000475         let newobj.kindfolds[kind.short] = g:tagbar_foldlevel == 0 ? 1 : kind.fold
   42              0.000093     endfor
                            
                                " Dictionary of dictionaries of the folding state of individual tags,
                                " indexed by kind and full path
    6              0.000033     let newobj.tagfolds = {}
   42              0.000113     for kind in a:typeinfo.kinds
   36              0.000255         let newobj.tagfolds[kind.short] = {}
   42              0.000066     endfor
                            
                                " The current foldlevel of the file
    6              0.000053     let newobj.foldlevel = g:tagbar_foldlevel
                            
    6   0.000593   0.000327     let newobj.addTag = function(s:add_snr('s:addTag'))
    6   0.000340   0.000188     let newobj.getTags = function(s:add_snr('s:getTags'))
    6   0.000308   0.000175     let newobj.getTagsByName = function(s:add_snr('s:getTagsByName'))
    6   0.000312   0.000176     let newobj.removeTag = function(s:add_snr('s:removeTag'))
    6   0.000281   0.000150     let newobj.reset = function(s:add_snr('s:reset'))
    6   0.000284   0.000157     let newobj.clearOldFolds = function(s:add_snr('s:clearOldFolds'))
    6   0.000284   0.000160     let newobj.sortTags = function(s:add_snr('s:sortTags'))
    6   0.000293   0.000170     let newobj.openKindFold = function(s:add_snr('s:openKindFold'))
    6   0.000276   0.000154     let newobj.closeKindFold = function(s:add_snr('s:closeKindFold'))
                            
                                " This is used during file processing. If the limit is exceeded at that
                                " point, then mark this flag for displaying to the tagbar window
    6              0.000034     let newobj.fsize_exceeded = 0
                            
    6              0.000019     return newobj

FUNCTION  <SNR>165_requires_new_instance()
    Defined: ~\AppData\Local\nvim-data\plugged\neoterm\autoload\neoterm.vim:172
Called 6 times
Total time:   0.000332
 Self time:   0.000323

count  total (s)   self (s)
    6   0.000296   0.000287   return (   empty(a:instance) &&   g:neoterm_term_per_tab &&   !has_key(t:, 'neoterm_id') ) || (   empty(a:instance) &&   !g:neoterm.has_any() )

FUNCTION  280()
    Defined: ~\AppData\Local\nvim-data\plugged\tagbar\autoload\tagbar\state.vim:27
Called 2 times
Total time:   0.000034
 Self time:   0.000034

count  total (s)   self (s)
    2              0.000031     return deepcopy(self)

FUNCTION  281()
    Defined: ~\AppData\Local\nvim-data\plugged\tagbar\autoload\tagbar\state.vim:32
Called 1196 times
Total time:   0.052112
 Self time:   0.042873

count  total (s)   self (s)
 1196   0.040393   0.031154     if !tagbar#is_paused() || a:force_current
 1196              0.007617         return self._current
                                else
                                    return self._paused
                                endif

FUNCTION  282()
    Defined: ~\AppData\Local\nvim-data\plugged\tagbar\autoload\tagbar\state.vim:41
Called 367 times
Total time:   0.004449
 Self time:   0.004449

count  total (s)   self (s)
  367              0.003791     let self._current = a:fileinfo

FUNCTION  leaderf#File#cleanup()
    Defined: ~\AppData\Local\nvim-data\plugged\LeaderF\autoload\leaderf\File.vim:52
Called 1 time
Total time:   0.005877
 Self time:   0.000072

count  total (s)   self (s)
    1   0.005867   0.000061     call leaderf#LfPy("fileExplManager._beforeExit()")

FUNCTION  284()
    Defined: ~\AppData\Local\nvim-data\plugged\neoterm\autoload\neoterm\term.vim:32
Called 6 times
Total time:   0.001317
 Self time:   0.001317

count  total (s)   self (s)
    6              0.000143   let l:winnr = bufwinnr(l:self.buffer_id)
    6              0.000044   if l:winnr > 0
    6              0.000168     let l:win_id = exists('*win_getid') ? win_getid() : 0
    6              0.000203     exec printf('%swincmd w', l:winnr)
    6              0.000525     call execute(a:cmd)
    6              0.000088     call win_gotoid(l:win_id)
    6              0.000018   end

FUNCTION  285()
    Defined: ~\AppData\Local\nvim-data\plugged\neoterm\autoload\neoterm\term.vim:42
Called 6 times
Total time:   0.001572
 Self time:   0.000255

count  total (s)   self (s)
    6   0.001558   0.000241   call l:self.vim_exec(printf('normal! %s', a:cmd))

FUNCTION  286()
    Defined: ~\AppData\Local\nvim-data\plugged\neoterm\autoload\neoterm\term.vim:46
Called 6 times
Total time:   0.002720
 Self time:   0.000747

count  total (s)   self (s)
    6              0.000083   if !empty(g:neoterm_command_prefix)
                                call l:self.termsend(l:self.termid, [g:neoterm_command_prefix . a:command[0]] + a:command[1:])
    6              0.000020   else
    6   0.000576   0.000175     call l:self.termsend(l:self.termid, a:command)
    6              0.000024   end
    6              0.000050   if g:neoterm_autoscroll
    6   0.001738   0.000166     call l:self.normal('G')
    6              0.000012   end

FUNCTION  <SNR>138_GetTagInfo()
    Defined: ~\AppData\Local\nvim-data\plugged\tagbar\autoload\tagbar.vim:3256
Called 5 times
Total time:   0.003941
 Self time:   0.003084

count  total (s)   self (s)
    5   0.000822   0.000154     let fileinfo = tagbar#state#get_current_file(0)
                            
    5              0.000042     if empty(fileinfo)
                                    return {}
    5              0.000010     endif
                            
                                " Don't do anything in empty and comment lines
    5   0.002452   0.002283     let curline = getbufline(bufnr(s:TagbarBufName()), a:linenr)[0]
    5              0.000133     if curline =~# '^\s*$' || curline[0] ==# '"'
    1              0.000006         return {}
    4              0.000007     endif
                            
                                " Check if there is a tag on the current line
    4              0.000058     if !has_key(fileinfo.tline, a:linenr)
                                    return {}
    4              0.000006     endif
                            
    4              0.000043     let taginfo = fileinfo.tline[a:linenr]
                            
                                " Check if the current tag is not a pseudo-tag
    4   0.000143   0.000121     if a:ignorepseudo && taginfo.isPseudoTag()
                                    return {}
    4              0.000006     endif
                            
    4              0.000015     return taginfo

FUNCTION  <SNR>138_GetNearbyTag()
    Defined: ~\AppData\Local\nvim-data\plugged\tagbar\autoload\tagbar.vim:3175
Called 368 times
Total time:   0.688428
 Self time:   0.611791

count  total (s)   self (s)
  368              0.002070     if s:nearby_disabled
                                    return {}
  368              0.000595     endif
                            
  368   0.054718   0.012717     let fileinfo = tagbar#state#get_current_file(a:forcecurrent)
  368              0.002749     if empty(fileinfo)
                                    return {}
  368              0.000584     endif
                            
  368              0.005658     let curline = a:0 > 0 ? a:1 : line('.')
  368              0.003448     let direction = a:0 > 1 ? a:2 : -1
  368              0.003321     let ignore_curline = a:0 > 2 ? a:3 : 0
                            
  368              0.003052     let typeinfo = fileinfo.typeinfo
  368              0.002651     let tag = {}
                            
  368              0.001971     if direction < 0
  368              0.001824         let endline = 1
  368              0.001948         let increment = -1
                                else
                                    let endline = line('$')
                                    let increment = 1
  368              0.000615     endif
                            
                                " If a tag appears in a file more than once (for example namespaces in
                                " C++) only one of them has a 'tline' entry and can thus be highlighted.
                                " The only way to solve this would be to go over the whole tag list again,
                                " making everything slower. Since this should be a rare occurence and
                                " highlighting isn't /that/ important ignore it for now.
 5727              0.036430     for line in range(curline, endline, increment)
 5615              0.055799         if has_key(fileinfo.fline, line)
 1050              0.010658             let curtag = fileinfo.fline[line]
 1050   0.076905   0.042270             if a:request ==# 'nearest-stl' && typeinfo.getKind(curtag.fields.kind).stl
  242              0.001619                 let tag = curtag
  242              0.000742                 break
  808              0.021347             elseif a:request ==# 'scoped-stl' && typeinfo.getKind(curtag.fields.kind).stl && curtag.fields.line <= curline && curline <= curtag.fields.end
                                            let tag = curtag
                                            break
  808              0.010895             elseif a:request ==# 'nearest' || (line == curline && ignore_curline == 0)
   14              0.000117                 let tag = curtag
   14              0.000034                 break
  794              0.001420             endif
 5359              0.009663         endif
 5727              0.017355     endfor
                            
  368              0.001661     return tag

FUNCTION  <SNR>138_OpenParents()
    Defined: ~\AppData\Local\nvim-data\plugged\tagbar\autoload\tagbar.vim:2753
Called 1 time
Total time:   0.055532
 Self time:   0.000100

count  total (s)   self (s)
    1              0.000004     if a:0 == 1
    1              0.000005         let tag = a:1
                                else
                                    let tag = s:GetNearbyTag('nearest', 0)
    1              0.000002     endif
                            
    1              0.000006     if !empty(tag)
    1   0.000056   0.000023         call tag.openParents()
    1   0.055432   0.000032         call s:RenderKeepView()
    1              0.000009     endif

FUNCTION  290()
    Defined: ~\AppData\Local\nvim-data\plugged\neoterm\autoload\neoterm\term\neovim.vim:7
Called 1 time
Total time:   0.023734
 Self time:   0.022845

count  total (s)   self (s)
    1   0.023731   0.022843   return termopen(s:shell(a:opts), a:opts)

FUNCTION  291()
    Defined: ~\AppData\Local\nvim-data\plugged\neoterm\autoload\neoterm\term\neovim.vim:11
Called 6 times
Total time:   0.000401
 Self time:   0.000401

count  total (s)   self (s)
    6              0.000386   return chansend(a:termid, a:command)

FUNCTION  neoterm#term#neovim#()
    Defined: ~\AppData\Local\nvim-data\plugged\neoterm\autoload\neoterm\term\neovim.vim:1
Called 1 time
Total time:   0.000017
 Self time:   0.000017

count  total (s)   self (s)
    1              0.000014   return s:neovim

FUNCTION  AutoPairsTryInit()
    Defined: ~\AppData\Local\nvim-data\plugged\auto-pairs\plugin\auto-pairs.vim:603
Called 45 times
Total time:   0.049954
 Self time:   0.005317

count  total (s)   self (s)
   45              0.000664   if exists('b:autopairs_loaded')
   38              0.000095     return
    7              0.000017   end
                            
                              " for auto-pairs starts with 'a', so the priority is higher than supertab and vim-endwise
                              "
                              " vim-endwise doesn't support <Plug>AutoPairsReturn
                              " when use <Plug>AutoPairsReturn will cause <Plug> isn't expanded
                              "
                              " supertab doesn't support <SID>AutoPairsReturn
                              " when use <SID>AutoPairsReturn  will cause Duplicated <CR>
                              "
                              " and when load after vim-endwise will cause unexpected endwise inserted.
                              " so always load AutoPairs at last
                            
                              " Buffer level keys mapping
                              " comptible with other plugin
    7              0.000034   if g:AutoPairsMapCR
    7              0.000085     if v:version == 703 && has('patch32') || v:version > 703
                                  " VIM 7.3 supports advancer maparg which could get <expr> info
                                  " then auto-pairs could remap <CR> in any case.
    7              0.000408       let info = maparg('<CR>', 'i', 0, 1)
    7              0.000052       if empty(info)
                                    let old_cr = '<CR>'
                                    let is_expr = 0
    7              0.000015       else
    7              0.000060         let old_cr = info['rhs']
    7   0.000797   0.000194         let old_cr = s:ExpandMap(old_cr)
    7              0.000201         let old_cr = substitute(old_cr, '<SID>', '<SNR>' . info['sid'] . '_', 'g')
    7              0.000058         let is_expr = info['expr']
    7              0.000044         let wrapper_name = '<SID>AutoPairsOldCRWrapper73'
    7              0.000014       endif
                                else
                                  " VIM version less than 7.3
                                  " the mapping's <expr> info is lost, so guess it is expr or not, it's
                                  " not accurate.
                                  let old_cr = maparg('<CR>', 'i')
                                  if old_cr == ''
                                    let old_cr = '<CR>'
                                    let is_expr = 0
                                  else
                                    let old_cr = s:ExpandMap(old_cr)
                                    " old_cr contain (, I guess the old cr is in expr mode
                                    let is_expr = old_cr =~ '\V(' && toupper(old_cr) !~ '\V<C-R>'
                            
                                    " The old_cr start with " it must be in expr mode
                                    let is_expr = is_expr || old_cr =~ '\v^"'
                                    let wrapper_name = '<SID>AutoPairsOldCRWrapper'
                                  end
    7              0.000012     end
                            
    7              0.000124     if old_cr !~ 'AutoPairsReturn'
    7              0.000023       if is_expr
                                    " remap <expr> to `name` to avoid mix expr and non-expr mode
    7              0.001329         execute 'inoremap <buffer> <expr> <script> '. wrapper_name . ' ' . old_cr
    7              0.000056         let old_cr = wrapper_name
    7              0.000015       end
                                  " Always silent mapping
    7              0.000629       execute 'inoremap <script> <buffer> <silent> <CR> '.old_cr.'<SID>AutoPairsReturn'
    7              0.000015     end
    7              0.000013   endif
    7   0.044257   0.000222   call AutoPairsInit()

FUNCTION  <SNR>138_HandleBufDelete()
    Defined: ~\AppData\Local\nvim-data\plugged\tagbar\autoload\tagbar.vim:3537
Called 31 times
Total time:   0.001440
 Self time:   0.001440

count  total (s)   self (s)
                                " Ignore autocmd events generated for "set nobuflisted",
   31              0.000515     let nr = str2nr(a:bufnr)
   31              0.000522     if bufexists(nr) && !buflisted(nr)
   31              0.000119         return
                                endif
                            
                                call s:known_files.rm(fnamemodify(a:bufname, ':p'))
                            
                                let tagbarwinnr = bufwinnr(s:TagbarBufName())
                                if tagbarwinnr == -1 || a:bufname =~# '__Tagbar__.*'
                                    return
                                endif
                            
                                if !s:HasOpenFileWindows()
                                    if tabpagenr('$') == 1 && exists('t:tagbar_buf_name')
                                        " The last normal window closed due to a :bdelete/:bwipeout.
                                        " In order to get a normal file window back switch to the last
                                        " alternative buffer (or a new one if there is no alternative
                                        " buffer), reset the Tagbar-set window options, and then re-open
                                        " the Tagbar window.
                            
                                        " Ignore the buffer to be deleted, just in case
                                        call setbufvar(a:bufname, 'tagbar_ignore', 1)
                            
                                        if s:last_alt_bufnr == -1 || s:last_alt_bufnr == expand('<abuf>')
                                            if argc() > 1 && argidx() < argc() - 1
                                                " We don't have an alternative buffer, but there are still
                                                " files left in the argument list
                                                next
                                            else
                                                enew
                                            endif
                                        else
                                            " Save a local copy as the global value will change
                                            " during buffer switching
                                            let last_alt_bufnr = s:last_alt_bufnr
                            
                                            " Ignore the buffer we're switching to for now, it will get
                                            " processed due to the OpenWindow() call anyway
                                            call setbufvar(last_alt_bufnr, 'tagbar_ignore', 1)
                                            execute 'keepalt buffer' last_alt_bufnr
                                            call setbufvar(last_alt_bufnr, 'tagbar_ignore', 0)
                                        endif
                            
                                        " Reset Tagbar window-local options
                                        set winfixwidth<
                            
                                        call s:OpenWindow('')
                                    elseif exists('t:tagbar_buf_name')
                                        close
                                    endif
                                endif

FUNCTION  <SNR>138_MapKeys()
    Defined: ~\AppData\Local\nvim-data\plugged\tagbar\autoload\tagbar.vim:479
Called 1 time
Total time:   0.004397
 Self time:   0.004370

count  total (s)   self (s)
    1   0.000046   0.000019     call tagbar#debug#log('Mapping keys')
                            
    1              0.000082     nnoremap <script> <silent> <buffer> <2-LeftMouse> :call <SID>JumpToTag(0)<CR>
    1              0.000068     nnoremap <script> <silent> <buffer> <LeftRelease> <LeftRelease>:call <SID>CheckMouseClick()<CR>
                            
    1              0.000056     inoremap <script> <silent> <buffer> <2-LeftMouse> <C-o>:call <SID>JumpToTag(0)<CR>
    1              0.000068     inoremap <script> <silent> <buffer> <LeftRelease> <LeftRelease><C-o>:call <SID>CheckMouseClick()<CR>
                            
    1              0.000219     let maps = [ ['jump',          'JumpToTag(0)'], ['preview',       'JumpToTag(1)'], ['previewwin',    'ShowInPreviewWin()'], ['nexttag',       'GotoNextToplevelTag(1)'], ['prevtag',       'GotoNextToplevelTag(-1)'], ['showproto',     'ShowPrototype(0)'], ['hidenonpublic', 'ToggleHideNonPublicTags()'], ['openfold',      'OpenFold()'], ['closefold',     'CloseFold()'], ['togglefold',    'ToggleFold()'], ['openallfolds',  'SetFoldLevel(99, 1)'], ['closeallfolds', 'SetFoldLevel(0, 1)'], ['incrementfolds',  'ChangeFoldLevel(1, 1)'], ['decrementfolds',  'ChangeFoldLevel(-1, 1)'], ['nextfold',      'GotoNextFold()'], ['prevfold',      'GotoPrevFold()'], ['togglesort',            'ToggleSort()'], ['togglecaseinsensitive', 'ToggleCaseInsensitive()'], ['toggleautoclose',       'ToggleAutoclose()'], ['togglepause',           'TogglePause()'], ['zoomwin',               'ZoomWindow()'], ['close',                 'CloseWindow()'], ['help',                  'ToggleHelp()'], ]
                            
    1              0.000007     let map_options = ' <script> <silent> <buffer> '
    1              0.000013     if v:version > 703 || (v:version == 703 && has('patch1261'))
    1              0.000008         let map_options .= ' <nowait> '
    1              0.000002     endif
                            
   24              0.000118     for [map, func] in maps
   23              0.000252         let def = get(g:, 'tagbar_map_' . map)
   23              0.000183         if type(def) == type('')
   15              0.000096             let keys = [def]
    8              0.000013         else
    8              0.000029             let keys = def
   23              0.000034         endif
   55              0.000173         for key in keys
   32              0.000174             if !empty(key)
   32              0.001989                 execute 'nnoremap' . map_options . key . ' :call <SID>' . func . '<CR>'
   32              0.000060             endif
   55              0.000089         endfor
   23              0.000064         unlet def
   24              0.000038     endfor
                            
    1              0.000008     let b:tagbar_mapped_keys = 1

FUNCTION  tagbar#ToggleWindow()
    Defined: ~\AppData\Local\nvim-data\plugged\tagbar\autoload\tagbar.vim:3759
Called 1 time
Total time:   1.697933
 Self time:   0.000070

count  total (s)   self (s)
    1              0.000025     let flags = a:0 > 0 ? a:1 : ''
    1   1.697898   0.000035     call s:ToggleWindow(flags)

FUNCTION  <SNR>165_after_open()
    Defined: ~\AppData\Local\nvim-data\plugged\neoterm\autoload\neoterm.vim:84
Called 1 time
Total time:   0.073458
 Self time:   0.000323

count  total (s)   self (s)
    1              0.000012   let b:neoterm_id = a:instance.id
    1              0.000009   let b:term_title = a:instance.name
    1   0.073074   0.000051   setf neoterm
    1   0.000104   0.000087   setlocal nonumber norelativenumber signcolumn=auto
                            
    1              0.000012   if g:neoterm_fixedsize
                                setlocal winfixheight winfixwidth
    1              0.000003   end
                            
    1              0.000008   if g:neoterm_keep_term_open
    1   0.000029   0.000025     setlocal bufhidden=hide
    1              0.000004   end
                            
    1              0.000008   if g:neoterm_autoinsert
                                startinsert
    1              0.000009   elseif !g:neoterm_autojump
    1   0.000149   0.000058     call neoterm#origin#return(a:instance.origin)
    1              0.000003   end

FUNCTION  remote#define#notify()
    Defined: ~\scoop\apps\neovim\0.6.1\share\nvim\runtime\autoload\remote\define.vim:184
Called 1068 times
Total time:   0.152632
 Self time:   0.152632

count  total (s)   self (s)
 1068              0.019997   if get(s:busy, a:chan, 0) > 0
                                let pending = get(s:pending_notifications, a:chan, [])
                                call add(pending, deepcopy(a:000))
                                let s:pending_notifications[a:chan] = pending
 1068              0.003086   else
 1068              0.081564     call call('rpcnotify', [a:chan] + a:000)
 1068              0.003927   endif

FUNCTION  neoterm#next_id()
    Defined: ~\AppData\Local\nvim-data\plugged\neoterm\autoload\neoterm.vim:332
Called 1 time
Total time:   0.000222
 Self time:   0.000222

count  total (s)   self (s)
    1              0.000142   let l:ids = map(a:ids, {_, v -> str2nr(v) })
                            
    1              0.000034   for i in range(1, max(l:ids) + 1)
    1              0.000016     if index(l:ids, i) < 0
    1              0.000010       let l:last_id = i
    1              0.000007       return l:last_id
                                end
                              endfor
                            
                              return a:last_id + 1

FUNCTION  <SNR>3_LoadFTPlugin()
    Defined: ~\scoop\apps\neovim\current\share\nvim\runtime\ftplugin.vim:14
Called 5 times
Total time:   0.232233
 Self time:   0.151623

count  total (s)   self (s)
    5              0.000095     if exists("b:undo_ftplugin")
                                  exe b:undo_ftplugin
                                  unlet! b:undo_ftplugin b:did_ftplugin
    5              0.000013     endif
                            
    5              0.000080     let s = expand("<amatch>")
    5              0.000033     if s != ""
    5              0.000176       if &cpo =~# "S" && exists("b:did_ftplugin")
                            	" In compatible mode options are reset to the global values, need to
                            	" set the local values also when a plugin was already used.
                            	unlet b:did_ftplugin
    5              0.000011       endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "aaa" and then "bbb".
   10              0.000225       for name in split(s, '\.')
    5   0.159265   0.078655         exe 'runtime! ftplugin/' . name . '.vim ftplugin/' . name . '_*.vim ftplugin/' . name . '/*.vim'
                                    " Load lua ftplugins
    5              0.071787         exe printf('runtime! ftplugin/%s.lua ftplugin/%s_*.lua ftplugin/%s/*.lua', name, name, name)
   10              0.000087       endfor
    5              0.000019     endif

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
  390  10.648982   0.931825  <SNR>138_AutoUpdate()
   27   7.865219   0.352867  <SNR>138_ProcessFile()
  456   5.552949   0.070718  <SNR>138_do_delayed_update()
   29   5.350040   0.039596  <SNR>138_ExecuteCtags()
   29   5.309144   0.009229  <SNR>138_run_system()
   27   5.113102   0.032966  <SNR>138_ExecuteCtagsOnFile()
  543   2.106337   0.387538  <SNR>138_ParseTagline()
    2   2.080089   0.053367  SidePanelToggleManagement()
   36   1.935054   0.761852  <SNR>5_SynSet()
  543   1.718799   0.498600  <SNR>138_ProcessTag()
    1   1.697933   0.000070  tagbar#ToggleWindow()
    1   1.697863   0.032721  <SNR>138_ToggleWindow()
    1   1.663793   0.017356  <SNR>138_OpenWindow()
    5   1.626078   0.005591  NeotermTerminalPython()
   45   1.534874   0.023116  <SNR>9_detect_indent()
   46   1.511663   1.457607  <SNR>9_guess()
    1   1.286510   0.000733  <SNR>138_Init()
 1364   1.266189   1.179830  <SNR>69_Highlight_Matching_Pair()
  543   0.953904   0.156374  tagbar#prototypes#normaltag#new()
  368   0.868436   0.123358  <SNR>138_HighlightTag()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
   46   1.511663   1.457607  <SNR>9_guess()
 1364   1.266189   1.179830  <SNR>69_Highlight_Matching_Pair()
  390  10.648982   0.931825  <SNR>138_AutoUpdate()
   36   1.935054   0.761852  <SNR>5_SynSet()
  368   0.688428   0.611791  <SNR>138_GetNearbyTag()
  543   1.718799   0.498600  <SNR>138_ProcessTag()
  602   0.800061   0.492676  tagbar#prototypes#basetag#new()
  407   0.490176   0.478251  <SNR>138_IsValidFile()
  543   2.106337   0.387538  <SNR>138_ParseTagline()
   27   7.865219   0.352867  <SNR>138_ProcessFile()
11438              0.307385  <SNR>144_add_snr()
   92   0.299628   0.286824  remote#define#request()
  374   0.390973   0.273794  <SNR>138_SetStatusLine()
    3              0.159840  <SNR>138_CheckFTCtags()
  543   0.953904   0.156374  tagbar#prototypes#normaltag#new()
    1   0.169694   0.154518  tagbar#types#ctags#init()
 1068              0.152632  remote#define#notify()
    5   0.232233   0.151623  <SNR>3_LoadFTPlugin()
  397   0.180328   0.146878  <SNR>138_add_tag_recursive()
  368   0.868436   0.123358  <SNR>138_HighlightTag()

